               Е. А. КОНОВА,
               Г. А. ПОЛЛАК




 АЛГОРИТМЫ
И ПРОГРАММЫ.
  ЯЗЫК С++
           Издание второе, стереотипное




                    ДОПУЩЕНО
УМО по образованию в области прикладной информатики
     в качестве учебного пособия для студентов,
             обучающихся по направлению
             «Прикладная информатика»




                САНКТПЕТЕРБУРГ
               МОСКВА•КРАСНОДАР
                      2017
ББК 32.973.26018.1я73
К 64
       Конова Е. А., Поллак Г. А.
К 64       Алгоритмы и программы. Язык С++: Учебное посо
       бие. — 2е изд., стер. — СПб.: Издательство «Лань», 2017. —
       384 с.: ил. — (Учебники для вузов. Специальная литера
       тура).

       ISBN 9785811420209
            При изложении материала авторы используют методику обучения
       от алгоритмов к программам, поэтому вначале излагаются сведения об
       алгоритмах с примерами реализации типовых алгоритмов. Изучение
       основ языка программирования С++опирается на полученные знания.
       Примеры можно решать в любой среде разработчика, поддерживающей
       язык С++, но авторами примеры отлажены в Visual Studio 2013. Коды
       программ соответствуют стандарту C++11 (ISO/IEC 14882:2011),
       разработаны в консольных приложениях на основе шаблона «Пустой
       проект».
            В задачах практикума предлагаются как задачи, использующие
       типовые алгоритмы, так и содержательные, для которых приведено
       только вербальное описание. Пособие предназначено для студентов
       направления подготовки «Прикладная информатика» и других, может
       быть рекомендовано для самостоятельного изучения, так как не требует
       предварительных знаний о языках программирования.

                                           ББК 32.973.26018.1я73

                                 Рецензенты:
       В. И. ШИРЯЕВ — доктор технических наук, профессор, зав.
       кафедрой «Системы управления» ЮжноУральского государ
       ственного университета; И. В. САФРОНОВА — кандидат
       технических наук, доцент, зав. кафедрой прикладной информатики
       и математики Уральского социальноэкономического института
       (филиала) Академии труда и социальных отношений.




                                    Обложка
                                 Е. А. ВЛАСОВА

                Охраняется законом РФ об авторском праве.
               Воспроизведение всей книги или любой ее части
             запрещается без письменного разрешения издателя.
                     Любые попытки нарушения закона
                  будут преследоваться в судебном порядке.

                                   © Издательство «Лань», 2017
                                   © Е. А. Конова, Г. А. Поллак, 2017
                                   © Издательство «Лань»,
                                     художественное оформление, 2017
                                         Введение




А   вторы прекрасно понимают трудности, которые воз-
    никают у начинающего программиста, поэтому учеб-
ное пособие предназначено, в первую очередь, для тех,
кто только начинает изучать программирование.
    В разработке методики изложения авторы придер-
живались определения, данного Н. Виртом [1]: Програм-
ма = Алгоритмы + Данные.
    Согласно этому определению программы представ-
ляют собой конкретные формулировки абстрактных ал-
горитмов, основанные на конкретных представлениях
данных. Именно поэтому авторами уделяется большое
внимание как разработке алгоритмов, так и концепции
данных языка программирования.
    Учебное пособие состоит из трех глав.
    В первой главе приводятся сведения о типовых алго-
ритмах обработки данных безотносительно к языку про-
граммирования. Приведены примеры решения некото-
рых классов задач, где для каждой задачи разработан ал-
горитм в виде блок-схемы с пояснениями, набор тестовых
данных и таблица исполнения алгоритма. Приводимые
способы решения задач по возможности являются рацио-
нальными, но не претендуют на то, чтобы быть наилуч-
шими.
    В качестве языка программирования выбран класси-
ческий С++. Краткое описание синтаксических правил
С++ и механизмов реализации приведено во второй гла-
ве. Материал разбит на темы, позволяющие изучать язык
по принципу «от простого к сложному». В изложении ав-
торы опираются на материал первой главы, приводя про-
граммную реализацию всех алгоритмов. Добавлено мно-
4                                               Введение



го примеров, иллюстрирующих как особенности языка
С++, так и некоторые алгоритмические приемы решения
задач. В качестве методологии выбрано структурное про-
граммирование на основе функций.
    Все приведенные программы проверены на ра-
ботоспособность авторами в среде проектирования
Visual Studio 2013. Коды программ соответствуют стан-
дарту C++11 (ISO/IEC 14882:2011) и разработаны в кон-
сольных приложениях на основе шаблона «Пустой про-
ект».
    Третья глава — это практикум, который содержит
задания для самостоятельного выполнения. В практику-
ме авторы опираются на материал второй главы. Третья
глава состоит из десяти основных тем. В каждой теме есть
краткое теоретическое введение, а также примеры про-
грамм решения некоторых задач. В каждом примере на-
зван типовой алгоритм и приведен код программы с под-
робными комментариями.
    Примеры и типовые решения помогут начинающим
в освоении практических приемов программирования
и выработке собственного стиля.
    В каждой теме для самостоятельного решения предла-
гаются по 30 вариантов задач примерно одинакового уров-
ня сложности. Особый интерес, по нашему мнению, пред-
ставляют содержательные задачи, в которых постановка
задачи выполнена на вербальном уровне, т. е. не формали-
зована. Здесь студент должен самостоятельно осмыслить
задачу, формализовать ее, предложить структуру данных
и выбрать или разработать алгоритм решения. Опыт по-
казывает, что часто именно этот этап в практическом про-
граммировании является наиболее трудным.
    Материал пособия консолидирует многолетний опыт
работы авторов в преподавании различных курсов про-
граммирования.
    Соответствует ФГОС ВПО третьего поколения для на-
правления «Прикладная информатика».
    Не требуется каких-либо предварительных знаний
о языках программирования, поэтому пособие может
быть рекомендовано для самостоятельного изучения.
                                                Гл ава 1

                  Основы алгоритмизации




   1.1. Определение алгоритма 
   и его свойства


П   од алгоритмом понимается точное предписание, за-
    дающее последовательность действий, которая ведет
от произвольного исходного данного (или от некоторой со-
вокупности возможных для данного алгоритма исходных
данных) к достижению полностью определяемого этим
исходным данным результата.
    Алгоритм должен обладать определенными свойства-
ми, наличие которых гарантирует получение решения за-
дачи исполнителем.
    Дискретность. Решение задачи должно быть разбито
на элементарные действия. Запись отдельных действий
реализуется в виде упорядоченной последовательности
отдельных команд, образующих дискретную структу-
ру алгоритма. Это свойство непосредственно отражено
в определении алгоритма.
    Понятность. На практике любой алгоритм предна-
значен для определенного исполнителя, и любую команду
алгоритма исполнитель должен уметь выполнить.
    Определенность (детерминированность). Каждая ко-
манда алгоритма должна определять однозначные дей-
ствия исполнителя. Результат их исполнения не должен
зависеть от факторов, не учтенных в алгоритме явно. При
одних и тех же исходных данных алгоритм должен давать
стабильный результат.
    Массовость. Разработанный алгоритм должен давать
возможность получения результата при различных ис-
ходных данных для однотипных задач.
6                                                  Гл а в а 1



    Например, пользуясь алгоритмом решения квадрат-
ного уравнения, можно находить его корни при любых
значениях коэффициентов.
    Свойство массовости полезное, но не обязательное
свойство алгоритма, так как интерес представляют и ал-
горитмы, пригодные для решения единственной задачи.
    Результативность (конечность). Это свойство пред-
полагает обязательное получение результата решения за-
дачи за конечное число шагов. Под решением задачи по-
нимается и сообщение о том, что при заданных значениях
исходных данных задача решения не имеет.
    Если решить задачу при заданных исходных данных
за конечное число шагов не удается, то говорят, что алго-
ритм «зацикливается».
    Смысл условий дискретности, понятности и опреде-
ленности ясен: их нарушение ведет к невозможности
выполнения алгоритма. Остальные условия не столь
очевидны. Для сложных алгоритмов выполнить исчер-
пывающую проверку результативности и корректности
невозможно. Это равносильно полному решению задачи,
для которой создан алгоритм, вручную.
    Можно сформулировать общие правила, руководствуясь
которыми следует записывать алгоритм решения задачи.
    1. Выделить величины, являющиеся исходными дан-
ными для задачи.
    2. Разбить решение задачи на такие команды, каждую
из которых исполнитель может выполнить однозначно.
    3. Указать порядок выполнения команд.
    4. Задать условие окончания процесса решения задачи.
    5. Определить, что является результатом решения за-
дачи в каждом из возможных случаев.
    Хотя алгоритмы обычно предназначены для автоматиче-
ского выполнения, они создаются и разрабатываются людь-
ми. Поэтому первоначальная запись алгоритма обычно про-
изводится в форме, доступной для восприятия человеком.
    Самой простой является словесная форма записи ал-
горитмов на естественном языке. В этом виде алгоритм
представляет собой описание последовательности этапов
обработки данных, изложенное в произвольной форме.
Ос н о в ы а л г о р и т м и з а ц и и                                            7


Словесная форма удобна для человеческого восприятия,
но страдает многословностью и неоднозначностью.
    Когда запись алгоритма формализована частично, то
используется псевдокод. Он содержит как элементы есте-
ственного языка, так и формальные конструкции, описы-
вающие базовые алгоритмические структуры. Эти кон-
струкции называются служебными словами. Формаль-
ного определения псевдокода или строгих правил записи
алгоритмов в таком формате не существует.
    Графическая форма представления алгоритма явля-
ется более компактной. Алгоритм изображается в виде
последовательности связанных между собой блоков, каж-
дый из которых соответствует выполнению одного или
нескольких действий. Графическое представление алго-
ритма называется блок-схемой. Блок-схема определяет
структуру алгоритма.
    Графические обозначения блоков стандартизованы.
Некоторые из часто используемых блоков представлены
в таблице 1.1.
                                                                     Та блица 1.1
                  Изображение основных блоков на блок-схеме
       Обозначение блока                                Пояснение


                                         Процесс (вычислительное действие, реа-
                                         лизованное операцией присваивания)



                                         Решение (проверка условия, реализую-
                                         щая условный переход)



                                         Начало, конец алгоритма



                                         Ввод-вывод в общем виде



                                         Модификация (начало цикла с параме-
                                         тром)
8                                              Гл а в а 1



    Отдельные блоки соединяются линиями переходов,
которые определяют очередность выполнения действий.
Направление линий сверху вниз или слева направо при-
нимается за основное.
    Алгоритм, записанный на языке программирования,
называется программой. При использовании этих языков
запись алгоритма абсолютно формальна и пригодна для
выполнения на ЭВМ. Отдельная конструкция языка про-
граммирования называется оператором. Программа —
это упорядоченная последовательность операторов.

    1.2. Базовые алгоритмические 
    конструкции
    Число реализованных конструкций конечно в любом
языке программирования. Структурной элементарной
единицей алгоритма является команда, обозначающая
один элементарный шаг обработки или отображения ин-
формации. Простая команда на языке блок-схем изобра-
жается в виде функционального блока «процесс», кото-
рый имеет один вход и один выход. Из команд проверки
условий и простых команд образуются составные коман-
ды, имеющие более сложную структуру, но тоже один
вход и один выход.
    Алгоритм любой сложности может быть представлен
комбинацией трех базовых структур:
  • следование;
  • ветвление (в полной и сокращенной форме);
  • цикл (с предусловием или постусловием).
    Характерной особенностью этих структур является
наличие у них одного входа и одного выхода.

    1.2.1. Линейные алгоритмы
    Базовая структура «следование» означает, что не-
сколько операторов выполняются последовательно друг
за другом, и только один раз за время выполнения про-
граммы. Структура «следование» используется для реа-
лизации задач, имеющих линейный алгоритм решения.
Это означает, что такой алгоритм не содержит проверок
Ос н о в ы а л г о р и т м и з а ц и и                             9


условий и повторений, действия в нем выполняются по-
следовательно, одно за другим.
   Пример 1.1. Построить блок-схему алгоритма вычисле-
ния высот треугольника со сторонами a, b, c по формулам:

                        ha = ? ? ? p ( p ? a) ( p ? b) ( p ? c);
                              2
                             ?a?

                        ha = ? ? ? p ( p ? a) ( p ? b) ( p ? c);
                              2
                             ?b?

                        ha = ? ? ? p ( p ? a) ( p ? b) ( p ? c),
                              2
                             ?c?
             (a + b + c)
где p =                  — полупе-
                 2
риметр.
   Для того чтобы не вычис-
лять три раза одно и то же
значение, введем вспомога-
тельную величину:
    t = 2 p ( p ? a) ( p ? b) ( p ? c).
    Блок 1. Ввод значений
сторон треугольника.
    Блок 2. Вычисление по-
лупериметра.
    Блок 3. Вычисление вспо-
могательной величины t.
    Блок 4. Вычисление вы-
сот, опущенных на стороны
а, b, c.
    Блок 5. Вывод результа-
тов.

      1.2.2. Разветвляющиеся алгоритмы

   Второй базовой структурой является «ветвление». Эта
структура обеспечивает, в зависимости от результата про-
верки условия, выбор одного из альтернативных путей
работы алгоритма, причем каждый из путей ведет к обще-
10                                                        Гл а в а 1



му выходу, так что работа алгоритма будет продолжаться
независимо от того, какой путь будет выбран.
   Существует структура с полным и неполным ветвле-
нием.
   Структура с полным ветвлением (если — то — иначе)
записывается так:
Если < условие >
то <действия 1>
иначе <действия 2>
Все если
   Команда выполняется так: если <условие> является ис-
тинным, то выполняются <действия 1>, записанные после
ключевого слова то, если <условие> является ложным, то
выполняются <действия 2>, записанные после слова иначе.
   Структура с неполным ветвлением (если — то) не со-
держит части, начинающейся со слова иначе:
Если <условие>
то <действия 1>
Все если
    Команда выполняется так: если <условие> является
истинным, то выполняются <действия 1>, записанные по-
сле ключевого слова то.
    Блок-схема алгоритма с ветвлением выглядит так:




     Полное ветвление. Структура         Неполное ветвление.
         Если — То — Иначе               Структура Если — То

     Пример 1.2. Вычислить значение функции
                       ?x + a, при x < 10;
                       ?
                   y = ?x + b, при 10 ? x ? 20;
                       ??x + c, при x > 20.
Ос н о в ы а л г о р и т м и з а ц и и                                   11


      Дано: x, a, b, c — произвольные числа.
      Найти: y.
      Представим задачу графически на числовой оси
            x < 10                       10 ? x ? 20          x > 20
                            10                         20
          y=x+a                            y=x+b              y=x+c
         1 интервал                      2 интервал         3 интервал

    Так как значение переменной x вводится произволь-
но, то оно может оказаться в любом из трех интервалов.
    Приведем блок-схему.




    Блок 1. Ввод исходных данных.
    Блок 2. Проверка введенного значения. Если х < 10
(выход «Да»), то точка находится в первом интервале.
В противном случае х ? 10 (выход «Нет»), и точка может
оказаться во втором или третьем интервале.
    Блок 4. Проверка ограничения значения х справа
(х < 20). Если условие выполняется (выход «Да»), то х на-
ходится во втором интервале, иначе х ? 20, и точка нахо-
дится в третьем интервале.
    Блоки 3, 5 и 6. Вычисление значения y.
12                                                  Гл а в а 1


     1.2.3. Циклические алгоритмы
    При составлении алгоритмов решения большинства
задач возникает необходимость в неоднократном повто-
рении одних и тех же команд. Алгоритм, составленный
с использованием многократных повторений одних и тех
же действий (циклов), называется циклическим. Однако
слово «неоднократно» не означает «до бесконечности».
Организация циклов, никогда не приводящая к останов-
ке в выполнении алгоритма («зацикливание» алгоритма),
нарушает требование его результативности — получения
результата за конечное число шагов.
    Блок, для выполнения которого организуется цикл,
называется телом цикла. Остальные операторы служат
для управления процессом повторения вычислений: это
начальные установки, проверка условия продолжения
цикла и модификация параметра цикла. Один проход
цикла называется итерацией.




     Цикл с предусловием            Цикл с постусловием


    Начальные установки служат для того, чтобы до вхо-
да в цикл задать значения переменных, которые в нем ис-
пользуются.
    Проверка условия продолжения цикла выполняется
на каждой итерации либо до тела цикла (цикл с предусло-
Ос н о в ы а л г о р и т м и з а ц и и                        13


вием), либо после тела цикла (цикл с постусловием). Тело
цикла с постусловием всегда выполняется хотя бы один
раз. Проверка необходимости выполнения цикла с пред-
условием делается до начала цикла, поэтому возможно,
что он не выполнится ни разу.
    При конструировании циклов следует соблюдать обя-
зательное условие результативности алгоритма (т. е. его
окончания за конечное число шагов). Практически это
означает, что в условии должна быть переменная, значе-
ние которой изменяется в теле цикла. Причем, изменяет-
ся таким образом, чтобы условие в конечном итоге пере-
стало выполняться. Такая переменная называется управ-
ляющей переменной цикла или параметром цикла.
    Еще один вид циклов — цикл с параметром, или
арифметический цикл. Тело цикла выполняется, пока
параметр цикла i пробегает множество значений от на-
чального (In) до конечного (Ik).
    Переменная i определяет количество повторений тела
цикла S. Если шаг изменения значения параметра цикла
обозначить через ?I, то количество повторений тела цик-
ла n можно вычислить по формуле
                                                ?
                                         n = I k I n + 1.
                                                ?I
    Если параметр цикла i изменяется с шагом 1, то шаг
может не указываться.
    Цикл выполняется так: начальное значение параметра
цикла i равно In. Если i ? Ik, выполняется тело цикла S, после
чего параметр цикла увеличивается на 1 с помощью опера-
тора присваивания i = i + 1, и сно-
ва проверяется условие i ? Ik.
    Пример 1.3. Дано целое поло-
жительное число n. Вычислить
факториал этого числа. Извест-
но, что факториал любого целого
положительного числа n опреде-
ляется как произведение чисел от 1 до заданного числа n:
                                  n! = 1 ? 2 ? 3 ? ... ? n.
14                                                       Гл а в а 1



    По определению 0! = 1 и 1! = 1.
    Задача решается с помощью циклического алгорит-
ма. Введем следующие обозначения: N — заданное число,
F — факториал числа, R — параметр цикла. Составим два
варианта алгоритма: с использованием цикла с предусло-
вием и цикла с параметром.
    Правильность алгоритма можно проверить, если вы-
полнить его формально «вручную». Выполним алгоритм
при n = 4.




         Цикл с предусловием            Цикл с параметром

         Цикл с предусловием            Цикл с параметром
     R        R <= N       F        R      R <= N        F
     1         Да       1?1=1       1       Да        1?1=1
     2         Да       1?2=2       2       Да        1?2=2
     3         Да      2?3=6        3       Да       2?3=6
     4         Да      6 ? 4 = 24   4       Да       6 ? 4 = 24
     5         Нет      — (кц)      5       Нет       — (кц)


    Итак, при решении данной задачи выполнение цикла
с предусловием ничем не отличается от выполнения цик-
ла с параметром. При R = 5 произойдет выход из цикла
и окончательное значение 4! = 24.
Ос н о в ы а л г о р и т м и з а ц и и                       15


    В чем же отличие? Посмотрим на структуру этих ци-
клов. В цикле пока начальное значение параметра цик-
ла R задается перед входом в цикл, в теле цикла органи-
зовано изменение параметра цикла командой R = R + 1,
условие R ? N определяет условие продолжение цикла.
В цикле с заданным числом повторений эти же команды
неявно заданы в операторе заголовка цикла.
    Пример 1.4. Пусть а0 = 1; аk = k ? ak–1 + 1/k, k = 1, 2, …
Дано натуральное число n. Получить аn.
    Дано: а0 — первый член последовательности; n — но-
мер члена последовательности, значение которого требу-
ется найти.
    Найти: аn — n-й член последовательности.
    Математическая модель. Посмотрим, как изменяет-
ся значение члена последовательности при изменении зна-
чения k. При k = 1 а1 = 1 ? a0 + 1. При k = 2 а2 = 2 ? a1 + 1/2.
При k = 3а3 = 3 ? a2 + 1/3. Выполнив указанные вычисле-
ния n раз, получим искомое значение аn. В задачах та-
кого типа не требуется хранить результаты вычислений
на каждом шаге. Поэтому можно использовать простые
переменные.
    Обозначим через a — произвольный член последова-
тельности. Тогда формула для вычисления члена после-
довательности будет выглядеть так:
                                         а = k ? a + 1/k.
    В этой формуле значение а, стоящее справа от зна-
ка «=», определяется на предыдущем шаге вычисления,
а значение а, стоящее в левой части выражения, опреде-
ляется на данном шаге и заменяет в памяти предыдущее
значение.
    Переменная а — вещественного типа; переменные k
и n — целого типа.
    Приведем словесное описание и блок-схему алгоритма.
    Блок 1. Ввод количества членов последовательности n.
    Блок 2. Присваивание начального значения a = 1.
    Блок 3. Арифметический цикл. Начальное значение
параметра цикла k равно 1, конечное значение равно n,
шаг изменения параметра — 1.
16                                                         Гл а в а 1



   Блок 4. Выполнение тела цикла. Для каждого значе-
ния k вычисляется выражение а = k * a + 1/ k.
   Блок 5. Вывод значения а.




   Пример 1.5. Даны натуральное число n, действитель-
ное число х. Вычислить сумму:
                               n     i
                              ? xi! .
                              i =1

    Дано: n — количество слагаемых; x — действительное
число.
    Найти: S — сумму чисел.
    Математическая модель. Обозначим с — слагаемое.
Начальное значение суммы S = 0.
    Количество слагаемых известно и равно n. Следова-
тельно, можно использовать арифметический цикл.
    Выведем рекуррентное соотношение, определяющее
формулу, по которой вычисляется слагаемое на очеред-
ном шаге выполнения цикла.
    Вспомним, что факториал числа n определяется как
произведение чисел от 1 до n включительно. Следователь-
но, i! = 1 ? 2 ? 3 ? 4 ? … ? i, по определению 0! = 1, 1! = 1. Для
вывода рекуррентного соотношения вычислим несколько
значений слагаемых.
Ос н о в ы а л г о р и т м и з а ц и и                                    17

         i = 1,    c = x1/1! = x;
         i = 2,    c = x2/2! = x2/ (1 ? 2) = c ? x/2 = c ? x/i;
         i = 3,    c = x3/3! = x3/ (1 ? 2 ? 3) = c ? x/3 = c ? x/i;
         i = 4,    c = x4/4! = x4/ (1 ? 2 ? 3 ? 4) = c ? x/4 = c ? x/i.
    В правой части всех формул значение с равно значе-
нию, вычисленному на предыдущем шаге. Итак, получа-
ем следующее соотношение, которое будем использовать
в алгоритме с = c ? x/i, где начальное значение с = 1, i = 1,
2, …, n.
    Сумму накапливаем, используя формулу S = S + с. За-
писанное соотношение определяет, что значение суммы
увеличивается на величину слагаемого при каждом по-
вторении цикла. Начальное значение суммы равно 0.
    Переменные i, n — целого типа, переменные c, x, S —
вещественного типа.
    Приведем словесное описание и блок-схему алгоритма.
    Блок 1. Ввод x, n.
    Блок 2. Присваивание начальных значений S = 0, c = 1.
    Блок 3. В цикле для всех значений параметра цикла i
вычисляем тело цикла (блок 4):
                          с = с * x/i;
                          S = S + c.
    Блок 5. Вывод суммы S.
18                                                         Гл а в а 1


     1.2.4. Итерационные циклы
    Все циклические алгоритмы можно разделить на две
группы: циклы с заранее известным количеством повто-
рений и циклы с заранее неизвестным количеством повто-
рений. Циклы с заранее неизвестным количеством повто-
рений называются итерационными. Итерационный про-
цесс — это последовательное приближение к результату
за некоторое количество шагов.
    Рассмотрим блок-схемы итерационных циклов на
примере.
    Пример 1.6. Даны действительные числа x, ? (x ? 0,
? > 0). Вычислить сумму с точностью ?:
                             ?     k
                            ? 2kx? k !
                            k=0

    Вычисление бесконечной суммы с заданной точно-
стью ? означает, что требуемая точность достигнута,
когда вычислена сумма нескольких первых слагаемых
и очередное слагаемое оказалось по модулю меньше, чем
?, — это и все последующие слагаемые можно не учиты-
вать.
    Пусть с — слагаемое, S — сумма, F — факториал чис-
ла k.
    Математическая модель. Выведем рекуррентное со-
отношение, используя способ, показанный в примере 1.5.
    Для вычисления факториала числа можно восполь-
зоваться формулой F = F ? k, которую мы вывели ранее.
Начальное значение F = 1. Проверьте правильность этой
формулы, последовательно вычисляя значение k!.
    Выведем общую формулу для вычисления одного сла-
гаемого (без учета факториала числа k):
            k = 0,   с = x0/20 = 1;
            k = 1,   с = x1/21 = x/2;
            k = 2,   с = x2/22 = (x/2) (x/2) = с ? x/2;
            k = 3,   с = x3/23 = (x2/4) (x/2) = с ? x/2;
            k = 4,   с = x4/24 = (x3/8) (x/2) = с ? x/2.
   Обобщая, для произвольного значения k можно запи-
сать c = с ? x/2, где значение переменной с в правой части
Ос н о в ы а л г о р и т м и з а ц и и                19


формулы вычисляется на предыдущем шаге. Начальное
значение с = 1 при k = 0.
    Сумму вычисляем по формуле S = S + c / F (см. при-
мер 1.5). Начальное значение S = 0.
    В данной задаче следует использовать цикл с предусло-
вием, потому что количество слагаемых будет зависеть от
введенного значения x и требуемой точности вычислений ?.
    Переменная k — целого типа, переменные x, ?, c, S —
вещественного типа. Переменную F следует взять веще-
ственного типа, так как диапазон целых чисел ограничен,
а факториал быстро возрастает с ростом значения k.
    Приведем словесное описание и блок-схему алгоритма.
    Блок 1. Ввод исходных данных x и ?.
    Блок 2. Присваивание начальных значений F = 1,
S = 0, с = 1. Параметр цикла k = 1.
    Блок 3. Прежде чем вычислять сумму, определим вы-
полнение условия продолжения цикла. По условию, когда
очередное слагаемое окажется по модулю меньше задан-
ной точности ?, вычисления следует прекратить. Слагае-
мым в нашем случае является дробь c/F. Так как может
быть введено отрицательное значение х, то использована
функция Abs(), определяющая модуль числа.
    Блок 4. Если требуемая точность вычислений не достиг-
нута (выход «Да» блока 3), выполняем тело цикла, опреде-
ляем новые значения переменных и продолжаем цикл.
    Блок 5. Как только требуемая точность вычисления
достигнута (выход «Нет» блока 3), завершаем цикл и пе-
чатаем значение переменной S.
20                                               Гл а в а 1



    Цикл, который мы использовали при решении задачи,
называется итерационным. Особенностью такого цикла
является то, что число его повторений зависит от выпол-
нения условия, записанного при входе в цикл. В итераци-
онных алгоритмах необходимо обеспечить обязательное
достижение условия выхода из цикла (сходимость ите-
рационного процесса). В противном случае произойдет
«зацикливание» алгоритма. Управление итерационным
циклом организует программист, который должен поза-
ботиться и об инициализации управляющей переменной,
и об ее приращении, и об условии завершения цикла.

     1.3. Алгоритмы, использующие 
     одномерные массивы
    Массив — это упорядоченный набор однотипных зна-
чений (элементов массива). Каждый массив имеет имя,
что дает возможность различать массивы между собой
и обращаться к ним по имени.
    Каждый элемент массива имеет три характеристики:
    1) имя, совпадающее с именем массива;
    2) индекс — целое число или множество целых чи-
сел, однозначно определяющее местоположение элемента
в массиве. В качестве индекса может использоваться так-
же переменная или арифметическое выражение целого
типа. Примеры индексов: 3, 15, i, j, i – 1, j + 2;
    3) значение — фактическое значение элемента, опре-
деленное его типом.
    Элементы массива могут использоваться произвольно
и являются одинаково доступными. Доступ к элементам
массива производится по его индексу.
    Массивы могут быть одномерными и многомерными.
В этом подпараграфе рассмотрим некоторые алгоритмы
на одномерных массивах.

     1.3.1. Ввод и вывод элементов массива
   Одномерный массив определяется именем и числом
элементов (размером), и мы обозначим его a[n], где a —
имя массива; n — число элементов массива. Например,
Ос н о в ы а л г о р и т м и з а ц и и                                          21


a[10], где а — имя массива; 10 — число элементов в мас-
сиве.
   Каждый элемент одномерного массива имеет один ин-
декс, равный порядковому номеру элемента в массиве.
Например, массив из 10 элементов выглядит так:
            Индекс          1     2      3    4   5   6    7    8    9   10
           Значение         3     0      15   4   6   –2   11   0   –9    7

    a[1] = 3; a[5] = 6; a[7] = 11; a[9] = –9; a[10] = 7.
   Так как всегда известно количество элементов в мас-
сиве, то для ввода и вывода его элементов используется
цикл с заданным числом повторений.
   Мы рассматриваем массив, состоящий из произволь-
ного числа элементов. Поэтому, прежде чем задать значе-
ния элементов массива, требуется ввести количество эле-
ментов массива n.
   Вывод элементов также производится с использовани-
ем цикла с заданным числом повторений.




                                                      Вывод элементов массива

      Ввод элементов массива


   Здесь и далее будем обозначать через i — текущий ин-
декс элемента массива. Он же будет являться параметром
цикла, так как количество повторений цикла зависит от
количества элементов в массиве.
   Далее во всех задачах будем считать, что элементы
массива заданы тем или иным способом, и показывать
только реализацию алгоритма решения задачи, опуская
команды ввода данных и вывода результата.
   Также не будем обозначать блоки начала и конца
выполнения алгоритма. Подразумевается, что все пере-
22                                                                             Гл а в а 1



численные блоки должны всегда присутствовать в алго-
ритме.
    Пример 1.7. Сформировать новый одномерный массив
из положительных элементов заданного массива.
    Дано: n — размер массива произвольный; массив Х[n].
    Найти: массив Y[k].
    Обозначим: i — текущий индекс элементов массива Х,
k — текущий индекс элементов массива Y.
    Ясно, что для реализации алгоритма необходимо ис-
пользовать цикл с заданным числом повторений, так как
количество элементов в массиве Х известно. Приведем фраг-
                            мент блок-схемы алгоритма
                            и ее словесное описание.
                                Блок 1. k = 0.
                                Блок 2. В цикле для всех
                            значений параметра i от 1 до
                            n выполняется тело цикла.
                                Блок 3. Если условие
                            X[i] > 0 выполняется (выход
                            «Да»), то вычисляется груп-
                            па операторов в блоке 4:
                                                k = k + 1; Y[k] = X[i].
     Тест
                        Данные                          Результат
         n=5                                   k=2
         X = (–1, 2, 0, 4, –3)                 Y = (2, 4)


     Выполнение алгоритма.
     k              i                xi > 0?                         yk = xi
0             1            x1 > 0? «Нет»
              2            x2 > 0? «Да»
1                                                           y1 = x2 = 2
              3            x3 > 0? «Нет»
              4            x4 > 0? «Да»
2                                                           y2 = x4 = 4
              5            x5 > 0? «Нет»
              6            Конец цикла
Ос н о в ы а л г о р и т м и з а ц и и                                    23


    Мы используем цикл с заданным числом повторений.
Напомним, что такой цикл (арифметический цикл) при-
меняется, когда число повторений цикла известно к нача-
лу его выполнения.

      1.3.2. Вычисление суммы и количества элементов
             массива

   Пример 1.8. Вычислить сумму элементов одномерного
массива.
    Дано: n — размер массива; массив А = (a1, a2, …, an).
   Найти: S — сумму элементов массива.
   Начальное значение суммы равно нулю. В предыду-
щих подпараграфах мы говорили о том, что значение сум-
мы накапливается с каждым шагом выполнения алгорит-
ма. Вычисляем сумму по формуле S = S + ai.
   Тест
              Данные                     Результат
 N=4            A = (3, 5, –2, 8) S = 14
          Исполнение алгоритма
 i                           S
     0
 1   S + a1 = 0 + 3 = 3
 2   S + a2 = a1 + a2 = 3 + 5 = 8
 3   S + a3 = a1 + a2 + a3 = 8 – 2 = 6
                                                     Фрагмент алгоритма
 4   S + a4 = a1 + a2 + a3 + a4 = 6 + 8 = 14


    Пример 1.9. Найти количество положительных и от-
рицательных чисел в данном массиве.
    Дано: n — размер массива; массив А = (a1, a2, …, an).
Обозначим k1 — количество положительных чисел, k2 —
количество отрицательных чисел.
    Найти: k1, k2 — количество положительных и отри-
цательных чисел массива.
    Математическая модель. Пусть k1 = 0 и k2 = 0. Если
a[i] > 0, то k1 = k1 + 1. Если a[i] < 0, то k2 = k2 + 1. Процесс
повторяется до окончания просмотра всех чисел массива.
    Приведем фрагмент блок-схемы алгоритма и ее сло-
весное описание.
24                                                    Гл а в а 1




   Блок 1. Задание начальных значений переменным k1
и k2.
   Блок 2. Заголовок арифметического цикла.
   Блок 3. Проверка условия. Если очередное значение
элемента массива положительное (выход «Да» блока 3), то
увеличиваем количество положительных чисел (блок 4).
   Блок 5. Если очередное значение элемента массива от-
рицательное (выход «Да» блока 5), то увеличиваем коли-
чество отрицательных чисел массива (блок 6).
   Указанные вычисления выполняем для всех n чисел
массива.
   В примере нам понадобилось два условных оператора,
так как в массиве могут встретиться нулевые элементы,
количество которых нам считать не надо.

     1.3.3. Определение наибольшего элемента массива
   Пример 1.10. Дан массив произвольной длины. Найти
наибольший элемент массива и определить его номер.
   Дано: n — размер массива; массив А = (a1, a2, …, an).
   Найти: Amax — наибольший элемент массива, k — его
номер.
   Математическая модель. Пусть Amax = a[1]; k = 1.
Если Amax < a[i], то Amax = a[i], k = i, для i = 2, 3, …, n.
Ос н о в ы а л г о р и т м и з а ц и и                                   25


      Тест
                                 Данные               Результат
                       n=5   A = (3, –1, 10, 1, 6) Amax = 10 k = 3

   Приведем фрагмент блок-схемы алгоритма и его вы-
полнение для тестового примера.




                   i           i ? n?        Amax < A[i]?   Amax     k
                                                            3        1
                  2 2 ? 5? «Да»            –1 < 3? «Да»
                  3 3 ? 5? «Да»            10 < 3? «Нет» 10          3
                  4 3 ? 5? «Да»            1 < 10? «Да»
                  5 5 ? 5? «Да»            6 < 10? «Да»
                  6 6 ? 5? «Нет» (кц)


      1.3.4. Удаление и вставка элементов массива
   Пример 1.11. Удалить из массива, в котором все эле-
менты различны, наибольший элемент.
   Дано: n — размер массива; A[n] — массив веществен-
ных чисел.
   Найти: новый массив А размера n – 1.
   Для решения задачи необходимо:
   1) найти номер k наибольшего элемента массива. Эта
задача решена в примере 1.10;
   2) сдвинуть все элементы массива, начиная с k-го, на
один элемент влево.
26                                                    Гл а в а 1



   Для того чтобы разработать алгоритм, рассмотрим
конкретный пример. Пусть дан одномерный массив, со-
стоящий из 7 элементов:
                  А = (6, 3, 7, 11, 2, 8, 1).
    Номер наибольшего элемента равен 4 (k = 4), т. е. на-
чиная с четвертого элемента будем сдвигать элементы на
один влево: четвертому элементу присвоим значение пя-
того, пятому — значение шестого, а шестому — значение
седьмого. На этом сдвиг заканчивается. Таким образом,
сдвиг начинается с k-го элемента и заканчивается элемен-
том с номером n, где n — количество элементов в масси-
ве. После сдвига массив будет такой: А = (6, 3, 7, 8, 1, 1).
Уменьшим количество элементов в массиве, так как после
удаления количество элементов в массиве станет на один
элемент меньше. Массив примет вид А = (6, 3, 7, 8, 1).
    В примере 1.10 уже рассматривался алгоритм поис-
ка наибольшего элемента в одномерном массиве. Так как
в данной задаче нас не интересует конкретное значение
наибольшего элемента, то модифицируем рассмотрен-
ный алгоритм и сохраняем только номер наибольшего
элемента.
    Приведем фрагмент блок-схемы алгоритма и ее сло-
весное описание.
    Блок 1. Пусть первый элемент максимальный (k = 1).
    Блок 2. В цикле просматриваем все элементы массива,
начиная со второго до последнего.
    Блок 3. Сравниваем элемент с номером k с очередным
элементом массива.
    Блок 4. Запоминаем номер элемента, который на оче-
редном шаге выполнения цикла больше k-го.
    По окончании цикла (блок 2) переменная k сохранит
номер наибольшего элемента.
    Начинам сдвиг.
    Блок 5. В цикле, начиная с k-го элемента по n – 1-й,
выполняем присваивание (блок 6), тем самым заменяя
элемент с номером i на элемент с номером i + 1.
    Блок 7. Размер массива уменьшаем на 1, выполняя
присваивание n = n – 1.
Ос н о в ы а л г о р и т м и з а ц и и                                               27




   Мы уже рассматривали подробно выполнение алго-
ритма нахождения наибольшего элемента массива и его
номера для тестового примера (см. пример 1.10). Пока-
жем, как выполняется вторая часть (сдвиг элементов мас-
сива) для тестового примера.
   Тест
                      Данные                                       Результат
 n=7        A = (6, 3, 7, 11, 2, 8, 1)                A = (6, 3, 7, 2, 8, 1) n = 6

   В массиве номер наибольшего элемента k = 4. Удаляем
этот элемент.
     i             i ? n – 1?            ai = ai+1                Результат
 4           4 ? 6? «Да»       а4 = а5               А = (6, 3, 7, 2, 2, 8, 1)
 5           5 ? 6? «Да»       а5 = а6               А = (6, 3, 7, 2, 8, 8,1)
 6           6 ? 6? «Да»       а6 = а7               А = (6, 3, 7, 2, 8, 1,1)
 7           7 ? 6? «Нет» (кц)
 n=6                                                 А = (6, 3, 7, 2, 8,1)

  Пример 1.12. Вставить произвольное число в одномер-
ный массив A[n] после элемента с заданным номером.
28                                                                  Гл а в а 1



    Дано: n — размер массива; A[n] — числовой веще-
ственный массив; k — номер элемента, после которого
вставляется число, равное m.
    Найти: новый массив A размера n + 1.
    Словесное описание алгоритма. Вставка нового эле-
мента осуществляется следующим образом:
    1) первые k элементов массива остаются без измене-
ния;
    2) все элементы, начиная с (k + 1)-го необходимо сдви-
нуть вправо, чтобы освободить место для вставляемого
элемента;
    3) элементу с номером (k + 1) присвоить значение m.
Количество элементов массива увеличить на 1.
    Рассмотрим пример. Пусть дан массив A = (3, –12, 5,
14, 27), где n = 5.
    Вставим элемент со значением 10 после второго эле-
мента массива. Получим массив A = (3, –12, 10, 5, 14, 27).
Количество элементов n = 6.
                                 Приведем        фрагмент
                            блок-схемы алгоритма и ее
                            словесное описание.
                                 Блок 1. Начинаем про-
                            сматривать массив с конца,
                            с n-го элемента до (k + 1)-го.
                                 Блок 2. В цикле сдвигаем
                            все элементы массива вправо.
                                 Блок 3. На освободивше-
                            еся место вставляем новый
                            элемент.
                                 Блок 4. Увеличиваем ко-
                            личество элементов в мас-
                            сиве.
    Тест
                Данные                               Результат
n = 5; k = 2;   А = (3, –12, 5, 14, 27) А = (3, –12, 10, 5, 14, 27); n = 6
m = 10


   Покажем выполнение алгоритма для тестового при-
мера.
Ос н о в ы а л г о р и т м и з а ц и и                                             29


     i     a[i + 1] = a[i]    a[k + 1] = m       n                Массив
 5       a[6] = a[5]                         5       А = (3, –12, 5, 14, 27, 27)
 4       a[5] = a[4]                                 А = (3, –12, 5, 14, 14, 27)
 3       a[4] = a[3] (кц)                            А = (3, –12, 5, 5, 14, 27)
                              a[3] = 10      6       А = (3, –12, 10, 5, 14, 27)


   В рассмотренных примерах мы использовали арифме-
тический цикл, количество повторений которого всегда
известно до работы начала алгоритма.

         1.3.5. Определение первого элемента массива,
                имеющего заданное свойство

    Пример 1.13. Определить, является ли заданная по-
следовательность различных чисел a1, a2, …, an монотон-
но убывающей.
    По определению последовательность монотонно убы-
вает, если a[i] ? a[i + 1]. Если хотя бы для одной пары
чисел это условие нарушается, то последовательность не
является монотонно убывающей. Следовательно, при по-
строении алгоритма мы должны зафиксировать именно
этот факт.
    Пусть переменная Flag принимает значение равное 1,
если последовательность является монотонно убываю-
щей, и 0 — в противном случае.
    Дано: n — размер массива; A[n] — числовой веще-
ственный массив.
    Найти: Flag = 1, если последовательность монотонно
убывает; Flag = 0 в противном случае.
    Словесное описание алгоритма. Предположим, что
последовательность монотонно убывает, и присвоим пере-
менной Flag начальное значение, равное 1. В цикле после-
довательно сравниваем значения двух соседних элемен-
тов. Выход из цикла возможен в двух случаях:
  • просмотрены все элементы заданной последовательно-
    сти. Это означает, что условие а[i] ? а[i + 1] выполняется
    для всех пар соединений элементов, и последователь-
    ность является монотонно убывающей. Тогда Flag = 1;
  • условие а[i] ? а[i + 1] не выполнилось для пары сосед-
    них элементов, тогда Flag = 0. Цикл прерывается. Сле-
30                                                                       Гл а в а 1



                            довательно, последователь-
                            ность не является монотонно
                            убывающей.
                                Приведем         фрагмент
                            блок-схемы алгоритма и ее
                            словесное описание.
                                Блок 1. Берем первое
                            число последовательности
                            i = 1. Предполагаем, что по-
                            следовательность монотонно
                            убывает (Flag = 1).
   Блок 2. Цикл с предусловием. Пока не проверены все
элементы и пока последовательность монотонно убывает
(проверка условия в блоке 2), выполняется тело цикла
(блоки 3–5).
   Блок 3. Если последовательность не монотонная (вы-
ход «Нет»), то фиксируем это и Flag = 0 (блок 4).
   Если условие не нарушается (выход «Да» блока 3),
то присваиваем номеру элемента следующее значение
(блок 5) и возвращаемся в цикл.
   Система тестов
  №        Проверяемый                Данные                   Результат
 теста        случай            n          Массив А               Flag
     1     Является             3           (3, 2, 1)               1
     2     Не является          3           (2, 3, 1)               0

     Выполнение алгоритма.
 № теста     i   Flag       (i <= n – 1) и (Flag = 1)?      а[i] > а[i + 1]?
             1           «Да»                            а[1] > а[2]? «Да»
             2           «Да»                            а[2] > а[3]? «Да»
     1            1
             3           «Нет»
                         Последовательность монотонно убывает
             1    1      «Да»                            а[1] > а[2]? «Нет»
     2            0      «Нет»
                         Последовательность не монотонно убывающая


   Пример 1.14. Определить, есть ли в одномерном мас-
сиве хотя бы один отрицательный элемент.
Ос н о в ы а л г о р и т м и з а ц и и                                    31


     Пусть переменная Flag = 1, если в массиве есть отри-
цательный элемент, и Flag = 0 — в противном случае.
     Дано: n — размер массива; A[n] — числовой веще-
ственный массив.
     Найти: Flag = 1, если отрицательный элемент есть;
Flag = 0 — в противном случае.
     Словесное описание алгоритма. Начинаем просматри-
вать массив с первого элемента (i = 1). Пока не просмотрен
последний элемент (i ? n) и не найден отрицательный эле-
мент (a[i] >= 0), будем переходить к следующему элементу
(i = i + 1). Таким образом, мы закончим просмотр массива
в одном из двух случаев:
     1) просмотрели все элементы и не нашли отрицатель-
ного, тогда Flag = 0 и i > n;
     2) нашли нужный элемент, при этом Flag = 1.
     Приведем фрагмент блок-схемы алгоритма и ее сло-
весное описание.
     Блок 1. Берем первый
элемент массива. Предпола-
гаем, что в массиве нет отри-
цательных чисел и Flag = 0.
     Блок 2. Пока не просмо-
трены все числа и пока не
встретилось отрицательное
число (выход «Да» блока 2)
выполняем тело цикла (бло-
ки 3–5).
     Блок 3. Если встретилось отрицательное число (выход
«Да» блока 3), запоминаем это и Flag = 1. Если очередное
число положительное или равно нулю (выход «Нет» бло-
ка 3), то увеличиваем номер числа (блок 5) и переходим
к следующему числу.
     Система тестов
              Проверяемый                    Данные           Результат
 № теста         случай             n          Массив А         Flag
 1           Есть                 3      (3, –2, 1)       1
 2           Нет                  3      (2, 3, 1)        0

      Исполнение алгоритма.
32                                                                   Гл а в а 1


 № теста    i    Flag          (i ? n) и (Flag = 0)?           а[i] < 0?
            1     0     (1 ? 3) и (Flag = 0)? «Да»         а[1] < 0? «Нет»
     1      2     0     (2 ? 3) и (Flag = 0)? «Да»         а[2] < 0? «Да»
                  1     Найдено отрицательное число (кц)
            1     0     (1 ? 3) и (Flag = 0)? «Да»         а[1] < 0? «Нет»
            2     0     (2 ? 3) и (Flag = 0)? «Да»         а[2] < 0? «Нет»
     2      3     0     (3 ? 3) и (Flag = 0)? «Да»         а[3] < 0? «Нет»
            4     0     (4 ? 3) и (Flag = 0)? «Нет» (кц)
                        Отрицательных чисел нет



     1.4. Алгоритмы, использующие 
     двумерные массивы
     1.4.1. Понятие двумерного массива
   Понятие «двумерный массив» определим на примере.
Пусть имеются данные о продажах некоторого товара по
месяцам:
 Месяц     Объем продаж, пар    Цена продажи, руб.     Себестоимость, руб.
     1           4500                   100                    50
     2           3900                   110                    55
     3           3100                   120                    60

    Таблица представляет собой множество из двенадцати
однородных величин — это массив. Ее элементы располо-
жены в 3 строки по 4 столбца в каждой.
    Подобного рода таблицы из нескольких строк с рав-
ным числом элементов в каждой называют в информати-
ке двумерными массивами или матрицей.
    Двумерный массив определяется именем, числом
строк и столбцов и обозначается, например, так: А[n, m],
где А — произвольное имя массива; n — число строк; m —
число столбцов. Обратите внимание на то, что сначала
всегда указывается количество строк, а потом — количе-
ство столбцов массива.
    Если имеются данные о продажах за 3 мес., то нашу
таблицу можно обозначить так: А[3, 4], т. е. массив состо-
ит из 3 строк и 4 столбцов.
    Строки двумерных массивов нумеруются по порядку
сверху вниз, а столбцы — слева направо.
Ос н о в ы а л г о р и т м и з а ц и и                                  33


   Элементы таблицы, представленной в примере, полу-
чат такие обозначения:
                        ? A [1,1] A [1, 2] A [1, 3] A [1, 4] ?
             A [3, 4] = ? A [2,1] A [2, 2] A [2, 3] A [2, 4]? =
                        ?                                    ?
                        ? A [3,1] A [3, 2] A [3, 3] A [3, 4]?
                                 ?1 4500 100 50 ?
                               = ?2 3900 110 55 ? .
                                 ?              ?
                                 ?3 3100 120 60 ?
    Каждый элемент двумерного массива определяется
номерами строки и столбца, на пересечении которых он
находится, и в соответствии с этим обозначается именем
массива с двумя индексами: первый — номер строки, вто-
рой — номер столбца. Например, А[1, 3] — элемент нахо-
дится в первой строке и третьем столбце.
    Таким образом, A[1, 1] = 1, A[2, 3] = 110 и т. д. Про-
извольный элемент двумерного массива мы будем обозна-
чать A[i, j], где i — номер строки, j — номер столбца.
    Поскольку положение элемента в двумерном массиве
описывается двумя индексами, алгоритмы для решения
большинства задач с их использованием строятся на осно-
ве вложенных циклов. Обычно внешний цикл организу-
ется по строкам массива, т. е. в нем выбирается требуемая
строка, а внутренний — по столбцам, в котором выбирает-
ся элемент внутри строки.




     Ввод двумерного массива                 Вывод двумерного массива
34                                                  Гл а в а 1



   В отличие от одномерных массивов для ввода и вывода
данных в двумерные массивы необходимо использовать
вложенные циклы. Циклы являются арифметическими,
так как количество строк и столбцов известно.
   Мы ввели и вывели элементы произвольного массива,
имеющего n строк и m столбцов. Понятно, что при вводе
необходимо задать количество строк и столбцов.
   Напомним, что во всех задачах будем считать, что
элементы массива заданы тем или иным способом,
и показывать только реализацию алгоритма решения
задачи, опуская команды ввода данных и вывода ре-
зультата.
   Также не будем обозначать блоки начала и конца
выполнения алгоритма. Подразумевается, что все пере-
численные блоки должны всегда присутствовать в алго-
ритме.
   Следует понимать, что все алгоритмы, приведенные
ранее для одномерных массивов, можно использовать
и для двумерных массивов, применив вложенный цикл.
Приведем алгоритмы решения некоторых задач.

     1.4.2. Вычисление суммы элементов двумерного
            массива

   Пример 1.15. Вычислить сумму элементов строк за-
данного двумерного массива.
   Дано: n, m — количество строк и столбцов массива со-
ответственно; массив А[n, m].
   Найти: S[n] — сумму элементов строк массива.
   Тест
                     Данные         Результат
                 N   M        A        S
                         ?2 1?
                 2   2   ?? 4 3??    (3, 7)


   Приведем фрагмент блок-схемы алгоритма и выпол-
нение тестового примера.
   Так как в массиве 2 строки, то сумма — это одномер-
ный массив, состоящий из 2 элементов.
Ос н о в ы а л г о р и т м и з а ц и и                                                35




      Исполнение алгоритма.
 i           i ? n?               j            j ? m?                     S
                                                             S1 = 0
                              1          1 ? 2? «Да»         S1 = S1 + a1,1 = 0 + 2 = 2
1 1 ? 2? «Да»
                              2          2 ? 2? «Да»         S1 = S1 + a1,2 = 2 + 1 = 3
                              3          3 ? 2? «Нет» (кц)
                                                           S2 = 0
                              1          1 ? 2? «Да»       S2 = S2 + a2,1 = 0 + 4 = 4
2 2 ? 2? «Да»
                              2          2 ? 2? «Да»       S2 = S2 + a2,2 = 4 + 3 = 7
                              3          3 ? 2? «Нет» (кц)
3 3 ? 2? «Нет» (кц)

    В этом примере мы нашли сумму элементов каждой
строки матрицы. Количество таких сумм равно количе-
ству строк матрицы, поэтому для сохранения значений
сумм использован одномерный массив S[n], количество
элементов в котором равно количеству строк матрицы.
    Обратите внимание на то, где присваивается началь-
ное значение переменной S. Если находится сумма всех
элементов матрицы, то команда S = 0 записывается перед
началом внешнего цикла. В результате получается одно
значение S = 10. Если ставится задача нахождения суммы
элементов строк матрицы, то команда S[i] = 0 записыва-
ется внутри цикла по строкам матрицы, тогда результат
представляет собой одномерный массив, в котором коли-
чество элементов равно количеству строк матрицы, и тог-
да S = (3, 7). Если требуется найти сумму элементов столб-
36                                                 Гл а в а 1



цов матрицы, то команда S[j] = 0 записывается внутри
цикла по столбцам матрицы, тогда результат представля-
ет собой одномерный массив, в котором количество эле-
ментов равно количеству столбцов матрицы, и S = (6, 4).

     1.4.3. Вычисление наибольшего элемента двумерного
            массива

    Пример 1.16. Найти наибольший элемент двумерного
массива и его индексы.
    Дано: массив А[n, m], где n, m — количество строк
и столбцов массива соответственно.
    Найти: max — наибольший элемент массива, а также
maxi и maxj — номер строки и столбца соответственно, на
пересечении которых находится искомый элемент.
    Словесное описание алгоритма. Пусть первый эле-
мент двумерного массива является наибольшим. Запо-
минаем его значение и индексы. Сравниваем наибольшее
значение со всеми оставшимися элементами. Если запом-
ненное значение меньше очередного элемента массива, то
запоминаем новое значение и его индексы.
    Так как значения элементов в массиве могут повто-
ряться, то договоримся, что будем запоминать только ин-
дексы первого наибольшего элемента.
    Приведем фрагмент блок-схемы алгоритма и ее описа-
ние.
                                Блок 1. Присваиваем на-
                            чальные значения перемен-
                            ным max, maxi, maxj.
                                Блок 2. Берем очередную
                            строку матрицы.
                                Блок 3. На i-й строке ма-
                            трицы последовательно вы-
                            бираем каждый элемент.
                                Блок 4. Сравниваем вы-
                            бранный элемент со значе-
                            нием переменной max.
                                Блок 5. Если значение
                            очередного элемента больше
                            max (выход «Да» блока 4),
Ос н о в ы а л г о р и т м и з а ц и и                                   37


то запоминаем его значение и индексы. Возвращаемся
в блок 3 и выбираем следующий элемент строки.
    Блок 6. Если в строке нет элементов, то выбираем но-
вую строку и повторяем вычисления (блоки 3–5).
    Тест
                                      Данные              Результат
                           n      m              A

                                            ?1 3 5?       max = 5
                           2      3         ?? 4 3 5 ??   maxi = 1
                                                          maxj = 3

      Выполните тестирование алгоритма самостоятельно.

      1.4.4. Вставка и удаление строк и столбцов
             двумерного массива

    Мы уже рассматривали задачи вставки и удаления
элементов в одномерном массиве. Обобщим эти алгорит-
мы на двумерный массив.
    Пример 1.17. Вставить в двумерный массив строку,
состоящую из нулей, после строки с номером k.
    Для решения этой задачи необходимо:
    1) первые k строк оставить без изменения;
    2) все строки после k-й сдвинуть на одну вниз. Сдвиг луч-
ше всего начать с последней строки и идти до (k + 1)-й строки;
    3) присвоить новые значения элементам (k + 1)-й стро-
ки и увеличить количество строк в двумерном массиве.
    Дано: массив А[n, m], где n, m — количество строк
и столбцов массива соответственно; k — номер строки, по-
сле которой вставляется новая строка.
    Найти: новую матрицу А, содержащую n + 1 строку
и m столбцов.
    Приведем фрагмент блок-схемы алгоритма.
    В блоке 3 в цикле выполняется сдвиг строк матрицы
вниз, начиная со строки с номером k. В блоке 5 происхо-
дит вставка новой строки.
    Тест
                       n   m     k    Исходная матрица       Результат

                                         ?1 2 3 ?           ?1 2 3 ?
                       2    3    1       ?? 4 5 6 ??        ?0 0 0?
                                                            ?      ?
                                                            ?4 5 6 ?
38                                                         Гл а в а 1



    Так как k = 1, то необходимо сдвинуть строку 2 вниз
и вставить после первой строки новую строку, состоящую
                           из нулей.
                               Исполнение алгоритма.
                              i      j                 A
                            Сдвигаем строки матрицы вниз
                            (блоки 1–3)
                                     1   A[3, 1] = A[2, 1] = 4
                              2      2   A[3, 2] = A[2, 2] = 5
                                     3   A[3, 3] = A[2, 3] = 6
                            Промежуточный результат
                                          ?1 2 3?
                                          ?4 5 6?
                                          ?     ?
                                          ?4 5 6?
                            Вставка строки
                                     1   A[2, 1] = 0
                              2      2   A[2, 2] = 0
                                     3   A[2, 3] = 0

    Примечания
    1. Если необходимо вставить новую строку после стро-
ки, удовлетворяющей некоторому условию, то надо най-
ти номер этой строки — и задача сведется к решению уже
рассмотренной.
    2. Если надо вставить новые строки после всех строк
с заданным условием, то надо учесть это при описании
массива. Заметим, что удобнее рассматривать строки,
начиная с последней строки, и после вставки очередной
строки увеличивать количество строк.
    3. Вставка новой строки перед строкой с номером k из-
менится только тем, что сдвигать назад надо не с (k + 1)-й
строки, а с k-й.
    4. Если надо вставлять столбцы, то размерность мас-
сива увеличивается по столбцам, а все остальное прак-
тически не меняется: надо сдвинуть столбцы вправо и на
данное место записать новый столбец.
    Пример 1.18. Удалить из двумерного массива строку
с номером k.
    Для удаления строки с номером k необходимо:
Ос н о в ы а л г о р и т м и з а ц и и                                          39


    1) сдвинуть все строки, начиная со строки с номером
k, вверх;
    2) уменьшить количество строк в двумерном массиве.
    Дано: массив А[n, m], где n, m — количество строк
и столбцов массива соответственно; k — номер удаляемой
строки.
    Найти: новую матрицу А, содержащую (n – 1)-ую
строку и m столбцов.
    Фрагмент блок-схемы алгоритма.
                                Тест
                                                            Исходная
                                              n   m   k                  Результат
                                                            матрица

                                                          ?1 2 3 ?       ?1 2 3 ?
                                             3 3 2        ?0 0 0?        ?? 4 5 6 ??
                                                          ?      ?
                                                          ?4 5 6 ?


                                                  Исполнение алгоритма.
                                              i   j                  A
                                               1 A[2, 1] = A[3, 1] = 4
                                             2 2 A[2, 2] = A[3, 2] = 5
                                               3 A[2, 3] = A[3, 3] = 6

    После выполнения циклов (блоки 1 и 2) матрица име-
ет следующий вид:
                                         ?1 2 3 ?
                                         ?4 5 6 ?.
                                         ?      ?
                                         ?4 5 6 ?
   Уменьшаем количество строк матрицы (блок 4), после
чего она примет искомый вид.

      1.4.5. Нахождение строк или столбцов двумерного
             массива, обладающих заданным свойством

    Пример 1.19. Дан двумерный массив A[n, m]. Найти
количество строк, содержащих хотя бы один нуль.
    Обозначим: k — количество строк, содержащих хотя
бы один нуль; Flag — признак наличия нулей в строке.
Flag = 1 означает, что нули в строке есть; Flag = 0 — нулей
в строке нет.
40                                                          Гл а в а 1



    Словесное описание алгоритма. Начинаем просматри-
вать массив с первой строки. Берем первый элемент столб-
ца (j = 1). Пока не просмотрен последний элемент столбца
(j ? m) и не найден отрицательный элемент (a[i, j] >= 0),
будем переходить к следующему элементу, увеличивая
индекс элемента j (j = j + 1). Таким образом, мы закончим
просмотр строки массива в одном из двух случаев:
    1) просмотрели все элементы и не нашли отрицатель-
ного, тогда Flag = 0;
    2) нашли нужный элемент, при этом Flag = 1. Увели-
чиваем значение количества строк k, содержащих нули.
    Фрагмент блок-схемы алгоритма.
    Блок 1. Присваиваем переменной k начальное значе-
ние.
    Блок 2. Берем очередную строку i.
    Блок 3. Для выбранной строки задаем первый элемент
строки и устанавливаем Flag = 0.
    Блок 4. Выполняем итерационный цикл для всех эле-
ментов строки (блоки 5–7).
    Блок 5. Сравниваем очередной элемент строки с ну-
лем.
    Блок 6. Если нулевой элемент найден (выход «Да»
блока 5), то Flag = 1, увеличиваем значение k и заканчи-
ваем просмотр строки (выход «Нет» блока 4).
                                    Блок 7. Если нулевой эле-
                                мент не найден (выход «Нет»
                                блока 5), то продолжаем про-
                                смотр оставшихся элементов
                                в строке, увеличивая индекс
                                элемента j.
                                    Покажем выполнение ал-
                                горитма на тестовом примере.
                                    Тест
                                        Данные       Результат
                                N M Матрица А           K
                                          ?1 0 1 ?
                                3   3     ?2 4 7 ?      2
                                          ?      ?
                                          ?0 1 0?
Ос н о в ы а л г о р и т м и з а ц и и                                         41


      Исполнение алгоритма.
  i    Flag       j             (j <= M) и (Flag = 0)?        A[i, j] = 0?     K
         0                                                                     0
                 1    (1 <= 3) и (Flag = 0)? «Да»         A[1, 1] = 0? «Нет»
 1               2    (2 <= 3) и (Flag = 0)? «Да»         A[1, 2] = 0? «Да»
         1                                                                     1
                      (2 <= 3) и (Flag = 0)? «Нет» (кц)
 2       0
                 1    (1 <= 3) и (Flag = 0)? «Да»       A[2, 1] = 0? «Нет»
                 2    (2 <= 3) и (Flag = 0)? «Да»       A[2, 2] = 0? «Нет»
                 3    (3 <= 3) и (Flag = 0)? «Да»       A[2, 3] = 0? «Нет»
         0       4    (4 <= 3) и (Flag = 0)? «Нет» (кц)
 3       0
                 1    (1 <= 3) и (Flag = 0)? «Да»       A[3, 1] = 0? «Да»      2
                      (4 <= 3) и (Flag = 0)? «Нет» (кц)

   Итак, количество строк, в которых встречается хотя
бы один нуль, равно 2, что соответствует условию задачи.

      1.5. Алгоритмы сортировки
    Сортировка — это процесс перестановки элементов не-
которого заданного множества в определенном порядке.
Цель сортировки — облегчить последующий поиск эле-
ментов в отсортированном множестве.
    В общем случае задача сортировки ставится следующим
образом. Имеется массив, тип данных которого позволяет
использовать операции сравнения («=», «>», «<», «>=» и
«<=»). Задачей сортировки является преобразование ис-
ходного массива в массив, содержащий те же элементы, но
в порядке возрастания (или убывания) значений.
    Методы сортировки не должны требовать дополни-
тельной памяти: все перестановки с целью упорядочения
элементов массива должны производиться в пределах
того же массива.
    Будем выполнять сортировку по возрастанию.
    Методы, сортирующие массив «на месте», делятся
на три основных класса в зависимости от лежащего в их
основе приема.
42                                                      Гл а в а 1



     1. Сортировка включениями (вставкой).
     2. Сортировка выбором.
     3. Сортировка обменом.

     1.5.1. Сортировки включениями (вставкой)
                Сортировка простой вставкой
     Идея алгоритма очень проста. Пусть имеется массив
a[1], a[2], ..., a[n]. Пусть элементы a[1], a[2], ..., a[i – 1]
уже отсортированы, и пусть имеем входную последова-
тельность a[i], a[i + 1], ..., a[n]. На каждом шаге, начиная
с i = 2 и увеличивая i на единицу, берем i-й элемент вход-
ной последовательности и вставляем его на подходящее
место в уже отсортированную часть последовательности.
     Обозначим вставляемый элемент через х.
     Пусть начальный массив 32 64 9 30 87 14 2 76.
i = 2 х = 64. Ищем для х подходящее место, считая,
              что а[1] = 32 — это уже отсортирован-
              ная часть последовательности. Получаем
              32 64 9 30 87 14 2 76.
i = 3 х = 9. Часть последовательности а[1], а[2] уже от-
              сортирована. Ищем для х подходящее место:
              9 32 63 30 87 14 2 76.
   Аналогично выполняем последующие шаги сорти-
ровки.

     i = 4 х = 30. Ищем для х подходящее место:
                   9 30 32 64 87 14 2 76.
     i = 5 х = 87. Ищем для х подходящее место:
                   9 30 32 64 87 14 2 76.
     i = 6 х = 14. Ищем для х подходящее место:
                   9 14 30 32 64 87 2 76.
     i = 7 х = 2. Ищем для х подходящее место:
                   2 9 14 30 32 64 87 76.
     i = 8 х = 76. Ищем для х подходящее место:
                   2 9 14 30 32 64 76 87.
   При поиске подходящего места для элемента х мы че-
редовали сравнения и пересылки, т. е. как бы «просеива-
ли» х, сравнивая его с очередным элементом a[i] и либо
Ос н о в ы а л г о р и т м и з а ц и и                                          43


вставляя х, либо пересылая a[i] направо и продвигаясь
влево. Заметим, что «просеивание» может закончиться
при двух различных условиях:
    1) найден элемент, значение которого больше, чем х;
    2) достигнут конец последовательности.
    Это типичный пример цикла с двумя условиями оконча-
ния. При реализации алгоритма с целью окончания выпол-
нения внутреннего цикла используют прием фиктивного
элемента (барьера). Его можно установить, приняв a[0] = x.
    Приведем фрагмент блок-схемы алгоритма и ее описа-
ние.
    Блок 1. Начинаем цикл
для перебора всех элементов
исходного массива.
    Блок 2. Присваиваем х
значение очередного элемен-
та массива. Устанавливаем
барьер и продвигаемся назад
по отсортированной части
массива.
    Блок 3. Начинам цикл
для поиска подходящего ме-
ста для значения х.
    Блок 4. Пока х меньше очередного элемента (выход
«Да» блока 3), выполняем сдвиг и продвигаемся к началу
отсортированной части массива.
    Блок 5. По выходу «Нет» блока 3 вставляем элемент х
на нужное место.
    Покажем исполнение алгоритма для рассмотренного
примера.
 i    x    a[0]   j        x < a[j]?          a[j + 1]             Массив
 2 64      64     1   64 < 32? «Нет»     a[2] = x = 64      32 64 9 30 87 14 2 76
                  2   9 < 64? «Да»       a[3] = a[2] = 64   32 64 64 30 87 14 2 76
 3    9     9     1   9 < 32? «Да»       a[2] = a[1] = 32   32 32 64 30 87 14 2 76
                  0   9 < 9? «Нет»       a[1] = x = 9       9 32 64 30 87 14 2 76
                  3   30 < 64? «Да»      a[4] = a[3] = 64   9 32 64 64 87 14 2 76
 4 30      30     2   30 < 32? «Да»      a[3] = a[2] = 32   9 32 32 64 87 14 2 76
                  1   30 < 9? «Нет»                         a[2] = x = 30
44                                                Гл а в а 1



    После     этого    шага   массив    выглядит    так:
9 30 32 64 87 14 2 76. Сортировка продолжается далее для
оставшихся значений i.

         Сортировка бинарными включениями
    Алгоритм сортировки простыми включениями име-
ет слабые места. Это, во-первых, необходимость переме-
щения данных, причем при вставке элементов, близких
к концу массива, приходится перемещать почти весь мас-
сив. Второй недостаток — это необходимость поиска ме-
ста для вставки, на что также тратится много ресурсов.
Эту часть алгоритма можно улучшить, применив так на-
зываемый бинарный поиск. Этот метод на каждом шаге
сравнивает х со средним (по положению) элементом отсо-
ртированной последовательности до тех пор, пока не бу-
дет найдено место включения.
    Модифицированный алгоритм называется сортиров-
кой бинарными включениями.
    Обозначим left — левая граница отсортированного
массива, right — его правая граница.
    Приведем фрагмент блок-схемы алгоритма и ее описа-
ние.
                                     Блок 1. Начинаем
                                 цикл для перебора всех
                                 элементов исходного
                                 массива.
                                     Блок 2. Присваива-
                                 ем х значение очеред-
                                 ного элемента массива.
                                 Устанавливаем левую
                                 и правую границы от-
                                 сортированной части
                                 массива.
                                     Блок 3. Пока левая
                                 граница отсортирован-
                                 ного массива не превос-
                                 ходит правую, выпол-
                                 няется тело цикла, со-
                                 стоящее из блоков 4–7.
Ос н о в ы а л г о р и т м и з а ц и и                                             45


   Блок 4. Находится средний по положению элемент от-
сортированной части массива.
   Блок 5. Значение х сравнивается с найденным элемен-
том. По выходу «Да» блока 5 корректируется правая гра-
ница отсортированной части массива, по выходу «Нет» —
левая.
   При выходе из цикла с предусловием будет найдено
положение вставляемого элемента.
   Блоки 8–9 реализуют сдвиг элементов массива для
вставки значения х.
   Блок 10. Вставка значения в отсортированную часть
массива.
   Приведем выполнение алгоритма при сортировке мас-
сива 32 64 9 30 87 14 2 76.
                 right




                          left <=
          left




 i    x                              m    x < a[m]?    j      a[j + 1]       a[left]
                         <= right?

 2 64 1 1                «Да»        1 32 < 64? «Да»
        0                «Нет»                         1 a[2] = 64          a[1] = 32
        2                «Да»        1 9 < 64? «Да»
      1
        1                «Нет»                         2 a[3] = a[2] = 64
 3 9
                                                       1 a[2] = a[1] = 32
                                                                            a[1] = 9
        3 «Да»                       2 30 < 32? «Да»
      1
        2 «Да»                       1 30 < 9? «Нет»
 4 30
          «Нет»                                        3 a[4] = a[3] = 64
      2
                                                       2 a[3] = a[2] = 32 a[2] = 30

   После     этого    шага   массив    выглядит   так:
9 30 32 64 87 14 2 76. Сортировка массива продолжается
для следующих значений i.

                                     Сортировка Шелла
    Дальнейшим развитием метода сортировки включе-
ниями является сортировка методом Шелла, называемая
по-другому сортировкой включениями с уменьшающим-
ся расстоянием. Мы не будем описывать алгоритм в об-
щем виде, ограничимся случаем, когда число элементов
в сортируемом массиве является степенью числа 2. Для
массива с 2n элементами алгоритм работает следующим
46                                                  Гл а в а 1



образом. На первом этапе производится сортировка вклю-
чением всех пар элементов массива, расстояние между
которыми равно 2n–1. На втором этапе производится со-
ртировка включением элементов полученного массива,
расстояние между которыми равно 2n–2. Алгоритм про-
должается до тех пор, пока мы не дойдем до этапа с рас-
стоянием между элементами, равным единице, и не вы-
полним завершающую сортировку включениями.
    Покажем сортировку Шелла на массиве, состоящем
из 8 элементов.
    На первом проходе отдельно группируются и сортиру-
ются все элементы, отстоящие друг от друга на четыре по-
зиции. Этот процесс называется 4-сортировкой. В нашем
примере из восьми элементов каждая группа содержит ров-
но два элемента. После этого элементы вновь объединяют-
ся в группы с элементами, отстоящими друг от друга на две
позиции, и сортируются заново. Этот процесс называется
2-сортировкой. Наконец, на третьем проходе все элементы
сортируются обычной сортировкой, или 1-сортировкой.
    Начальное состояние 32 64 9 30 87 14 2 76.
    n = 3.




    На первом шаге сравниваются элементы, отстоящие
друг от друга на 4 позиции: a[1] и a[5], a[2] и a[6], a[3]
и a[7], a[4] и a[8].


    На втором шаге сравниваются элементы, отстоящие
друг от друга на 2 позиции: a[1] и a[3], a[2] и a[4], a[3]
и a[5], a[4] и a[6], a[5] и a[7], a[6] и a[8].


     На этом шаге сравниваются все соседние элементы.
     Отсортированный массив:
               2 9 14 30 32 64 76 87.
Ос н о в ы а л г о р и т м и з а ц и и                47


    Таким образом, на каждом проходе либо участвуют срав-
нительно мало элементов, либо они уже довольно хорошо
упорядочены и требуют относительно мало перестановок.
    Очевидно, что этот метод в результате дает упорядо-
ченный массив, и также совершенно ясно, что каждый
проход будет использовать результаты предыдущего про-
хода, поскольку каждая i-сортировка объединяет две
группы, рассортированные предыдущей 2i-сортировкой.
Также ясно, что приемлема любая последовательность
приращений, лишь бы последнее было равно 1, так как
в худшем случае вся работа будет выполняться на послед-
нем проходе. Однако менее очевидно, что метод убываю-
щего приращения дает даже лучшие результаты, когда
приращения не являются степенями двойки [1].
    Таким образом, алгоритм разрабатывается вне связи
с конкретной последовательностью приращений. Все t
приращения обозначаются через h1, h2, ..., ht, с условия-
ми h1 = 1, hi+1 < ht.
    Каждая h-сортировка программируется как сортиров-
ка простыми включениями. Для того чтобы условие окон-
чания поиска места включения было простым, использу-
ется барьер.
    Ясно, что каждая
h-сортировка требует
собственного барьера,
и программа должна
определять его место
как можно проще.
Поэтому       исходный
массив нужно допол-
нить      несколькими
h-компонентами. Этот
алгоритм называется
сортировкой Шелла.
    Приведем       блок-
схему алгоритма для
t = 4. Примем h[1] = 9;
h[2] = 5; h[3] = 3;
h[4] = 1.
48                                                             Гл а в а 1



     Исполнение алгоритма.
          n = 8; a = (32 64 9 30 87 14 2 76); t = 4.
           h[1] = 9; h[2] = 5; h[3] = 3; h[4] = 1.
     m    k       i      x      j    j <= 0Ux < a[j]      a [j + k]
     1    9      9
                 5      87       0   «Нет»
                 6      14       1   «Да»              а[6] = 32
                                –4   «Нет»             а[1] = 14
     2    5
                         2       2   «Да»              а[7] = 64
                 7
                                –1   «Нет»             а[2] = 2
                 8      76       3   «Нет»

    После     этой     фазы массив   выглядит  так:
14 2 9 30 87 32 64 76.
    В конечном счете, сортировка включениями оказы-
вается не очень подходящим методом для ЭВМ, так как
включение элемента с последующим сдвигом всего ряда
элементов на одну позицию неэкономна.

     1.5.2. Сортировка простым выбором

    Сортировка простым выбором основана на следующем
правиле.
    В неупорядоченном массиве выбирается и отделяется
от остальных элементов наименьший элемент. Наимень-
ший элемент записывается на i-е место исходного мас-
сива, а элемент с i-го места — на место выбранного. Уже
упорядоченные элементы (а они будут расположены на-
чиная с первого места) исключаются из дальнейшей со-
ртировки, поэтому длина оставшегося неупорядоченного
массива должна быть на один элемент меньше предыду-
щего.
    Улучшенный алгоритм — пирамидальная сортиров-
ка требует организации массива виде дерева. Желающих
изучить этот алгоритм сортировки авторы отсылают к [1],
где он прекрасно описан.
    Сортировку простым выбором продемонстрируем на
массиве 32 64 9 30 87 14 2 76.
Ос н о в ы а л г о р и т м и з а ц и и                  49


   i = 1, наименьшее значение 2, меняем местами 2 и 32.
Массив после этого шага:
                               2 64 9 30 87 14 32 76.
    i = 2, наименьшее значение в оставшейся части масси-
ва 9, меняем местами 9 и 64. Массив после этого шага:
                               2 9 64 30 87 14 32 76.
    i = 3, наименьшее значение в оставшейся части масси-
ва 14, меняем местами 14 и 64. Массив после этого шага:
                               2 9 14 30 87 64 32 76.
    i = 4, наименьшее значение в оставшейся части мас-
сива 30. Обмен не происходит, так как 30 стоит на своем
месте.
    i = 5, наименьшее значение в оставшейся части масси-
ва 32, меняем местами 32 и 87. Массив после этого шага:
                               2 9 14 30 32 64 87 76.
    i = 6, наименьшее значение в оставшейся части мас-
сива 64. Обмен не происходит, так как 64 стоит на своем
месте.
    i = 7, наименьшее значение в оставшейся части масси-
ва 76, меняем местами 76 и 87. Массив после этого шага:
                               2 9 14 30 32 64 76 87.
   Массив отсортирован, но выполняется еще один шаг.
   i = 8, наименьшее значение в оставшейся части мас-
сива 87. Обмен не происходит, так как 87 стоит на своем
месте.
   Таким образом, мы видим, что метод сортировки про-
стым выбором основан на повторном выборе наименьшего
элемента сначала среди n элементов, затем среди (n – 1)-го
элемента и т. д. Возможна ситуация, когда обмен значе-
ний элементов не происходит.
   Приведем блок-схему и описание алгоритма сортиров-
ки простым выбором.
   Блок 1. Организует внешний цикл для просмотра эле-
ментов неупорядоченной части массива.
50                                                                           Гл а в а 1



                                   Блок 2. Запоминание ин-
                               декса и значения i-го элемен-
                               та, которые принимаем за
                               начальные при поиске наи-
                               меньшего элемента.
                                   Блоки 3–5. Поиск значе-
                               ния наименьшего элемента
                               и его номера в еще неупоря-
                               доченной части массива.
                                   Блок 6. Обмен наимень-
                               шего и i-го элементов.
         Приведем исполнение алгоритма для массива:
                           32 64 9 30 87 14 2 76; n = 8.
     i         k       x        j       a[j] < x?          a[k] = a[i]; a[i] = x
           1       32        2      a[2] < 32? «Нет»
                             3      a[3] < 32? «Да»
                             4      a[4] < 9? «Нет»
1          3       9
                             5      a[5] < 9? «Нет»
                             6      a[6] < 9? «Нет»
           7       2         7      a[7] < 9? «Да»   A[7] = a[1] = 32; a[1] = 2
                             кц


         После окончания внутреннего цикла массив имеет вид
                              2 64 9 30 87 14 32 76.
   Сортировка продолжается для всех оставшихся значе-
ний параметра внешнего цикла i.

         1.5.3. Обменные сортировки
                       Сортировка простым обменом
    Простая обменная сортировка (называемая также
«методом пузырька») для массива a[1], a[2], ..., a[n] рабо-
тает следующим образом. Начиная с конца массива, срав-
ниваем два соседних элемента (a[n] и a[n – 1]). Если вы-
полняется условие a[n – 1] > a[n], то значения элементов
меняются местами. Процесс продолжается для a[n – 1]
и a[n – 2] и т. д., пока не будет произведено сравнение a[2]
Ос н о в ы а л г о р и т м и з а ц и и                                                 51


и a[1]. Понятно, что после этого на месте a[1] окажется
элемент массива с наименьшим значением. На втором
шаге процесс повторяется, но последними сравниваются
a[3] и a[2]. На последнем шаге будут сравниваться только
значения a[n] и a[n – 1]. Понятна аналогия с пузырьком,
поскольку наименьшие элементы (самые «легкие») по-
степенно «всплывают» к верхней границе массива.
    Простая реализация алгоритма.
    Блок 1. Арифметический
цикл. Значение параметра
цикла i определяет количе-
ство сравниваемых элемен-
тов во внутреннем цикле.
    Блок 2. Задание номеров
элементов для сравнения.
    Блок 3. Сравнение двух
соседних элементов.
    Блок 4. Выполняется об-
мен элементов массива при
выходе «Да» блока 3.
    Сортируем массив 32 64 9 30 87 14 2.
    Выполнение алгоритма для i = 2 приведено ниже.
  i      j       a[j – 1] > a[j]?             a[j – 1], a[j]           Массив
         8    2 > 76? «Нет»                                    32 64 9 30 87 14 2 76
         7    14 > 2? «Да»               a[6] = 2, a[7] = 14   32 64 9 30 87 2 14 76
         6    87 > 2? «Да»               a[5] = 2, a[6] = 87   32 64 9 30 2 87 14 76
  2      5    30 > 2? «Да»               a[4] = 2, a[5] = 30   32 64 9 2 30 87 14 76
         4    9 > 2? «Да»                a[3] = 9, a[4] = 2    32 64 2 9 30 87 14 76
         3    64 > 2? «Да»               a[2] = 2, a[3] = 64   32 2 64 9 30 87 14 76
         2    32 > 2? «Да»               a[1] = 2, a[2] = 32   2 32 64 9 30 87 14 76

   После этого шага значение 2 встало на свое место, и ал-
горитм повторяется для i = 3, 4, ..., n.
   Очевидный способ улучшить алгоритм — это запоми-
нать, производился ли на данном проходе какой-либо об-
мен. Если нет, то алгоритм может закончить свою работу.
   Используем переменную Flag, и пусть переменная
Flag = 1, если на очередном шаге был выполнен обмен
элементов, и Flag = 0, если обмена не было.
52                                                                         Гл а в а 1



                                     Приведем       фраг-
                                 мент блок-схемы и ее
                                 описание.
                                     Блок 1. Задаем
                                 начальные значения
                                 Flag = 1 и m = n – 1.
                                     Блок 2. Заголовок
                                 цикла. Пока не просмо-
                                 трен весь массив и пока
                                 был обмен, выполняем
                                 внутренний цикл.
                                     Блок 3. Предпо-
                                 ложим, что элементы
                                 массива уже отсорти-
                                 рованы, тогда Flag = 0.
    Блок 4. Организация арифметического цикла для
сравнения и обмена соседних элементов массива.
    Блоки 5–6. Тело внутреннего цикла. В блоке 5 выпол-
няется сравнение соседних элементов.
    При выходе «Да» блока 5 меняем местами элементы
и фиксируем факт обмена в переменной Flag.
    Блок 7. По окончании внутреннего цикла очередной
элемент встал на свое место, уменьшается размер еще не
отсортированной части массива.
    Если был хотя бы один обмен, алгоритм повторяется.
    Выполним      алгоритм    и   отсортируем     массив
32 64 9 30 87 14 2.
 Flag   m   m > 1 и Flag = 1?       i     a[i] > a[i + 1]      a[i]      a[i + 1]

1           «Да»
0                               1       32 > 64? «Нет»
1                               2       64 > 9? «Да»        a[2] = 9    a[3] = 64
1       6                       3       64 > 30? «Да»       a[3] = 30   a[4] = 64
                                4       64 > 87? «Нет»
1                               5       87 > 14? «Да»       a[5] = 14   a[6] = 87
1                               6       87 > 2? «Да»        a[6] = 2    a[7] = 87

    В    результате             получим             следующий           массив:
32 9 30 64 14 2 87.
Ос н о в ы а л г о р и т м и з а ц и и                                              53


   По выходе из внутреннего цикла m = 6 и Flag = 1, так
как выполнялись обмены элементов массива. Начинаем
внутренний цикл для нового значения переменной m.
   Последний элемент находится на своем месте.
   Продолжим сортировку для m = 5.
 Flag      m     m > 1 и Flag = 1?       i    a[i] > a[i + 1]?      a[i]      a[i+ 1]
   1            «Да»
   0                                     1   32 > 9? «Да»        a[1] = 9    a[2] = 32
   1                                     2   32 > 30? «Да»       a[2] = 30   a[3] = 32
   1       5                             3   32 > 64? «Нет»
                                         4   64 > 14? «Да»       а[4] = 14   a[5] = 64
   1                                     5   64 > 2? «Да»        a[5] = 2    a[6] = 64
   1                                     6   64 > 87? «Нет»

    Теперь массив имеет вид 9 30 32 14 2 64 87, и два по-
следних элемента находятся на своих местах.
    Так как были перестановки элементов, то алгоритм
продолжается до полной сортировки массива.
    Второе улучшение алгоритма связано с тем, что мож-
но установить барьер: запоминать наименьшее значение
индекса массива, для которого на текущем шаге выпол-
нялись перестановки. Очевидно, что верхняя часть масси-
ва до элемента с этим индексом уже отсортирована, и на
следующем шаге можно прекращать сравнения значений
соседних элементов при достижении такого значения ин-
декса.
    В-третьих, метод пузырька работает неравноправно
для так называемых «легких» и «тяжелых» значений.
Один неправильно расположенный «пузырек» в «тяже-
лом» конце рассортированного массива всплывет на ме-
сто за один проход, а неправильно расположенный эле-
мент в «легком» конце будет опускаться на правильное
место только за один шаг на каждом проходе. Например,
массив
                               12 18 42 44 55 67 94 6
будет рассортирован за один проход, а сортировка массива
                               94 6 12 18 43 44 55 76
54                                                 Гл а в а 1



потребует семи проходов. Эта асимметрия подсказывает
третье улучшение: менять местами направление следую-
щих один за другим проходов. Этот улучшенный алго-
ритм называется шейкер-сортировкой.

                  Шейкер-сортировка
    При ее применении на каждом следующем шаге ме-
няется направление последовательного просмотра. В ре-
зультате на одном шаге «всплывает» очередной наиболее
легкий элемент, а на другом «тонет» очередной самый тя-
желый.
    Обозначим left — номер левой границы сортируемой
части массива, right — номер его правой границы.
                                 Блок 1. Устанавка но-
                             меров начальных границ
                             сортируемого массива.
                                 Блок 2. Вход в цикл.
                             Пока левая граница не пре-
                             восходит правую границу
                             (выход «Да» блока 2) вы-
                             полняем цикл.
                                 Блок 3. Выполнение
                             прохода массива вниз.
                                 Блок 4. Сравнение со-
                             седних элементов.
                                 Блок 5. Если a[j – 1] >
                             > a[j] (выход «Да» блока 4),
                             производим обмен этих эле-
                             ментов и фиксируем номер
                             элемента j, с которым про-
                             изводился обмен.
                                 По окончании прохода
                             вниз (выход блока 3) сдви-
                             гаем левую границу масси-
ва (блок 6) и выполняем проход вверх (блоки 7–9).
    Покажем выполнение алгоритма для массива, состоя-
щего из 7 элементов:
                   32 9 30 64 14 2 87.
Ос н о в ы а л г о р и т м и з а ц и и                                                        55


         Выполняем проход сверху вниз.
         right



                     left <=
 left




                 k              j   j > left?     a[j – 1] > a[j]?             Обмен
                     right?

                 7             7    «Да»         2 > 87 «Нет»
                 6             6    «Да»         14 > 2 «Да»         х = 14; a[5] = 2; a[6] = 14
                 5             5    «Да»         64 > 2 «Да»         х = 64; a[4] = 2; a[5] = 64
 2       7       4   «Да»      4    «Да»         30 > 2 «Да»         х = 30; a[3] = 2; a[4] = 30
                 3             3    «Да»         9 > 2 «Да»          х = 9; a[2] = 2; a[3] = 9
                 2             2    «Да»         32 > 2 «Да»         х = 32; a[1] = 2; a[2] = 32
                               1    «Нет»

    Массив     после этого   прохода   имеет   вид
2 32 9 30 64 14 87.
    Меняем направление движения и выполняем проход
снизу вверх.
 left        right    k   j    j <= right       a[j – 1] > a[j]?
                     3    3    «Да»         32 > 9? «Да»   х = 32; a[2] = 9; a[3] = 32
                     4    4    «Да»         32 > 30? «Да» х = 32; a[3] = 30; a[4] = 32
                          5    «Да»         32 > 64? «Нет»
     3           7
                     6    6    «Да»         64 > 14? «Да» х = 64; a[5] = 14; a[6] = 64
                          7    «Да»         64 > 87? «Нет»
                          8    «Нет»

    Теперь массив имеет вид 2 9 30 32 14 64 87.
    Опять меняем направление движения. Смена направ-
ления движения выполняется до тех пор, пока выполня-
ется условие, записанное в блоке 2.
    Анализ показывает [1], что сортировка обменом и ее
небольшие улучшения хуже, чем сортировка включения-
ми и выбором. Алгоритм шейкер-сортировки рекоменду-
ется использовать в тех случаях, когда известно, что мас-
сив «почти упорядочен».
    В 1962 г. Чарльз Хоар предложил метод сортировки
разделением. Этот метод является развитием метода про-
стого обмена и настолько эффективен, что его стали назы-
вать методом быстрой сортировки — QuickSort.
    Метод требует использования рекурсивных функций
и в рамках данного пособия не рассматривается.
56                                                 Гл а в а 1


     1.5.4. Сравнение методов сортировки
   На основании анализа, приводимого в [1], можно сде-
лать следующие выводы об эффективности рассмотрен-
ных алгоритмов сортировки.
   1. Преимущество сортировки бинарными включения-
ми по сравнению с сортировкой простыми включениями
мало, а в случае уже имеющегося порядка вообще отсут-
ствует.
   2. Сортировка методом «пузырька» является наихуд-
шей среди сравниваемых методов. Ее улучшенная вер-
сия — шейкер-сортировка — все-таки хуже, чем сорти-
ровка простыми включениями и простым выбором.
   3. Сортировка простым выбором является лучшим из
простых методов.

     1.6. Алгоритмы поиска
   Алгоритмы поиска занимают очень важное место сре-
ди прикладных алгоритмов, и это утверждение не нужда-
ется в доказательстве.
   Все алгоритмы поиска разбиваются на две большие
группы в зависимости от того, упорядочен или нет массив
данных, в котором проводится поиск. Рассмотрим про-
стые алгоритмы поиска заданного элемента в одномерном
массиве данных.

     1.6.1. Последовательный поиск
    Наиболее примитивный, а значит, наименее эффек-
тивный способ поиска — это обычный последовательный
просмотр массива.
    Пусть требуется найти элемент Х в массиве из n эле-
ментов. Значение элемента Х вводится с клавиатуры.
    В данном случае известно только значение разыски-
ваемого элемента, никакой дополнительной информации
о нем или о массиве, в котором его надо искать, нет. Поэ-
тому для решения задачи разумно применить очевидный
метод — последовательный перебор элементов массива
и сравнение значения очередного элемента с заданным об-
разцом.
Ос н о в ы а л г о р и т м и з а ц и и                   57


   Пусть Flag = 1, если значение, равное Х, в массиве най-
дено, в противном случае Flag = 0. Обозначим k — индекс
найденного элемента. Элементы массива — целого типа.

                                 Элементы массива
    Присвоим начальные значения переменным Flag и k
и возьмем первый элемент массива (блок 1).
    Пока не просмотрены все элементы и пока элемент, рав-
ный Х, не найден (выход «Да» блока 2), выполняем цикл.
    Сравниваем очередной элемент массива со значением
Х, и если они равны (выход «Да» блока 3), то запомина-
ем его индекс и поднимаем Flag = 1. Если элемент еще не
найден (выход «Нет» блока 2), продолжаем просмотр эле-
ментов массива.
    Выход из цикла (блок 2) возможен в двух случаях:
    1) элемент найден, тогда Flag = 1, а в переменной k со-
хранен индекс найденного элемента;
    2) элемент не найден, тогда Flag = 0, а k также равен 0.




      1.6.2. Бинарный поиск
     Если известно, что массив упорядочен, то можно ис-
пользовать бинарный поиск.
     Пусть даны целое число Х и массив размера n, отсортиро-
ванный в порядке неубывания, т. е. для любого k (1 <= k < n)
выполняется условие a[k – 1] <= a[k]. Требуется найти такое
i, что a[i] = Х, или сообщить, что элемента Х нет в массиве.
     Идея бинарного поиска состоит в том, чтобы прове-
рить, является ли Х средним по положению элементом
58                                                     Гл а в а 1



массива. Если да, то ответ получен. Если нет, то возможны
два случая.
    1. Х меньше среднего по положению элемента, следо-
вательно, в силу упорядоченности массива можно исклю-
чить из рассмотрения все элементы массива, расположен-
ные правее этого элемента, так как они заведомо больше
его, который, в свою очередь, больше Х, и применить этот
метод к левой половине массива.
    2. Х больше среднего по положению элемента, следо-
вательно, рассуждая аналогично, можно исключить из
рассмотрения левую половину массива и применить этот
метод к его правой части.
    Средний по положению элемент и в том, и в другом
случае в дальнейшем не рассматривается. Таким образом,
на каждом шаге отсекается та часть массива, где заведомо
не может быть обнаружен элемент Х.
    Пусть Х = 6, а массив состоит из 10 элементов:
                  3 5 6 8 12 15 17 18 20 25.
   1-й шаг. Найдем номер среднего по положению эле-
мента: m = [(1 + 10) / 2] = 5. Так как 6 < a[5], то далее мо-
жем рассматривать только элементы, индексы которых
меньше 5. Об остальных элементах можно сразу сказать,
что они больше, чем Х, вследствие упорядоченности мас-
сива и среди них искомого элемента нет.
                  3 5 6 8 12 15 17 18 20 25.
   2-й шаг. Сравниваем лишь первые 4 элемента массива;
значение m = [(1 + 4) / 2] = 2. 6 > a[2], следовательно, рас-
сматриваем правую часть подмассива, а первый и второй
элементы из рассмотрения исключаются:
                  3 5 6 8 12 15 17 18 20 25.
   3-й шаг. Сравниваем          два    элемента;   значение
m = [(3 + 4) / 2] = 3:
                  3 5 6 8 12 15 17 18 20 25.
     a[3] = 6. Элемент найден, его номер — 3.
Ос н о в ы а л г о р и т м и з а ц и и                    59


    В общем случае значение m равно целой части от дро-
би [(left + right) / 2], где left — индекс первого, а right —
индекс последнего элемента рассматриваемой части мас-
сива.
    Если Flag = 1, то нужное значение в массиве найдено,
а если Flag = 0, то значения, равного Х, в массиве нет.
    Алгоритм бинарного поиска можно применять только
для упорядоченного массива. Это происходит потому, что
данный алгоритм использует тот факт, что индексами эле-
ментов массива являются последовательные целые числа.
По этой причине бинарный поиск практически бесполе-
зен в ситуациях, когда массив постоянно меняется в про-
цессе решения задачи. Алгоритм также используется при
сортировке массивов методом бинарного включения (см.
п. 1.5.1).
    Ниже приведен фрагмент блок-схемы алгоритма би-
нарного поиска.
60                                                       Гл а в а 1


     Вопросы для самопроверки
1. Дайте определение алгоритма. Перечислите свойства алгоритма.
2. Назовите отличия программного способа записи алгоритмов
    от других способов.
3. Назовите базовые алгоритмические структуры и дайте им
    краткую характеристику.
4. Дайте определение цикла с заданным числом повторений.
    Когда целесообразно применять циклы этого вида?
5. Что такое итерационные циклы? Когда возникает необходи-
    мость в их использовании?
6. Определите основные отличия между циклами с постусло-
    вием и предусловием. Как они выполняются?
7. Что называется рекуррентной формулой? Когда она приме-
    няется?
8. Дайте определение массива. Поясните, почему для хране-
    ния его элементов используется непрерывная память.
9. Можно ли при вводе или выводе элементов массива ис-
    пользовать цикл с предусловием или с постусловием?
10. Укажите, как изменится алгоритм нахождения наибольше-
    го значения (пример 1.10), если все элементы массива — от-
    рицательные числа.
11. Если известно, что в массиве обязательно имеется отрицатель-
    ный элемент, то как изменится алгоритм решения задачи 1.14?
12. Дайте определение двумерного массива. Поясните особенно-
    сти хранения элементов двумерного массива.
13. Почему при составлении алгоритмов для решения задач
    с использованием двумерного массива применяется вложен-
    ный цикл?
14. Можно ли при решении задачи 1.19 использовать цикл с по-
    стусловием? Ответ поясните.
15. Перечислите простые алгоритмы сортировки и укажите их
    основные отличия.
16. Почему сортировка включениями является неэкономным
    методом?
17. Какими характеристиками должен обладать массив, чтобы
    применение шейкер-сортировки было эффективным?
18. Чем сортировка Шелла отличается от сортировки простыми
    вставками?
19. Назовите метод сортировки, который является лучшим сре-
    ди простых методов. Поясните, за счет чего это достигается.
20. Почему алгоритм бинарного поиска превосходит «слепой»
    поиск? Какими характеристиками должен обладать массив,
    в котором применяется алгоритм бинарного поиска?
                                                 Гл ава 2

              Основы программирования
                           на языке C++




П    рограмма — это алгоритм, записанный на каком-либо
     языке программирования (формальном языке).
    Программа предназначена для обработки данных
(управления данными). В процессе работы приложения
сама программа (или ее часть) и данные (или их часть) на-
ходятся в оперативной памяти компьютера (ОЗУ).
    Язык программирования является инструментом
для написания программ. Языки программирования,
в том числе C++, относятся к формальным языкам. Зада-
чей формальных языков является описание алгоритмов
и функций, которые выполняет компьютер. Формаль-
ные языки отличает небольшой набор изобразительных
средств соответственно целям этих языков. В состав систе-
мы правил алгоритмического языка входят две группы.
    1. Синтаксис — формальный набор правил, опреде-
ляющий способ построения любых конструкций языка.
    2. Семантика — множество правил, определяющих
смысл синтаксических конструкций.
    Алгоритм решения задачи записывается программи-
стом согласно синтаксическим правилам языка, и это
программа. Семантика реализована в компиляторе, кото-
рый переводит код во внутреннее представление. Компи-
лятор обнаруживает синтаксические ошибки, допущен-
ные в коде программы.
    Для разработки приложений в современном програм-
мировании используются интегрированные среды разра-
ботчика (Integrated Developer Environment — IDE, или
62                                              Гл а в а 2



Rapid Application Development — RAD), которые позво-
ляют программировать быстро и надежно. Современные
среды разработчика являются многоязыковыми и позво-
ляют в одном проекте кодировать на разных языках. Так,
Visual Studio.Net поддерживает языки С++, С#, Basic
и Fortran#.
    Обязательными этапами обработки кода программы
на языке С++ являются:
  • препроцессорное преобразование;
  • компиляция;
  • компоновка.
    Задачей препроцессора является преобразование тек-
ста программы до ее компиляции. Препроцессор сканиру-
ет текст, находит в нем команды, называемые директива-
ми препроцессора, и выполняет их. В результате проис-
ходят изменения в исходном тексте: вставка фрагментов
текста и замена некоторых его фрагментов. Полученный
текст называется полным текстом программы.
    На этапе компиляции полный код программы преоб-
разуется во внутреннее машинное представление, неко-
торую последовательность команд, которая понятна ком-
пьютеру. Компилятор находит ошибки несоответствия
кода программы синтаксическим правилам языка.
    На этапе компоновки происходит редактирование
связей и сборка исполнимого кода программы. Компо-
новщик обрабатывает все вызовы библиотечных функций
и выполняет их подключение. Таким образом, к компи-
лированному исходному коду добавляются необходимые
функции стандартных библиотек. Готовый код является
исполнимым и может быть выполнен компьютером.

     2.1. Начальные сведения о языке 
     программирования C++
   Чтобы писать хорошие программы, недостаточно
знать правила записи синтаксических конструкций, не-
обходимо отчетливо представлять себе механизмы, встро-
енные в реализацию компилятора, которые, собственно,
и являются той самой семантикой.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   63

     2.1.1. Алфавит языка С++ и лексемы
      Алфавит — набор символов, разрешенных для по-
строения синтаксических конструкций. Алфавит языка
С++ содержит четыре группы символов.
      1. Буквы. Разрешается использовать буквы латинско-
го алфавита, прописные (A–Z) и строчные (a–z). Русские
буквы не входят в алфавит, но используются в коммента-
риях и текстовых константах, там, где они не влияют на
смысл программы.
      2. Цифры. Используются арабские цифры 0, 1, ..., 9.
      3. Специальные символы. Они могут быть разделены
на подгруппы:
   • знаки препинания (разделители): , ; . : ;
   • знаки операций: +, –, *, /, %, &, |, ?, !, <, =, >;
   • парные скобки: [ ], { }, ( ), " ", ' ';
   • прочие символы: _, #, ~, ^.
      4. Невидимые символы. Они могут считаться раз-
делителями, их особенность в том, что символы суще-
ствуют (каждый имеет код), но в редакторе не видны.
Это такие символы, как пробел, табуляция, разделитель
строк. Их общее название — обобщенные пробельные
символы.
      Из символов алфавита строятся все конструкции
языка.
      Лексема — это единица текста (конструкция, слово),
воспринимаемая компилятором как единое неделимое
целое. Можно выделить пять классов лексем.
      1. Имена (идентификаторы) для именования про-
извольных объектов программы, например, x1, Alpha,
My_file.
      2. Служебные (ключевые) слова, обозначающие кон-
струкции языка (имена операторов), например, for, while,
do.
      3. Константы, например, 1, 12.5, “Василий”.
      4.       Операции (знаки         операций),     например,
++, >=, !=, >.
      5. Разделители (знаки пунктуации), например,
[ ], ( ), { }.
64                                               Гл а в а 2


     2.1.2. Концепция данных в языке С++
    Данные — все, что подлежит обработке с помощью
программы. Данные, используемые приложением,
должны быть описаны в программном коде. Классифи-
кацию данных можно выполнять по нескольким кате-
гориям.
    1. По типу. Каждое данное имеет тип. Типы данных
можно разделить на базовые, т. е. такие, правила орга-
низации которых предопределены реализацией языка,
и конструируемые, т. е. те, которые пользователь строит
по определенным правилам для конкретной задачи.
    2. По способу организации. Для каждого из простых
(базовых) типов каждое данное может быть неизменяе-
мым или изменяемым. По способу организации данные
делятся на два класса:
  • константа — данное, которое не меняет своего значе-
    ния при выполнении программы и присутствует в тек-
    сте программы явным образом. Тип константы опреде-
    лен ее записью;
  • переменная — данное, которое изменяется при вы-
    полнении программы и в тексте присутствует своим
    именем (идентификатор). Тип переменной величины
    должен быть объявлен в тексте программы.
    Каждое данное, независимо от способа организации,
обладает типом. Тип данного очень важен, так как он
определяет:
  • механизм выделения памяти для записи значений пе-
    ременной;
  • диапазон значений, которые может принять перемен-
    ная;
  • список операций, которые разрешены над данной пе-
    ременной.
    Механизм выделения памяти и внутреннего представ-
ления данного важнее всего, диапазон значений и опера-
ции являются следствием из первого.
    Тип любого данного программы должен быть объяв-
лен обязательно. Для констант тип определен явно запи-
сью константы в тексте программы. Для переменных тип
должен быть задан в объявлении объекта. При объявле-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +                        65


нии переменной происходит выделение области памяти,
размер которой определен типом переменной и в которой
хранится значение переменной.
    Классификация типов данных:
  • простые типы (базовые, скалярные, внутренние,
    предопределенные);
  • конструируемые типы (массивы, строки, структуры,
    функции и др.).
    Основные типы данных определены ключевыми сло-
вами, список которых приведен в таблице 2.1.
                                                                          Та блица 2.1
          Ключевые слова, определяющие основные типы данных
   Имя                   Значение типа                     Размер   Диапазон значений
   типа
 char       Символьный (целое)                            1 байт    –128–127
 int        Целый                                         4 байта   ±2 147 483 649
            С плавающей точкой (действи-
 float                                                    4 байта   3.4e-38–3.4e38
            тельный)
            Двойной точности (действитель-
 double                                                   8 байт    1.7e-308–1.7e308
            ный)
 void       Любой или никакой                                       Не ограничен

   Замечания
   1. В языке С++ для определения размера памяти, за-
нимаемой объектом, есть операция sizeof(), например,
sizeof(int); sizeof(double); sizeof(My_obj).
   В качества аргумента операции можно указать имя
типа (int, double) или имя объекта (My_obj).
   2. Существует специальный тип данных void, кото-
рый относится к базовым, но имеет существенные осо-
бенности. Про данное такого типа говорят, что оно «не
имеет никакого типа». На самом деле тип void использу-
ется при работе с динамическими данными и может адре-
совать пространство произвольного размера, где можно
разместить данное любого типа. Значит, можно считать,
что данное типа void может представлять «данное любого
типа».
   3. Основные типы данных можно изменить (модифи-
цировать) с использованием вспомогательных ключевых
слов long и unsigned:
66                                                            Гл а в а 2



 • long (длинный) увеличивает объем выделяемой памя-
   ти в 2 раза;
 • unsigned (без знака) не использует знаковый бит, за
   счет чего хранимое значение может быть увеличено.

     2.1.3. Константы в языке С++
   Синтаксис языка выделяет пять типов констант: це-
лые, действительные (вещественные), символьные, пере-
числимые, нулевой указатель.

                       Целые константы
    Синтаксис языка позволяет использовать константы
трех систем счисления: десятичные, восьмеричные, шест-
надцатеричные. Основание определяется префиксом в за-
писи константы. По умолчанию основание 10, префикс 0
предваряет восьмеричную константу, префикс 0х или 0Х
предваряет шестнадцатеричную константу. В остальном
запись целых констант соответствует общепринятой.
    Примеры записи целых констант приведены в табли-
це 2.2.
                                                         Та блица 2.2
                   Примеры записи целых констант
      Десятичные           Восьмеричные          Шестнадцатеричные
          127                  012                     0xА
         –256                  –014                   –0x10


    Целые числа в памяти компьютера представлены
в форме с фиксированной точкой. Эта форма позволяет
представить значение с абсолютной точностью. На рисун-
ке 2.1 показано представление целого числа в двухбайто-
вой ячейке памяти.




                              Рис. 2.1
                     Представление целых чисел
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   67

                        Действительные константы
    Вещественные (действительные) числа представлены
в памяти компьютера в форме с плавающей точкой в виде
М ? 10р, где М — мантисса вещественного числа; 10 —
основание системы счисления; р — показатель десятич-
ной степени, целое число со знаком. Основание системы
счисления в языке С++ заменяется буквой е или Е. Неко-
торые из составляющих могут быть опущены.
    Примеры записи действительных констант:
                 44. 3.1415926 44.е0 .31459Е1 0.0
    На рисунке 2.2 показано представление вещественно-
го числа в четырехбайтовой ячейке памяти.




                                    Рис. 2.2
                        Представление вещественных чисел


                            Символьные константы
    Символьная константа — это лексема, которая со-
держит произвольный символ, заключенный в одинар-
ные кавычки (апостроф). Хранится в одном байте памяти
в виде целого числа, определяющего целочисленный код
символа. Символьной константой может быть любой сим-
вол, изображаемый на экране в текстовом режиме, или не
имеющий отображения (пробельный символ).
    Примеры символьных констант: '!', '.', 's', 'А', '+', '2'.
    Существуют также управляющие символы (ESC-
последовательности), которые используются в строко-
вых константах и переменных. Они имеют признак '\'
(backslash или обратный слеш), который используется
для указания управляющего воздействия. Вот их непол-
ный список:
    '\0' — нулевой символ;
    '\n' — перевод строки;
    '\r' — возврат каретки;
68                                               Гл а в а 2



   '\t' — табуляция;
   '\' — апостроф;
   '\\' — обратный слэш;
   '\ddd' — восьмеричное представление символьной кон-
станты, где ddd — ее восьмеричный числовой код, напри-
мер, '\017' или '\233';
   '\xhh' или '\Xhh' — шестнадцатеричное представление
символьной константы, где hh — ее числовой код, напри-
мер, '\x0b' или '\x1F'.
   Символьные константы имеют целый тип и могут ис-
пользоваться в выражениях.

                    Строковые константы
   Формально строки не относятся к константам языка
С++, а представляют отдельный тип его лексем. Строко-
вая константа определяется как набор символов, заклю-
ченных в двойные кавычки " ".
   Например,
#define STR "Программа"
   В конце строковой константы добавляется нуле-
вой символ '\0'. В тексте строки могут встретиться ESC-
последовательности, которые будут выполнять управля-
ющее воздействие.
   Например,
"\nПри выводе \nтекст может быть \nразбит на строки."
   Здесь "\n" выполняет управляющее воздействие, и вы-
вод будет таким:
При выводе
текст может быть
разбит на строки.
   При хранении строки все символы, в том числе управ-
ляющие, хранятся последовательно, и каждый занимает
ровно один байт.

     Типы числовых констант и модификаторы типов
   Для модификации типа числовых констант исполь-
зуются префиксы и суффиксы, добавляемые к значению
константы. Суффикс l(L) от слова long увеличивает дли-
ну данного в два раза, суффикс u(U) от слова unsigned
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   69


используется для чисел, не содержащих знак, т. е. по-
ложительных, при этом увеличивается число разрядов,
отводимых под запись числа, а значит, и его возможное
значение.
    Например, длинные константы 12345l, –54321L; кон-
станты без знака 123u, 123U; шестнадцатеричная длинная
константа 0xb8000000l; восьмеричная длинная константа
без знака 012345LU.

     2.1.4. Переменные в языке С++
    Одним из основных понятий в языках программиро-
вания является объект. Будем использовать это понятие
как объект программного кода.
    Объект — это некоторая сущность, обладающая опре-
деленным набором свойств и способная хранить свое со-
стояние.
    Объектами программного кода являются константы,
переменные, функции, типы и т. д.
    Переменная — это объект, для использования которо-
го необходимо определить три характеристики:
  • имя;
  • тип;
  • значение (не обязательно).
    Имя переменной (идентификатор) обозначает в тексте
программы величину, изменяющую свое значение. Для
каждой переменной выделяется некоторая область памя-
ти, способная хранить ее значение. Имя позволяет осу-
ществить доступ к области памяти, хранящей значение
переменной.
    Тип переменной определяет размер выделяемой памя-
ти и способ хранения значения (см. рис. 2.1, 2.2).
    Значение переменной не определено вначале, изменя-
ется при присваивании переменной значения.
    Имя переменной (идентификатор) включает в себя ла-
тинские буквы, цифры, знак подчеркивания "_". Первым
символом должна быть буква.
    Примеры идентификаторов: x1, Price, My_file1, alpha,
PI. В качестве имен рабочих переменных используются
простые имена i, j, k1, k2 и им подобные.
70                                                                      Гл а в а 2



    Ограничения:
  • длина имени содержит не более 32-х символов;
  • в качестве имен нельзя использовать ключевые слова
    языка С++, например, названия операторов for, if, do;
  • в качестве имен не рекомендуется использовать имена
    объектов стандартных библиотек, например, имена
    функций sin(), sqrt(), pow();
  • имена, которые начинаются со знака подчеркива-
    ния, зарезервированы для использования в библио-
    теках и компиляторах, поэтому их не следует выби-
    рать в качестве прикладных имен, например, _acm,
    _AX, _BX.
    Перечень основных, не всех служебных слов приведен
в таблице 2.3.
                                                                  Та блица 2.3
                     Служебные слова в языке C++
                         char, double, enum, float, int, long, short, struct,
Типы данных              signed, union, unsigned, void, typedef
Квалификаторы типа const, volatile
Классы памяти            auto, extern, register, static

Названия операторов break,,continue  , do, for, goto, if…else, return,
                    switch while, case, default, sizeof
Модификаторы        asm, far, interrupt, pascal и др.
Псевдопеременные    Названия регистров _AH _DS _DX и др.


   Замечания
   1. Рекомендуется использовать имена переменных,
отражающие их первоначальный смысл, например, Count
(количество), X_coord (координата по х), Old_value_of_long
(предыдущее значение длины).
   2. Заглавные и строчные буквы считаются различны-
ми. Так, разными объектами будут переменные, имею-
щие имена Alpha и alpha.
   3. Идентификаторы, зарезервированные в языке,
являются служебными (ключевыми) словами. Следо-
вательно, их нельзя использовать как имена свободных
объектов программы. К ним относятся типы данных, ква-
лификаторы типа, классы памяти, названия операторов,
модификаторы, псевдопеременные.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +     71

     2.1.5. Объявление переменных
   Каждая переменная должна быть объявлена в тексте
программы перед первым ее использованием. Начинаю-
щим программистам рекомендуется объявлять перемен-
ные в начале тела программы перед первым исполнимым
оператором. Синтаксис объявления переменной требует
указать ее тип и имя:
Имя_типа Имя_переменной;
   Можно одновременно объявить несколько перемен-
ных, тогда в списке имен они отделяются друг от друга
запятой, например:
int a, b, c;		                       // целые со знаком
char ch, sh;		                       // однобайтовые символьные
long l, m, k;		                      // длинные целые
float x, y, z;		                     // вещественные
long double u, v		                   // длинные двойные
    На этапе компиляции для объявленных переменных
в ОЗУ будет выделена память для записи их значений.
Имя переменной определяет адрес выделенной для нее
памяти, тип переменной определяет способ ее хранения
в памяти. Как следствие, тип определяет диапазон ее воз-
можных значений и операции, разрешенные над этой ве-
личиной.

     2.1.6. Инициализация переменных
   Переменные, объявленные в программе, не имеют
значения, точнее имеют неопределенные значения. Так
как память, выделенная под запись переменных, не очи-
щается, то значением переменной будет «мусор» из того,
что находилось в этой памяти ранее.
   Инициализация — это прием, который позволяет при-
своить значения переменным при их объявлении. Син-
таксис инициализации:
Имя_типа Имя_переменной = Начальное_значение;
     Например,
float pi=3.1415;
unsigned Year=2014;
72                                                  Гл а в а 2


     2.1.7. Именованные константы
   В языке C++, кроме переменных, можно использовать
именованные константы, т. е. константы, имеющие фик-
сированные названия (имена). Имена могут быть произ-
вольными идентификаторами, не совпадающими с други-
ми именами объектов. Принято использовать в качестве
имени константы большие буквы и знаки подчеркивания,
что визуально отличает имена переменных от имен кон-
стант. Способов определения именованных констант три.
   Первый способ — это константы перечисляемого типа,
имеющие синтаксис:
enum тип_перечисления {список_именованных_констант};
   Здесь «тип_перечисления» — это его название, необяза-
тельный произвольный идентификатор; «список_имено-
ванных_констант» — это разделенная запятыми последова-
тельность вида:
имя_константы = значение_константы
     Примеры.
enum BOOL {FALSE, TRUE};
enum DAY {SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
????????? THURSDAY, FRIDAY, SATURDAY};
enum {ONE=1, TWO, THREE, FOUR, FIVE};
   Если в списке нет элементов со знаком «=», то значе-
ния констант начинаются с 0 и увеличиваются на 1 слева
направо. Так, FALSE равно 0, TRUE равно 1. SUNDAY равно
0 и так далее, SATURDAY равно 6. Если в списке есть эле-
менты со знаком «=», то каждый такой элемент получает
соответствующее значение, а следующие за ним увеличи-
ваются на 1 слева направо, так, значение ONE = 1, TWO = 2,
THREE = 3, FOUR = 4, FIVE = 5.
    Второй способ — это именованные константы, задан-
ные с ключевым словом const в объявлении типа:
const Имя_типа Имя_константы = Значение_константы;
   Ключевое слово const имеет более широкий смысл
и используется также в других целях, но здесь его суть
в том, что значение константы не может быть изменено.
    Примеры.
const float Pi=3.1415926;
const long M=999999999L;
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +                       73


   Попытка присвоить значение любой из констант Pi,
M будет неудачной. Визуализация имен констант с помо-
щью использования больших букв необязательна.
   Третий способ ввести именованную константу дает
препроцессорная директива #define, подробный синтаксис
и механизм выполнения которой будет рассмотрен далее.

     2.2. Операции и выражения языка C++
   Операция — это символ или лексема вычисления зна-
чения. Операции используются для формирования и вы-
числения значений выражений и для изменения значе-
ний данных.

     2.2.1. Классификация операций
   Классифицировать операции можно по нескольким
признакам. Приведем два варианта: по типу возвращае-
мого значения и по числу операндов.
   1. Тип возвращаемого значения является важным
свойством любой операции. В таблице 2.4 приведена клас-
сификация операций по типу возвращаемого значения.
                                                                           Та блица 2.4
       Классификация операций по типу возвращаемого значения
                      Арифметические                                 Логические
+ сложение                                                      > больше
– вычитание                                                     < меньше
* умножение                                                     == равно
/ деление (для целых операндов — целая часть                    != не равно
от деления)
% остаток от деления (только для целых)                         >= больше или равно
                                                                <= меньше или равно
                                                                && логическое «И»
                                                                || логическое «ИЛИ»
                                                                ! логическое «НЕ»

    Арифметические операции имеют обычный матема-
тический смысл. Для целого типа данных существуют
две операции деления: целочисленное деление / и остаток
от деления %. Каждая из этих операций, примененная
к данным целого типа, возвращает целое значение.
74                                                    Гл а в а 2



     Пример 2.1.
int x=5, y=3;
x/y		           // результат = 1
x%y		           // результат = 2
y/x		           // результат = 0
y%x		           // результат =3
x=–5		          // знак сохраняется
x/y		           // результат=–1
x%y		           // результат= –2
y/x             // результат=0
y%x		           // результат=3
   Логические операции предназначены для проверки
условий и для вычисления логических значений.
   Замечание. Логического типа данных в стандарте языка
С++ нет, его имитирует тип int (условно принято, что 0 — это
значение «Ложь», а все отличные от нуля значения — это
«Истина»). Компилятор Visual Studio 2013 в качестве логи-
ческого типа позволяет использовать тип bool, например:
bool yes;
yes=x>0;
    Логическими являются операции, возвращающие ло-
гическое значение. Их можно, в свою очередь, разбить на
две группы.
    Операции отношения. Связывают данные числовых
или символьных типов и возвращают логическое значе-
ние, например:
3>1			                 // истина, не равно 0
'a'>'b'			             // ложь равна 0
х>=0			                // зависит от х
y!=x			                // зависит от х и от у
   Значение операции отношения может быть присвоено
целой переменной или переменной логического типа, на-
пример:
int a=5, b=2;
bool c;
c=a>b; 			             // c = 1
c=a<b; 			             // c = 0
c=a==b; 		             // c =0
c=a!=b; 			            // c = 1
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   75


   Операции отношения могут участвовать в записи вы-
ражения наряду с арифметическими операциями, тогда
при вычислении значения выражения важен порядок вы-
числения, например:
c=10*(a>b);    // a > b = 1, 10 * 1 = 10, значит, с = 10
c=10*(10*a<b); // 10 * a = 50, 50 < b = 0, 10 * 0 = 0, с =0
c=1<a&&a<10; // 1 < a = 1, а < 10 = 1, значит, с = 1
   Собственно логические операции. Связывают данные
логического типа (целые) и возвращают логическое зна-
чение. Это логические операции конъюнкция &&, дизъ-
юнкция || и отрицание !, которые применяются к значе-
ниям операндов, имеющих логическое значение. Если
операндом является отношение, то предварительно вы-
числяется его значение, например:
// оба операнда (x>0 и y>0) одновременно истинны
                                                х>0 && y>0;
// хотя бы один операнд (x % 2==0 или y % 2==0) истинен
х%2==0||y%2==0;
// значение, обратное значению операнда
// (x*x+y*y<=r*r)
!(x*x+y*y<=r*r);
   2. Второй вид классификации операций языка С++ —
классификация по числу операндов.
   1) Унарные операции имеют только один операнд, на-
пример:
+10, –а, !(x>0), ~a.
   2) Бинарные операции имеют два операнда, напри-
мер:
х+5, x–y, b&&c.
   3) Тернарная операция имеет три операнда, это опера-
ция условия, приведем ее синтаксис здесь:
Логическое_выражение ? Выражение1 : Выражение2
    Операция условия выполняется в два этапа. Сначала
вычисляется значение логического выражения. Затем,
если оно истинно, вычисляется значение второго операн-
да, который назван «Выражение1», оно и будет резуль-
татом, иначе вычисляется значение третьего операнда,
который назван «Выражение2», и результатом будет его
значение.
76                                                           Гл а в а 2



   Например, вычисление абсолютного значения некото-
рого i:
int abs;
abs=(i<=0)?–i:i;

     2.2.2. Операции изменения данных
   Операции изменения данных имеют особое значение,
позволяя выполнить присваивание значения переменной.
   Список операций изменения данных приведен в та-
блице 2.5.
                                                        Та блица 2.5
                    Операции изменения данных
      Основные операции     Арифметические операции с присваиванием
= операция присваивания  += сложение с присваиванием
++ увеличение на единицу –= вычитание с присваиванием
–– уменьшение на единицу *= умножение с присваиванием
                         /= деление с присваиванием
                         %= остаток от деления с присваиванием

    Операция присваивания в C++ — это обычная операция,
которая является частью выражения, но имеет очень низкий
приоритет и поэтому выполняется в последнюю очередь. Се-
мантика этой операции заключается в том, что вычисляется
выражение правой части и присваивается левому операнду.
Это означает, что слева может быть только переменная ве-
личина, которая способна хранить и изменять свое значение
(левостороннее выражение). В правой части, как правило,
записывается вычисляемое выражение.
    Пример 2.2.
х=2;			                   // х принимает значение константы
cond=(x<=2);		            // cond принимает логическое
			                       // значение
3=5;			                   // ошибка, слева константа
x=x+1;			                 // x принимает значение,
			                       // увеличенное на 1
   Расширением операции присваивания являются опе-
рации вычисления с присваиванием, которые еще назы-
ваются «присваивание после» и позволяют сократить за-
пись выражений, например:
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +                77


х+=5;			                             // аналог записи x = x + 5
y*=3			                              // аналог записи y = y * 3
     Пример 2.3.
     Пусть c = 5, a = 3; тогда
c+=a;			                             // c = 8
c–=a;			                             // c = 2
c*=2;			                             // c = 10
c/=4;			                             // c = 1
   Необычными операциями являются операции увели-
чения и уменьшения на единицу, имеющие самостоятель-
ные названия инкремент и декремент, например:
x++;			                              // аналог записи x = x + 1 или х += 1
– –x;			                             // аналог записи x = x – 1 или х –= 1
   Каждая из этих операций имеет две формы.
   1. Префиксная ++x или – –х. При ее выполнении x из-
меняется прежде, чем выполняются другие операции,
входящие в выражение.
   2. Постфиксная x++ или х– –. При ее выполнении сна-
чала выполняются все операции выражения, и только по-
том изменяется х.
   Пример 2.4.
int q, a;
a=2;
q=2*++a; // сначала а увеличивается на 1, т. е. а = 3,
          // затем а умножается на 2 и результат
          // присваивается q
q=2*a++; // сначала а умножается на 2, результат
          // присваивается
          // q, затем а увеличивается на 1,
          // после чего а = 5

     2.2.3. Выражения в зыке С++
   Выражение — это правило вычисления одного зна-
чения.
   Формально выражение — это несколько операндов,
объединенных знаками операций. В качестве операн-
дов выступают константы, имена переменных, вызовы
операций-функций. Кроме того, в запись выражения мо-
гут входить технические символы, такие как скобки ().
78                                                            Гл а в а 2



Как правило, смыслом выражения является не только
вычисление значения, но и присваивание его перемен-
ной, поэтому в записи выражения присутствует операция
присваивания «=» или ее клоны.
   Поскольку все данные в С++ (переменные, константы
и другие объекты) имеют тип, то значение, вычисленное
выражением, также будет иметь тип, который определя-
ется типом операндов, например, как в таблице 2.6.
                                                      Та блица 2.6
            Примеры определения типа выражения
       Операнды                Операции           Результат
Целые                     +–*/%             Целый
Вещественные              +–*/              Вещественный
Числовые или символьные   > < != == >= <=   Логический (int, bool)
Логические                && ! ||           Логический

     Если тип вычисленного выражением значения не со-
впадает с типом переменной левой части, то происходит
преобразование (приведение) типов.
     Порядок вычисления выражений определяется ран-
гом (приоритетом) входящих в него операций и прави-
лами ассоциативности, которые применяются при вычис-
лении значений выражений, если несколько операций
одного приоритета стоят подряд. Большинство операций
левоассоциативны (>), т. е. вычисляются слева направо
естественным образом, например, бинарные операции.
Однако есть правоассоциативные операции (<), которые
вычисляются справа налево.
     Например, операция присваивания позволяет выпол-
нить цепочку присваиваний: х = y = z = 10;
     Здесь цепочка раскрывается по порядку z = 10, затем
y = z, затем x = y.
     В таблице 2.7 приведены приоритеты операций С++.
     Из таблицы 2.7 видно, что принятый ранг операций
наиболее близок к математическому, также как и приня-
тый порядок их вычисления. Так, умножение и деление
(мультипликативные операции) старше сложения и вы-
читания (аддитивные операции). Унарные операции + и –
старше бинарных, стало быть, знак операнда вычисляет-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +                79

                                                                    Та блица 2.7
                  Полная таблица приоритетов операций С++
 Ранг (приоритет)                        Операции               Ассоциативность
         1             () [] –> (операции разыменования)              >
          2            ! ~ + – ++ –– & * (тип) sizeof                 <
          3            * / % (бинарные)                               >
          4            + – (бинарные)                                 >
         5             << >> (сдвиг)                                  >
         6             < <= > >= (отношения)                          >
          7            == != (отношения)                              >
          8            &                                              >
         9             ^ (поразрядное исключающее или)                >
         10            |                                              >
         11            &&                                             >
         12            ||                                             >
         13            ? : (условная операция)                        <
         14            = *= /= %= += –= &= ^= |= <<= >>=              <
         15            , (операция запятая)                           >

ся в первую очередь. Операция присваивания и ее клоны
младше прочих, что позволяет выполнить присваивание
только после того, как значение выражения вычислено
полностью. Операции отношения младше арифметиче-
ских операций, что позволяет использовать естественную
запись логических выражений, например, x>0 && y>0.
Здесь в первую очередь вычисляются значения отноше-
ний, которые затем являются операндами конъюнкции.
    Пример 2.5.
int c, a=5, b=3;
c=a++;		                         // c=5, а=6
c=a++*3;		                       // c=a*3=15, потом а=7
с=––а/2;		                       // ––a, a=6, потом c=а/2=3
c=a+++b; 		                      // сначала с=a+b=9, потом а++, а=7
c=a++ + ++b;		                   // ++b=4, потом c=а+b=11, потом а++8

                                Приведение типов
    Под приведением типов понимаются действия, кото-
рые компилятор выполняет в случае, когда в выражении
смешаны операнды различных типов, чего, строго говоря,
не следует допускать. Механизм приведения типов в С++
заключается в том, что при вычислении значения выраже-
80                                                    Гл а в а 2



ния компилятор, не изменяя внутреннего представления
данных, преобразует данное «меньшего» типа к «больше-
му», где «величину» типа определяет размер выделенной
для него памяти. Такое преобразование выполняется без
ведома программиста и может привести к потере данных.
    Пример 2.6. Известно, что целое значение представле-
но в памяти точно, а вещественное приближенно.
int a=5, b=2;
float c;
c=a*1.5;         // в выражении операнды разных типов
		               // автоматически включаются механизмы
		               // приведения типов, с=7.5

                   Преобразование типов
    Под преобразованием типов в выражениях понимают-
ся действия, выполняемые при присваивании.
    Пример 2.7.
int a=5, b= 2;
float c;
с=a/b;
   Хочется думать, что значение с будет равно 2.5, ведь
оно вещественное, но порядок операций таков, что деле-
ние старше присваивания и оно выполняется с операнда-
ми целого типа, и его результат с = 2, т. е. приведение типа
будет выполнено только при присваивании.
   Для того чтобы избежать потери информации, в выра-
жениях следует применять операцию явного преобразова-
ния типа, синтаксис которой:
(Имя_типа) Имя_переменной;
    Эта запись включается в те выражения, в которых не-
обходимо выполнить преобразование перед вычислением.
В этом случае программист явно указывает компилятору,
что тот должен сделать.
    Пример 2.8.
    Перепишем пример 2.7.
int a=5, b=2;
float c;
с=(float)a/2.0; // c=5.0/2.0=2.5
b=(int)c/b;     // b=2/2=1
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   81


    При выполнении присваивания, если типы левой
и правой частей выражения не совпадают, происходит не-
явное преобразование. Компилятор С++ всегда пытается
это сделать, и упрощенно можно считать, что преобразо-
вание происходит без потери данных от меньшего типа
к большему, например от int к float или от char к int, и с по-
терей данных из большего типа к меньшему, например от
float к int. Это легко понять, если вспомнить, что тип дан-
ного — это объем занятой им памяти.
    Рекомендуется строго относиться к типам данных, не
смешивать типы в выражениях, следить, чтобы тип лево-
го операнда присваивания соответствовал типу выраже-
ния правой части.

     2.3. Структура и компоненты простой
     программы на языке C++

     2.3.1. Функция main()

   В современных средах программирования програм-
ма — это «проект». В состав проекта входят один или не-
скольких файлов с расширением «.с» или «.сpp». Все ис-
ходные файлы компилируются и собираются совместно.
Простейшие программы содержатся в одном текстовом
файле.
   Программа может состоять из одной или нескольких
функций. Функция — это самостоятельный именованный
алгоритм решения некоторой законченной задачи. Одна
из функций должна иметь имя main(). С нее всегда начи-
нается выполнение программы. Любая функция, кроме
main(), может быть вызвана из другой функции. При вы-
зове функции могут быть переданы параметры (данные).
По окончании выполнения функции в вызывающую
функцию может быть возвращено значение (результат),
а может не быть возвращено ничего. Примером обраще-
ния к функциям являются библиотечные функции, на-
пример, sin(x), fabs(a).
   Функция обладает типом, соответствующим возвра-
щаемому значению. Если функция ничего не возвращает,
82                                                         Гл а в а 2



ее тип void. Если функция не имеет аргументов, вместо
них в списке параметров записывается слово void.
    Пример 2.9.
void main(void)      // не имеет типа и не имеет параметров
main()		             // тип функции по умолчанию будет int,
		                   // аргументов нет, значит, их может быть
		                   // произвольное число
     Пример функций, не возвращающих значения —
printf(), scanf().

     2.3.2. Комментарии
   Комментарии предназначены для записи пояснений
и примечаний к тексту программы и не влияют на выпол-
нение программы. Они записываются на родном языке
программиста.
   В языке С++ существуют два вида комментариев.
   1. Многострочный комментарий записывается в любом
месте текста программы в скобках вида /*   */. Перево-
дит в разряд примечаний весь текст, заключенный между
ними. Такие комментарии удобны при отладке программы,
чтобы исключить фрагмент кода, или для пояснений.
   2. Однострочный комментарий записывается в любой
строке программы после сочетания символов //. Коммен-
тирует весь текст до окончания строки. Используется для
пояснений к строкам.
   Использование комментариев является признаком
хорошего стиля программирования. Так, необходимы
пояснения к смыслу объявленных объектов программно-
го кода, к используемым алгоритмам, к структуре про-
граммного кода.

     2.3.3. Структура файла программы из одной функции.
            Блок операторов

     Код программы, которая состоит из одной функции
main(), обычно содержит следующие составляющие, хотя
почти все они могут отсутствовать:
#Директивы препроцессора    // начинаются с символа # и
                            // записываются в одну строку
Тип_функции main(параметры) // заголовок функции
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   83


{ // блок тела функции;
         определения объектов;
         исполняемые операторы;
         return выражение;     // если функция возвращает
                                                 значение
}
    В C++ объявление переменной (объекта) возможно
не только в начале программы, но и в любом месте тек-
ста до первого обращения к ней. Областью действия объ-
екта является только непосредственно охватывающий
его блок. Как правило, так объявляют рабочие перемен-
ные.
    Блок (операторов) — это произвольная последователь-
ность определений и операторов, заключенная в фигур-
ные скобки:
{
    // блок;
}
   Блок используется для укрупнения структуры про-
граммы. Точка с запятой в конце блока не ставится.
   Текст программы на языке C++ обладает структурой.
Существует система правил корректной записи текста
программ, которые просты, но улучшают зрительное вос-
приятие и понимание кода.
   1. Каждый оператор заканчивается знаком «;». Обыч-
ная ошибка начинающего — это знак «;», завершающий
заголовки функций или операторов цикла. В первом слу-
чае синтаксическая ошибка распознается как отсутствие
тела функции, во втором случае телом цикла является пу-
стой оператор, что синтаксической ошибкой не является,
и программа выполняется.
   2. Каждый оператор записывается в одну строку. Та-
кая запись позволяет структурировать текст программы,
наглядно видеть ее алгоритм, и облегчает отладку при по-
шаговом исполнении.
   3. Блок, т. е. произвольный фрагмент текста, заклю-
ченный в фигурные скобки {}, размещается в любом месте
программы. Использование блоков позволяет укрупнить
структуру алгоритма.
84                                                  Гл а в а 2



    4. Структура программы подчеркивается отступами.
Это позволяет визуально показать блоки, составляющие
структуру алгоритма.
    5. Необходимо использовать разумное количество
комментариев.
    6. Имена объектов программы выбираются осмыс-
ленно. Каждое имя подчеркивает назначение и логику
объекта, например, имена библиотечных функций sin(),
abs(), printf() и прочих говорят сами за себя. Имена объ-
ектов, введенные программистом, подчеркивают их аб-
страктный смысл, например, Count, Square, Point.x, Point.y
и т. д.
    7. Пробелы в тексте являются значащими только в со-
ставе текстовых констант. В коде программы пробелы от-
деляют друг от друга элементы текста. В остальных слу-
чаях их использование произвольно, например, лишние
пробелы улучшают читабельность программы.

     2.3.4. Директивы препроцессорной обработки
   Директивы начинаются со знака # и записываются
в одной строке. Являются командами (директивами),
выполняемыми препроцессором на стадии предвари-
тельной обработки текста программы, т. е. до ее компи-
ляции. Директив препроцессора достаточно много, на
начальном этапе достаточно ознакомиться с двумя из
них.

                   Директива #define
   Используется для задания именованных констант
и для задания строк подстановки.
   Синтаксис.
#define Имя Выражение
    Механизм действия директивы — макроподстановки,
т. е. препроцессор сканирует весь текст программы и вы-
полняет замены в тексте программы, везде вместо «Име-
ни» подставляя «Выражение».
    Замечание. Имена define определенных констант за-
писываются большими буквами, чтобы визуально отли-
чить их от имен переменных и других объектов.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +       85


     Пример 2.10.
#define N 10		        // по всему тексту вместо N число10
#define PI 3.1416926 // вместо PI его числовое значение
#define STR "Строковая константа, подставляется в текст\n"
   Директива #define может не только определить имено-
ванную константу, но и выполнить макроподстановки.
   Пример 2.11.
#define N1 N+1		                     // вместо N1 текст N+1
#define int long		                   // в тексте все описания int
			                                  // заменятся на long
   Если в замещаемом имени есть скобки, следующие за
именем без пробела, то это макроопределение с параме-
трами:
#define Имя(список_параметров) Выражение
     Например,
#define Cube(x) x*x*x
   Имя здесь играет роль имени макроопределения,
а параметров может быть несколько, тогда они отделя-
ются запятыми. Между именем и списком параметров
не должно быть пробела. Такое макроопределение мо-
жет использоваться как функция, хотя макроподста-
новки не заменяют функции, и иногда могут привести
к ошибкам.
   Пример 2.12.
#define Cube(x) x*x*x
// макроопределение возведения в степень
#include <stdio.h>
void main(void)
{
   int а=2;
   printf("%d %d", a, Cube(a)); // выведено 2 8
}

                               Директива #include
   Используется для замены в тексте путем добавления
текста из других файлов в точку нахождения #include.
   Синтаксис.
#include “filename”
#include <filename>
86                                                    Гл а в а 2



    Механизм действия — включение текста указанного
файла в текущее место в программе. Включаемые файлы
называются заголовочными и содержат информацию, ко-
торая для программы глобальна.
    Директива #include "filename" осуществляет поиск фай-
ла сначала в текущем каталоге, а затем в системных ката-
логах. Так подключаются личные файлы программиста,
содержащие произвольные тексты, например, определе-
ния констант, объявления или описания функций.
    Директива #include <filename> осуществляет поиск
файла только в системных каталогах. Так подключаются
стандартные заголовочные файлы, поставляемые в ком-
плекте со стандартными библиотеками функций.
    Каждая библиотечная функция имеет свое описание
(прототип). Кроме того, в заголовочных файлах описаны
многие константы, определения типов и макроподстанов-
ки. Например, стандартный заголовочный файл <stdio.h>
содержит описания библиотечных функций ввода и выво-
да, <math.h> подключается при использовании математи-
ческих функций. Их описание содержится в справочной
системе. Следует понимать, что использование #include
не подключает к программе соответствующую библиоте-
ку, а только включает в текст программы на глобальном
уровне все нужные описания и объявления. Сами библио-
течные функции подключаются к программе в виде объ-
ектного кода на этапе компоновки, когда компоновщик
обрабатывает все вызовы функций, определяет, какие
потребуются программе, и собирает исполнимый файл,
включая в него объектные (компилированные) коды тех
функций, к которым выполняется обращение.

     2.3.5. Ввод и вывод данных. Начальные сведения
   В этом подпараграфе описаны инструменты ввода-
вывода данных в классическом языке С с использованием
библиотеки stdio.h (standard input output library).
   Ввести данное — означает присвоить произвольное
значение переменной во время выполнения программы.
   Вывести данное — означает напечатать на экране зна-
чение переменной при выполнении программы.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   87


   Простейший из способов обмена данных — это фор-
матированный ввод-вывод с определением правил раз-
мещения данных во входном/выходном потоке. Для реа-
лизации такого обмена к программе директивой #include
<stdio.h> подключается библиотека stdio.h.
   Для ввода значения данного с клавиатуры с эхо повто-
ром на экране используется функция scanf(), синтаксис
которой:
scanf("форматная строка", список_ввода);
   Здесь «список_ввода» — имена переменных, значения
которых будут введены с клавиатуры при выполнении
функции scanf(). Имена переменных предваряются сим-
волом «&», который является признаком адресной опе-
рации и означает, что введенное значение пересылается
по адресу, определенному именем переменной. При вводе
данные отделяются пробелами или нажатием клавиши
[Enter].
    Для вывода значения данного на экран используется
функция printf(), синтаксис которой:
printf("форматная строка", список_вывода);
    Здесь «список_вывода» — список имен переменных
и выражений (в том числе констант), значения которых
появятся на экране при выполнении функции printf().
    Форматная (управляющая) строка — это строка сим-
волов внутри двойных кавычек, содержащая управляю-
щие символы и текст. При вводе данных функция scanf()
читает посимвольно текст из входного потока, распознает
лексемы и преобразует их в машинное представление в со-
ответствии с признаком формата, сопоставленного пере-
менной, ожидающей данное. При выводе функция printf()
берет машинное представление значения переменной, со-
ответственно признаку формата преобразует в текстовое
представление и выводит на экран.
    Число управляющих символов равно числу объектов
в списке ввода-вывода. Управляющий символ имеет при-
знак % и может иметь одно из следующих значений:
%d — ввод-вывод целого десятичного числа             (int),
%u — ввод-вывод целого без знака             (unsigned),
%f — ввод-вывод числа с плавающей точкой          (float),
88                                                      Гл а в а 2



%lf — ввод-вывод числа с плавающей точкой     (double),
%e — ввод-вывод числа в экспоненциальной форме
                                       (double и float),
%c — ввод-вывод символа 		                       (char),
%l — ввод-вывод длинного значения                (long),
и др.
    При вводе и выводе необходимо строгое соответствие
типа данного управляющему символу формата.
    Пример 2.13.
    Приведем пример форматированного ввода и вывода:
#include <stdio.h>
void main(void)
{
  int my_int;
  float my_float;
  printf("\nВведите целое и дробное число\n");
  scanf("%d", &my_int);
  scanf("%f", &my_float);
  printf("%d %f", my_int, my_float);
}
    При запуске программы функция printf() выведет на
экран строку — приглашение к вводу данных, затем при
выполнении каждой функции scanf() будет ожидать ввода
данных. Пользователь должен ввести требуемое количе-
ство данных, отделяя их пробелами или нажатием клавиши
[Enter]. При завершении ввода данные тут же будут выведе-
ны на экран самым примитивным образом. Так, если ввести
целое 5 и дробное 9.9, то строка вывода будет иметь вид:
59.900000
   Поскольку при вводе данного функция scanf() нахо-
дится в состоянии ожидания ввода, рекомендуется каж-
дый ввод предварять строкой, выводящей на экран при-
глашение к вводу данных, в котором пользователю под-
робно объясняют, что и как он должен сделать, чтобы
правильно ввести данные, например:
printf("Введите координаты центра и радиус круга\n");
scanf("%f%f%f", &x, &y, &R);
   При выводе данных для улучшения вывода рекомен-
дуется использовать некоторые приемы.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   89


   1. Управляющие символы, например:
   "\n" для перевода строки при выводе;
   "\t" для выполнения табуляции.
   2. Произвольный текст в форматной строке для при-
глашения на ввод данного и для пояснений при выводе,
например, функция вывода может быть записана так:
printf("Целое = %d, Вещественное = %f\n", my_int, my_float);
   Пробелы в строке текста являются значащими. Те-
перь, если ввести целое 5 и дробное 9.9, то строка вывода
будет иметь вид:
Целое = 5, Вещественное = 9.900000
    3. Модификаторы форматов. Они используются для
оформления вывода. По умолчанию (без модификаторов)
данные выводятся в поле минимальной ширины с точно-
стью 6 знаков после запятой, число прижимается к право-
му краю поля. Этим выводом можно управлять:
  • можно задать ширину поля как строку цифр, опреде-
    ляющую наименьший размер поля вывода, которое
    будет игнорировано, если число не входит в поле;
  • можно задать точность вывода для вещественных чи-
    сел: это две цифры, определяющие общий размер поля
    вывода и число знаков после запятой.
    В следующих примерах обозначим знаком ? пробелы,
которые будут значимыми в строке вывода.
    Пример 2.14.
printf("Целое=%4d, Вещественное=%5.2f\n", my_int, my_float);
   Если ввести значения 10 и 2.3, то строка вывода будет
иметь вид:
Целое = ??10, Вещественное = ?9.90
   Если ввести значения 19951 и 12.9999, то строка вы-
вода будет иметь вид:
Целое = 19951, Вещественное = 13.00
   Можно сделать вывод, что число округляется.
   4. Знак минус используется для выравнивания числа
влево внутри поля вывода:
printf("Целое=%–4d, Вещественное=%–5.2f\n", my_int,
my_float);
   Если ввести значения 2 и 2.36666, то строка вывода
будет иметь вид:
90                                                Гл а в а 2



Целое = 2???, Вещественное = 2.37?
   Если ввести значения –1999 и 12.9999, то строка вы-
вода будет иметь вид:
Целое = –1999, Вещественное = 13.00
   Пример 2.15. Приведем пример использования фор-
матированного ввода-вывода.
   В комментариях к строкам приведен вид выводимого
данного и пояснения.
#include <stdio.h>
#define STR "Программа" // для иллюстрации вывода строк
void main (void)
{
// вывод целого числа 336
   printf("%d\n", 336); // 336
   printf("%2d\n", 336); // 336 формат 2d игнорируется
   printf("%8d\n", 336); // ?????336 ширина поля 8
   printf("%-8d\n", 336); // 336????? прижато влево
   printf("\n");		        // пропуск строки при выводе

// вывод вещественного числа 12.345
   printf("%f\n",      12.345); // 12.345000
   printf("%e\n",      12.345); // 1.234500е+01
   printf("%10.1f\n", 12.345); // ??????12.3
   printf("%–12.1f\n", 12.345); // 12.3??????
   printf("\n");

// вывод строки символов по формату s
   printf("%s\n",      STR); // Программа
   printf("%12s\n",    STR); // ???Программа
   printf("%12.5s\n", STR);  // ???????Прогр
   printf("%-12.5s\n", STR); // Прогр???????
   printf("\n");
}


     2.4. Управляющие конструкции языка C++
    Оператор — это предложение, описывающее одно
действие по обработке данных или действия программы
на очередном шаге ее исполнения.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   91

     2.4.1. Классификация операторов
   Все операторы языка С++ можно разделить на две
группы.
   1. Операторы преобразования данных.
   2. Операторы управления ходом выполнения про-
граммы.
   Это разделение соотносится с определением алгоритма.
   Операторами преобразования данных являются вы-
ражения. Оператора присваивания в языке С++ нет, его
заменяет выражение, в составе которого есть операция
присваивания.
   Примеры операторов изменения данных:
y+4;		                   // выражение
x=y+4;		                 // выражение присваивания
x++;		                   // выражение – оператор
   Операция присваивания правоассоциативна, поэтому
допускается запись цепочек присваиваний, например:
x=y=z=1;                 // каждая переменная будет равна 1
   К операторам преобразования данных можно отнести
оператор обращения к функции (вызов функции). Его
операцией являются круглые скобки, а операндами —
имя функции и список параметров, например:
scanf("%d%f", &a, &b);
printf("a=%d, b=%f", &a, &b);
    При выполнении вызова функции scanf() значения
переменных a, b будут изменены. При выполнении вызо-
ва функции printf() выполняются действия по преобразо-
ванию данных из внутреннего представления в текстовое,
пригодное для вывода на экран.
    Операторы управления предназначены для управле-
ния ходом выполнения программы. Обычно операторы
программы выполняются в том порядке, в котором запи-
саны. Поскольку каждый оператор выполняет одно дей-
ствие по обработке данных, тем самым управляя работой
компьютера, то порядок выполнения выражений называ-
ют потоком управления. Поток управления редко бывает
линейным. Изменить направление потока управления по-
зволяют операторы управления, перечисленные в табли-
це 2.8.
92                                                             Гл а в а 2


                                                       Та блица 2.8
                   Операторы управления C++
                                                           Ключевое
                 Название оператора                          слово
Составной оператор                                    {…}
Условный оператор                                     if
Оператор цикла с проверкой условия до выполнения      while
Оператор цикла с проверкой условия после выполнения   do… while
Оператор цикла типа «прогрессия»                      for
Оператор прерывания                                   break
Оператор продолжения                                  continue
Оператор переключатель                                switch
Оператор перехода                                     goto

   При описании каждого оператора языка С++ будем
придерживаться следующей схемы:
 • назначение;
 • синтаксис;
 • семантика, механизм исполнения;
 • пример;
 • особенности.

     2.4.2. Оператор присваивания
   Назначение. Изменение значения данного в соответ-
ствии с выражением правой части.
   Синтаксис.
Имя_переменной = Выражение;		                     // форма 1
Имя_переменной = (тип) Выражение; 		              // форма 2
   Выполнение. В первую очередь вычисляется выраже-
ние правой части, во вторую вычисленное значение при-
сваивается переменной левой части.
   Примеры:
x=y=0;
x++;
y=sin(2*PI*x);
y+=0.2;
   Особенности. Если в выражении встречаются опе-
ранды разных типов, то при вычислении значения вы-
ражения происходит неявное преобразование типов, как
правило, к большему типу. При несоответствии типа вы-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   93


ражения правой части типу переменной в левой части
происходит приведение типа выражения к типу перемен-
ной, при этом неизбежна потеря данных при приведении
от большего типа к меньшему.
    Приведем пример реализации линейного алгоритма
вычисления высот треугольника, блок-схема которого
приведена в примере 1.1 (глава 1).
    Пример 2.16.
// вычислить высоты треугольника со сторонами a, b, c
#include <stdio.h>
#include <conio.h>
#include <math.h>
void main(void)
{
   double a,b,c;
   printf("Введите стороны треугольника");
   scanf("%lf%lf%lf", &a, &b, &c);
   double p,t;
   // объявить переменные можно там, где они
   // понадобились
   double Ha,Hb,Hc;
   p=0.5*(a+b+c);
   // нет проверки условия существования треугольника
   t=2*sqrt(p*(p-a)*(p-b)*(p-c));
   Ha=t/a;
   Hb=t/b;
   Hc=t/c;
   printf("Значения высот треугольника:\n
	 Ha=%6.2lf,Hb=%6.2lf, Hc=%6.2lf\n",Ha, Hb, Hc);
}

     2.4.3. Составной оператор
   К составным операторам относятся собственно состав-
ные операторы и блоки. В обоих случаях это последова-
тельность операторов, заключенная в фигурные скобки.
Блок отличается тем, что в его состав входят описания
каких-либо объектов программы.
   Блоком является тело любой функции, в том числе
функция main().
94                                                Гл а в а 2



    Назначение. Составной оператор используется для
объединения нескольких операторов в один. Составной
оператор, например, формирует ветвь условного операто-
ра или тело цикла в операторах цикла.
    Пример 2.17.
                                   {// это блок
{// это составной оператор
                                   int n=0;
n++;
                                   n++;
S+=n;
                                   S+=n;
}
                                   }

     2.4.4. Условный оператор if
   В п. 1.2.2 (глава 1) приведены блок-схемы структуры
если — то — иначе с полным и неполным ветвлением.
В языке С++ эта структура реализуется условным опера-
тором if.
   Назначение. Выбор одного из двух возможных путей
исполнения программы в зависимости от условий, сло-
жившихся при выполнении.
   Для проверки условия формулируется некоторое
утверждение, которое может быть истинным или лож-
ным. Это логическое выражение, которое может принять
одно из значений True либо False. В языке С++ они име-
ют форму выражений целого типа, принимая значения
«не 0», что соответствует истине, либо «0», что соответ-
ствует лжи, либо типа bool.
   Синтаксис. Синтаксис условного оператора имеет две
формы.
   Сокращенная форма.
if (Логическое_выражение)
Оператор;
     Здесь «Логическое_выражение» — любое выражение
типа int или bool.
     «Оператор» — это один или несколько операторов,
в общем случае составной оператор. Логическое выраже-
ние записывается в скобках.
    Полная форма.
if(Логическое_выражение)
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +              95


?Оператор1;
else
?Оператор2;
    Здесь «Логическое_выражение» имеет тот же смысл,
что и ранее, а «Оператор1" или «Оператор2" — это, в общем
случае, блок.
    Выполнение.
    1. Вычисляется значение логического выражения.
    2. Если оно не равно 0, выполняется «Оператор1",
а если оно равно 0, выполняется «Оператор2" (или ничего
в первой форме).
    Пример 2.18. Первая форма условного оператора.
    Стоимость товара равна произведению цены на коли-
чество. Если есть скидка, то стоимость уменьшается на
величину discount. Вычислить стоимость.
pay=cost*count;		      // общая формула
if(discount!=0)		      // если есть скидка, то стоимость
			                    // уменьшается
pay=pay–(pay*discount)/100;
// вывод pay в любом случае
printf("Стоимость = %6.2f\n", pay);
    Пример 2.19. Вторая форма условного оператора.
    Оплата труда работника — это произведение количе-
ства отработанных часов на стоимость часа. Если отра-
ботано более 40 ч, то за каждый час работодатель платит
в полтора раза больше.
if(hour<40)
   pay=rate*hour;                                     // обычная оплата,
                                                      // hour < 40
else
   pay=rate*40+(hour–40)*rate*1.5; // повышенная оплата
                                    // hour >= 40
// печать одинакова
printf("К оплате %6.2f рублей.\n", pay);
   Пример 2.20. Использование блоков в составе услов-
ного оператора.
   Если необходимо вывести на экран число оплаченных
часов и значение суммы к оплате, тогда для каждой ветви
нужна своя собственная печать.
96                                                        Гл а в а 2



if(hour<40)
{
   pay=rate*hour;                     // обычная оплата
   printf("Оплачено %d часов, к оплате %6.2f руб.\n", hour, pay);
}
else
{
   pay=rate*40+(hour–40)*rate*1.5; // повышенная оплата
   printf("Оплачено %d часов, %d сверхурочно.\n",
   hour, hour–40);
   printf("К оплате %6.2f руб.\n", pay);
}
   В состав операторов, формирующих ветви условного
оператора, могут входить любые операторы, в том числе
условные. В этом случае говорят о вложенном условном
операторе. Каждая из ветвей, в свою очередь, может со-
держать условный оператор или несколько. Число уров-
ней вложения не ограничено, однако чем их больше, тем
сложнее восприятие текста.
   Пример 2.21. Вычислить значение функции
                      ?x + a, при x < 10;
                      ?
                  y = ?x + b, при 10 ? x ? 20;
                      ??x + c, при x > 20.

    Блок-схема алгоритма решения задачи приведена
в примере 1.2 (глава 1).
void main(void)
{
  float a,b,c;
  float x,y;
  printf("Введите параметры функции");
  scanf("%f%f%f",&a,&b,&c);
  printf("Введите аргумент функции");
  scanf("%f",&x);
  if(x<10)
?? y=x+a;
  else
?? if(x<20)
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   97


??? y=x+b;
?? else
??? y=x+c;
  printf("x=%6.2f,y=%6.2f\n",x,y);
  getch();
}
    Логическое выражение в условном операторе может
быть как угодно сложным. Для записи сложных логиче-
ских выражений используются специальные логические
операции:
    && — логическое «и»;
    || — логическое «или»;
    ! — логическое отрицание «не».
    Например, для обозначения категории «подростко-
вый возраст» нужна условная градация, скажем, от 12 до
17 лет. Если переменная Age обозначает возраст некоего
круга людей, то подростками из них будут только те, для
которых справедливо утверждение Age>=12 && Age<=17.
Логическое выражение будет истинно, только когда оба
условия выполняются одновременно. Соответственно,
если Age<12||Age>17, то человек не подросток (это ребе-
нок, если Age<12, или взрослый человек, если Age>17).
Это логическое выражение будет истинно, когда хотя бы
одно или оба условия выполнены. Для того чтобы проил-
люстрировать применение операции отрицания, запишем
условие «не подросток» инверсией выражения «подрост-
ковый возраст» !(Age>=12 && Age<=17).
    Приоритеты операций приведены ранее в таблице 2.7.
    Наиболее распространены следующие ошибки записи
логических выражений.
    1. Знаки логических операций похожи на знаки пораз-
рядных операций сравнения & (и) и | (или). Выполнение
этих операций происходит различным образом, поэтому не
всегда результат поразрядного сложения равен истинной
дизъюнкции операндов, а результат поразрядного умно-
жения равен истинной конъюнкции (хотя иногда равен).
    2. Знак операции = отличен от знака ==. Знаки опера-
ций = и == похожи внешним образом, но радикально от-
личаются по механизму выполнения.
98                                                 Гл а в а 2



   Каждый программист хотя бы раз допустил ошибку
вида:
if(Key=27)       // ошибка здесь
{
   printf("Завершение работы.\n");
   return;
}
else
   printf("Продолжение работы.\n");
    Здесь по смыслу алгоритма значение переменной Key
определяет момент завершения или продолжения работы
программы. Однако в этом тексте, независимо от перво-
начального значения Key, будет выполнено присваивание
Key=27, и значение выражения станет равно 1. Значит,
результат проверки значения выражения равен 1, всег-
да выполняется первая ветка, и программа благополучно
всегда завершит свою работу.
    3. Пропуск знаков логических операций. Математи-
ческая запись 3 < x < 6 должна быть записана на языке
С++ обязательно с использованием логической операции
&&: if(–3<x && x<6), хотя компилятор согласится с текстом
вида if(–3 < x < 6).
    При вычислении выражения –3 < x < 6 сначала вычис-
ляется (–3 < x). Это выражение имеет логическое значение
(0 или 1). Затем полученное логическое значение участву-
ет в вычислении выражения (–3 < x) < 6, результат которо-
го всегда истинен.
    4. Операции сравнения для вещественных типов. Опе-
рации сравнения могут применяться к данным любого из
базовых типов С++. Для данных целого и символьного ти-
пов точное соответствие возможно. Для данных веществен-
ных типов всегда существует ошибка представления дан-
ных, которая может накапливаться. Поэтому проверки на
точное равенство вещественных чисел следует избегать.
    Пример 2.22.
#include <stdio.h>
void main(void)
{
  float x=1./3.;
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +                        99


  float y;
  y=x+x+x;
  if(y==3*x)
?? printf("Равны\n");
  else
?? printf("Не равны\n");
}
     Казалось бы, y должен быть равен 3*х, но в силу ошиб-
ки представления данных вещественного типа этого не
произойдет.
   Проверка вещественных чисел выполняется на при-
ближенное равенство с использованием приближенного
значения модуля разности сравниваемых значений:
(fabs(y–3*x)<0.001);
// вычисление, например с точностью 0.001
    Примеры записи логических выражений приведены
в таблице 2.9.
                                                                          Та блица 2.9
                    Примеры записи логических выражений
 №                                      Математическая            Синтаксис записи
               Условие
 п/п                                     формулировка                 на С++
       Число Х принад-             –2 <= x <= +2                –2.<=x && x<=2.
  1    лежит отрезку [–2,          Или |x| <= 2                 или fabs(x)<=2.
       +2]
       Число Х принад-
       лежит отрезку [–2,          –4 <= x <= –2;               –4.<=x && x<=2.
  2    –4] или отрезку             +2 <= x <= + 4               || 2.<=x && x<=4.
       [+2, +4]
       Точка с коорди-             ?x > 0
       натами (x, y) на-           ?
  3                                                             x>0 && y>0
       ходится в первой            ?y > 0
       четверти
       Точка с координа-           ?x > 0 ?x < 0
  4    тами (x, y) нахо-           ?     ??                     x>0&&y>0||x<0&&y<0
       дится в первой или          ?y > 0 ?y < 0
       в третьей четверти
       Числа a, b, c одно-         Каждое число делится         а%2==0&&b%2==0&&
  5    временно четны              на 2 без остатка             c%2==0
                                   Одно или два, или все
       Хотя бы одно из                                          а%2==0||b%2==0
  6                                три числа делятся на
       чисел a, b, c четно                                      ||c%2==0
                                   2 без остатка
       Символ является                                          char d; // объявление
  7    знаком препина-                                          d=='.'||d==','
       ния                                                      ||d=='?'||d=='!'
100                                                                 Гл а в а 2


                                                  Пр одолжение та бл. 2.9

№                              Математическая          Синтаксис записи
             Условие
п/п                             формулировка               на С++
       Символ является                              char d; // объявление
 8     буквой латинского                            d>='A'&&d<='Z'||
       алфавита                                     d>='a'&&d<='z'
       Точка с координа- Во второй четверти
       тами (x, y) принад- ?x > ?1
       лежит указанной     ?
       области             ?y < 1
                                                    х>–1&&x<0&&y>0
 9                         В четвертой четверти     &&y<1||x>0&&
                                                    x<1&&y<0&&y>–1
                           ?x < 1
                           ?
                           ?y > ?1


    Точка с коор-          При подстановке           // Значения a, b, x, y
              (x, y)
 10 динатами               в уравнение прямой
    находится выше         y1= a x + b: если y1 > y, известны.
    прямой y = ax + b      то выше, иначе ниже. а*x+b>y


      2.4.5. Оператор цикла while
   В п. 1.2.3 (глава 1) приведены блок-схемы циклических
алгоритмов. Рассмотрим реализацию циклов в языке С++.
   Для реализации цикла с предусловием используется
оператор цикла while.
   Назначение. Организация многократного повторения
фрагмента программы.
   Синтаксис.
while (Логическое_выражение)
{ // Тело цикла;
}
    Здесь «Тело цикла» — один или несколько операторов,
в общем случае составной оператор. «Логическое_выраже-
ние» — это выражение условия завершения цикла.
    Выполнение. Тело цикла выполняется, пока «Логиче-
ское_выражение» имеет значение «истинно» (отлично от
0). Когда «Логическое_выражение» ложно (равно 0), управ-
ление передается оператору, стоящему за циклом.
   Пример 2.23. Найти сумму n чисел натурального ряда
       n
S = ? i. Параметр цикла i ? [1, n], шаг изменения параме-
      i =1
тра ?i = 1. Тело цикла S = S + i.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   101


void main(void)
{
  int n, Sum=0;
  int i;
  printf("\nВведите количество элементов ряда\n");
  scanf("%d", &n);
  i=1;
  while(i<=n)
  {
?? Sum+=i;      // очередное сложение
?? i++;		       // увеличение слагаемого
  }
  printf("Сумма чисел натурального ряда=%d", Sum);
}
   Поскольку значение суммы не зависит от порядка сум-
мирования, то в стиле языка С++ алгоритм запишется так:
i=n;
Sum=0;
while(i)		               // пока i отлично от 0
  Sum+=i––;
   Особенности. Проверка условия происходит до входа
в цикл, поэтому для заведомо ложного выражения тело
цикла не будет выполнено ни разу.

     2.4.6. Оператор цикла do… while
    Оператор цикла do … while используется для реализа-
ции цикла с предусловием, блок-схема которого приведе-
на в п. 1.2.3 (глава 1).
    Назначение. Организация многократного повторения
фрагмента программы.
    Синтаксис.
do
{
// Тело цикла;
}
while(Логическое_выражение);
    Здесь «Тело цикла» — один или несколько операторов,
в общем случае составной оператор. «Логическое_выраже-
ние» — это выражение условия завершения цикла.
102                                                     Гл а в а 2



    Выполнение. Тело цикла (в общем случае блок) вы-
полняется многократно, пока «Логическое_выражение» не
равно 0. Как только выражение станет ложно (т. е. равно
0), цикл заканчивается, управление передается следую-
щему по порядку оператору.
    Пример 2.24. Решим задачу примера 2.23 с использо-
ванием оператора цикла do.
void main(void)
{
  int n, Sum=0;
  int i;
  printf("\nВведите количество элементов ряда \n");
  scanf("%d", &n);
  i=n;
  do
?? Sum+=i––;
  while(i);			                 // пока i отлично от 0
  printf("Сумма чисел натурального ряда=%d", Sum);
}
    Особенности. Проверка условия происходит после
выполнения тела цикла. Значит, как бы ни было задано
«Логическое_выражение», оператор тела цикла выполнит-
ся не менее чем один раз.

      2.4.7. Оператор цикла типа прогрессия for
   Назначение. Организация многократного повторения
произвольного фрагмента кода программы. Как правило,
цикл используется, когда число повторений тела цикла
известно заранее и явно есть переменная величина, кото-
рая, изменяясь, составляет прогрессию. Она является па-
раметром цикла. Иногда ее называют счетчик цикла.
   Синтаксис.
for(Выражение1; Выражение2; Выражение3)
  // Тело цикла;
   Здесь параметр цикла составляет прогрессию и явно
присутствует в записи заголовка цикла (так называется
строка for(…)).
   «Выражение1" задает начальное значение параметра
цикла, «Выражение2" задает условие завершения выпол-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   103


нения тела цикла и является логическим, «Выражение3"
задает приращение параметра цикла. «Тело цикла» — это
произвольная последовательность операторов, как прави-
ло, составной оператор. Первое и третье выражения могут
состоять из нескольких операторов, отделенных друг от
друга запятой.
    Блок-схема, реализующая оператор этого типа, при-
ведена в п. 1.2.3 (глава 1).
    Выполнение. Перед входом в цикл, т. е. до перво-
го выполнения тела цикла, однократно выполняется
«Выражение1". Тело цикла выполняется многократно,
пока «Выражение2" (условие) не равно 0. Как только его
значение становится равным 0, управление передает-
ся следующему по порядку оператору. Проверка усло-
вия завершения цикла происходит до выполнения тела
цикла.
    Пример 2.25. Решим задачу примера 2.23 с использо-
ванием цикла for.
void main(void)
{
  int n, Sum=0;
  int i;
  printf("\nВведите количество элементов ряда \n");
  scanf("%d",&n);
  for(i=1; i<=n; i++)
?? Sum+=i;
  printf("Сумма членов натурального ряда=%d", Sum);
}
   Особенности.
   1. Управляющая переменная цикла for не обязательно
целого типа, она может быть вещественной или символь-
ной.
   Приведем пример цикла, вычисляющего сумму геоме-
трической прогрессии.
   Пример 2.26. Вычислить сумму геометрической про-
                                          2
грессии по формуле S = ?1,1 ? i, где i изменяется по зако-
                                        i =1
ну i = i ? 1,1.
void main(void)
104                                                Гл а в а 2



{
  float Sum=1, i;
  for(i=1.; i<=2.; i*=1.1)
?? Sum+=i;
  printf("\nСумма геометрической прогрессии %f", Sum);
}
    2. Любое из трех выражений, стоящих в заголовке
цикла, любые два или все могут отсутствовать, но разде-
ляющие их символы «;» опускать нельзя. Если «Выраже-
ние2" отсутствует, то считается, что оно истинно, и цикл
превращается в бесконечный, для выхода из которого не-
обходимы специальные средства. Бессмысленно исполь-
зовать несколько «Выражений2", так как управление ци-
клом выполняется по первому условию.
    3. Оператор цикла for удобен тем, что интегрирует
в заголовке описание всего процесса управления. Телом
цикла является, в общем случае, блок. Поскольку началь-
ных присваиваний и выражений приращения может быть
несколько, весь цикл вместе с телом может быть записан
одной строкой. Например, тот же цикл в стиле языка С++
может выглядеть так:
for(Sum=0,i=1;i<=n; Sum+=i++);
      Здесь два начальных присваивания, а тело цикла
Sum+=i++ вместе с приращением параметра цикла записа-
но в его заголовке.
    Приведем код программы вычисления факториала
функции с применением циклов while и for. Блок-схема
алгоритма приведена в примере 1.3 (глава 1).
    Пример 2.27. Дано целое положительное число n. Вы-
числить факториал этого числа.
// первый вариант
void main(void)
{
int N;
long int F;
int R;
printf("Введите число\n");
scanf("%d",&N);
F=R=1; // присваивание начальных значений
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   105


while (R<=N)
  {
   F=F*R;
   R++;
  }
printf("Факториал %d равен %ld\n",N,F);
}

// второй вариант
void main(void)
{
   int N;
   long int F;
   int R;
   printf("Введи число\n");
   scanf("%d",&N);
   F=1;			              // начальное значение факториала
   for(R=1; R<=N; R++) // здесь R – параметр цикла
?? F=F*R;
   printf("Факториал %d равен %ld\n",N,F);
}
     При использовании цикла while программист должен
явно указать начальное значение параметра цикла (в про-
грамме это переменная R), а в теле цикла изменить его
значение. При использовании цикла for эти действия вы-
полняются в заголовке цикла.
   Пример 2.28. Пусть а0 = 1; аk = k ? ak–1 + 1/k, k = 1, 2, …
Дано натуральное число n. Получить аn.
   В задаче требуется определить член последователь-
ности. Особенности этой задачи и блок-схема ее решения
приведены в примере 1.4 (глава 1).
void main(void)
{
// вычисление элемента последовательности
   int n;
   int k;
   double a=1.;		        // инициализация данного
   printf("Введите число элементов последовательности.\n");
   scanf("%d",&n);
106                                                    Гл а в а 2



  for(k=1; k<=n; k++)
?? a=k*a+1./(double)k; // вещественное 1., целое k
  printf("%d-элемент последовательности равен
%8.4lf",n,a);
}
   Пример 2.29. Даны натуральное число n, действитель-
ное число х. Вычислить сумму:
                              n   i
                           ? xi! .
                           i =1

    Прежде чем написать программный код для решения
этой задачи, необходимо вывести рекуррентное соотно-
шение, которое определит способ вычисления слагаемого
на каждом шаге выполнения цикла. Способ вывода этой
зависимости и блок-схема алгоритма приведены в приме-
ре 1.5 (глава 1).
void main(void)
{
  int i,n;
  double c,x,S;
  printf("Введите число слагаемых.\n");
  scanf("%d",&n);
  printf("Введите x\n");
  scanf("%lf",&x);
  S=0;
  c=1;
  for(i=1; i<=n; i++)
?? {
?? c=c*x/i;		            // неявное приведение типов
?? S+=c;
?? }
  printf("Сумма равна %8.3lf", S);
}
    Пример 2.30. Даны действительные числа x, ? (x ? 0,
? > 0). Вычислить сумму с точностью ?:
                          ?       k
                          ? 2kx? k !
                         k=0
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   107


    Блок-схема алгоритма решения задачи приведена
в примере 1.6 (глава 1). Там же показан вывод рекуррент-
ного соотношения, определяющего вычисление слагаемо-
го на каждом шаге выполнения цикла.
void main(void)
{
  double x,eps;
  double c,S;
  double F;     // или long double, значение может быть
		              // большим.
  int k;
  printf("Введите точность вычислений.\n");
  scanf("%lf",&eps);
  printf("Введите x\n");
  scanf("%lf",&x);
  F=1;
  S=0;
  c=1;
  k=1;
  while(fabs(c/F)>eps) // итерационный цикл
   {
??? S+=c/F;
??? k+=1;
??? c=c*x*0.5;
??? F*=k;
  }
  printf("Сумма равна %lf\n",S);
}

     2.4.8. Правила организации циклических алгоритмов
   Циклические алгоритмы разделяются на две группы.
   1. Арифметический цикл (управляемый счетчи-
ком). Цикл повторяется заранее известное число раз.
Например, спортсмен должен пробежать 10 кругов или
40 км.
   2. Итерационный цикл (управляемый событием).
Обычно число повторений цикла заранее неизвестно. На-
пример, спортсмен должен бежать, пока не устанет, или
пока суммарный путь пробега не составит 42 км.
108                                                 Гл а в а 2



    Программа должна организовать правильное управ-
ление процессом выполнения циклического алгоритма.
Для управления в программе используется некая величи-
на, которая называется «параметр цикла» (управляющая
переменная). Это одна из переменных программы, кото-
рая изменяется в теле цикла, определяет число повторе-
ний цикла и позволяет завершить его работу.
    При организации цикла всегда должны быть пройде-
ны следующие этапы.
    1. Подготовка цикла. Подготовка включает дей-
ствия, которые не относятся непосредственно к логиче-
ской схеме цикла, но позволяют правильно его выпол-
нить. Обычно на этом этапе выполняется присваивание
начальных значений переменным, в том числе параме-
тру цикла.
    2. Точка входа в цикл определяет момент передачи
управления первому оператору тела цикла.
    3. Итерация. Итерацией называется очередное выпол-
нение тела цикла, т. е. фрагмента, который должен быть
повторен многократно. Как правило, включает в себя из-
менение параметра цикла.
    4. Точка проверки условия. Она определяет момент
проверки условия, при котором решается, делать ли но-
вую итерацию или перейти к оператору, стоящему за ци-
клом. В проверке условия явно или нет присутствует па-
раметр цикла.
    5. Выход из цикла определяет передачу управления
оператору, стоящему за циклом.
    Не всегда эти составляющие присутствуют явным об-
разом.
    В п. 2.4.5–2.4.7 (глава 2) описаны три вида операторов
цикла языка C++, которые служат инструментом для ор-
ганизации циклических процессов.
    С помощью каждого из этих операторов можно орга-
низовать циклический алгоритм любого типа. В приме-
ре 2.27 (глава 2) показана реализация вычисления факто-
риала числа с использованием циклов while и for.
    При проектировании цикла необходимо решить две
задачи.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   109


    1. Разработать поток управления. Здесь наиболее
важный шаг — это выбор параметра цикла. Для параме-
тра цикла должно быть известно:
  • условие завершения цикла;
  • начальное значение параметра;
  • способ обновления параметра цикла.
    2. Спланировать действия внутри цикла. Здесь важ-
но решить, что представляет собой отдельная итерация,
и точно определить:
  • способ инициализации повторяющегося процесса;
  • действия, которые входят в него;
  • способ его обновления.
    Пример 2.31. Приведем пример проектирования ци-
клического алгоритма, в котором использованы различ-
ные операторы цикла для решения одной и той же задачи.
    Условие задачи: снаряд выпущен под углом ? к го-
ризонту со скоростью V (рис. 2.3). Требуется определить
высоту и дальность
полета в течение про-
межутка времени от
t =1 с до t = 10 с с ин-
тервалом, равным 1 с.
    Циклом управляет
переменная t, для ко-
торой известен закон                   Рис. 2.3
изменения. Содержа-           Траектория полета снаряда
нием тела цикла явля-
ется вычисление очередного значения высоты и дальности
полета и вывод этих значений на печать. Число повторений
заранее известно и равно 10, значит, можно использовать
цикл арифметического типа. Арифметический цикл мож-
но организовать с применением любого из операторов цик-
ла языка С++, что и показано в полном тексте программы.
#include <stdio.h>
#include <math.h>
#define G 9.8			             // константа тяготения
void main(void)
{
  // переменные, которые являются начальными значениями
110                                                         Гл а в а 2



  float V;			                       // скорость
  int A_Grad;			                    // угол в градусах
  // переменные, участвующие в вычислениях
  float Alpha;			                   // угол в радианах
  float t;			                       // время полета
  float Sy, Sx;			                  // высота и дальность
  printf("Введите скорость и угол в градусах\n");
  scanf("%f%d",&V,&A_Grad);
  Alpha=(float)A_Grad*M_PI/360.;
  // арифметический цикл. Управляющая переменная
t=[1.0; 10.0], ?t=1.
  // 1. Оператор for
  printf("--------------------------------------\n");
  printf("--Время--Высота--Дальность\n");
  // подготовка цикла
  printf("--------------------------------------\n");
  for(t=1.;t<=10.;t+=1.)
  {
?? Sx=V*t*cos(Alpha);
?? Sy=V*t*sin(Alpha)–0.5*G*t*t;
?? printf("%6.2f %6.2f %6.2f\n",t,Sy,Sx);
  }

// 2. Оператор while
printf("--------------------------------------\n");
printf("Время Высота Дальность\n");
printf("--------------------------------------\n");
// подготовка цикла. Начальное значение t=1
t=1.;
while(t<=10.)
{
   Sx=V*t*cos(Alpha);
   Sy=V*t*sin(Alpha)–0.5*G*t*t;
   Printf("%6.2f %6.2f %6.2f\n",t,Sy,Sx);
   t+=1.;
}

// 3. Оператор do
printf("-------------------------------\n");
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   111


printf("--Время--Высота--Дальность\n"); // подготовка цикла
printf("-------------------------------\n");
t=1.;
do
{
  Sx=V*t*cos(Alpha);
  Sy=V*t*sin(Alpha)–0.5*G*t*t;
  Printf("%6.2f %6.2f %6.2f\n",t,Sy,Sx);
  t+=1.;
}
while(t<=10.);
}
   В этом примере код программы приведен в трех вари-
антах, чтобы показать отличия в организации цикличе-
ских алгоритмов при использовании разных операторов
цикла. Решение задачи выявляет одну ее особенность.
Приведем одну из распечаток решения, полученную при
скорости 100 м/с и угле, равном 30°.
-----------------------------------------------------------
Время		           Высота		Дальность
-----------------------------------------------------------
 1.00		?? 20.98		? 96.59
 2.00		?? 32.16		                   193.19
 3.00		?? 33.55		                   289.78
 4.00		?? 25.13		                   386.37
 5.00		??? 6.91		                   482.96
 6.00		? –21.11		                   579.56
 7.00		? –58.93		                   676.15
 8.00		           –106.54           772.74
 9.00		           –163.96           869.33
10.00		           –231.18           965.93
    Как видим, результат решения зависит от входных
данных. Наибольшую дальность полета можно достичь
за время, меньше чем 10 с, как было объявлено в поста-
новке задачи. При этом координата, определяющая вы-
соту, становится отрицательной, как будто снаряд про-
бил землю и продолжает лететь под землей. Этот факт
требует улучшения постановки задачи, а именно нужно
отслеживать траекторию полета, пока снаряд находит-
112                                                   Гл а в а 2



ся в движении, т. е. пока его вертикальная координата
больше нуля.
    Следовательно, от арифметического цикла следует
отказаться и выбрать итерационный, в котором услови-
ем завершения вычислений будет условие «пока снаряд
находится в полете», т. е. его вертикальная координата
больше 0. Итерационный цикл также можно организо-
вать с использованием любого из операторов цикла.
    Приведем основную часть программы, отвечающую за
организацию циклов. Условие завершения цикла
V*t*sin(Alpha)–0.5*G*t*t>0
управляет выполнением циклического алгоритма незави-
симо от используемого оператора цикла посредством па-
раметра цикла t, входящего в запись условия.

// 1. Оператор for
printf("--------------------------------------\n");
printf("Время Высота Дальность\n");
printf("--------------------------------------\n");
for(t=1.;V*t*sin(Alpha)–0.5*G*t*t>0.;t+=1.)
{
   Sx=V*t*cos(Alpha);
   Sy=V*t*sin(Alpha)–0.5*G*t*t;
   printf("%6.2f %6.2f %6.2f\n",t,Sy,Sx);
}

// 2. Оператор while
printf("--------------------------------------\n");
printf("Время Высота Дальность\n");
printf("--------------------------------------\n");
t=1.;
while(V*t*sin(Alpha)–0.5*G*t*t>0.)
{
   Sx=V*t*cos(Alpha);
   Sy=V*t*sin(Alpha)–0.5*G*t*t;
   printf("%6.2f %6.2f %6.2f\n",t,Sy,Sx);
   t+=1.;
}
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   113


// 3. Оператор do
printf("--------------------------------------\n");
printf("Время Высота Дальность\n");
printf("--------------------------------------\n");
t=1.;
do
{
   Sx=V*t*cos(Alpha);
   Sy=V*t*sin(Alpha)–0.5*G*t*t;
   printf("%6.2f %6.2f %6.2f\n",t,Sy,Sx);
   t+=1.;
}
while(V*t*sin(Alpha)–0.5*G*t*t>0.);
   При выполнении этой программы процесс заверша-
ется по событию, число строк результирующей таблицы
зависит от входных данных, и при тех же начальных зна-
чениях распечатка будет такой:
-----------------------------------------------------------
Время		           Высота		Дальность
-----------------------------------------------------------
1.00		            20.98		? 96.59
2.00		            32.16		           193.19
3.00		            33.55		           289.78
4.00		            25.13		           386.37
5.00		? 6.91		                      482.96
   Пример 2.32. Изменим постановку задачи, чтобы по-
лучить чисто итерационный процесс. Например, пусть
требуется определить время полета и его дальность при
заданных начальных значениях скорости и угла. В этой
постановке задачи итоговыми значениями являются t
и Sx, но для проверки условия завершения нужно вычис-
лять значение вертикальной координаты. Переменная Sy
не нужна, так как формула проверки условия записана
в виде логического выражения. Вывод заголовка не вхо-
дит в подготовку цикла, а вывод на печать вынесен за тело
цикла.
// 1. Оператор for
for(t=1.;V*t*sin(Alpha)–0.5*G*t*t>0.;t+=1.)
   Sx=V*t*cos(Alpha);
114                                               Гл а в а 2



printf("--Время--Дальность\n");
printf("%6.2f %6.2f \n",t,Sx);

// 2. Оператор while
t=1.;
while(V*t*sin(Alpha)–0.5*G*t*t>0.)
{
   Sx=V*t*cos(Alpha);
   t+=1.;
}
printf("--Время--Дальность\n");
printf("%6.2f %6.2f \n",t,Sx);

// 3. Оператор do
t=1.;
do
{
   Sx=V*t*cos(Alpha);
   t+=1.;
}
while(V*t*sin(Alpha)–0.5*G*t*t>0.);
printf("--Время--Дальность\n");
printf("%6.2f %6.2f \n",t,Sx);

    Еще более интересной задачей является задача опреде-
ления попадания в цель. Если известны координата цели
и ее размер, то после выполнения цикла значение Sx мож-
но сравнить с координатой цели. Например, пусть коор-
дината центра мишени Sm, а ее линейный размер L, тогда
условие попадания в цель запишется:
if(Sx<Sm+0.5*L&&Sx>Sm–0.5*L)
   printf("Цель поражена\n");
else
   if(Sx<Sm–0.5*L)
?? printf("Недолет\n");
   else
?? printf("Перелет\n");
   Надо заметить, что и в последнем случае задача ре-
шена некорректно. Значение времени t выбрано дискрет-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   115


ным, и изменение t равно 1 с. Следовательно, точность
вычисления неизвестна, но весьма невелика.
    Еще более интересной задачей является задача подбо-
ра входных данных t и V таким образом, чтобы обеспечить
попадание в цель. Это задача моделирования, имеющая
более сложное решение.

     2.4.9. Оператор прерывания break для циклов do,
            while, for

   Назначение. Прекращение выполнения цикла с пере-
дачей управления следующему за циклом оператору.
   Синтаксис.
break;
   Выполнение. Оператор break осуществляет выход из
тела цикла к оператору, следующему по порядку за ци-
клом. Используется для прерывания при организации
бесконечных циклов, позволяя корректно завершить ал-
горитм.
   Пример 2.33. Найти сумму арифметической прогрес-
сии всех чисел натурального ряда, которая не превышает
некоторого наперед заданного значения, например, n.
void main(void)
{
  int n, Sum=0, i;		           // i — числа натурального
ряда
  printf("\nВведите наибольшее значение\n");
  scanf("%d", &n);
  for(i=1;;i++) 		     // бесконечный цикл
  {			                 // суммирует числа i
?? Sum+=i;
?? if(Sum>n) 		        // условие завершения
??? break;		           // прерывание цикла
  }
  printf("Количество элементов, включенных в сумму
%d\n",i);
}
     Особенности. В случае вложения циклов оператор
break прерывает только непосредственно охватывающий
цикл.
116                                                  Гл а в а 2


      2.4.10. Оператор продолжения continue для циклов do,
            while, for

   Назначение. Переход к следующей итерации тела
цикла без прерывания выполнения цикла. Противополо-
жен break.
   Синтаксис.
continue;
    Выполнение. В любой точке цикла continue прервет
текущую итерацию и перейдет к проверке условия завер-
шения цикла.
    Пример 2.34. Найти сумму дробей вида 1/х, если
x ? [–1; +1], шаг изменения ?x = 0,1. При вычислении
         1    1            1 1 1           1
суммы      +      + ... +    + +    + ... + точка х = 0 яв-
         ?1 ?0,9          0,1 0 0,1        1
ляется особой точкой, в которой знаменатель дроби равен
0, и, следовательно, значение слагаемого не определено.
Можно организовать два цикла сложения с управлением
по x ? [ –1; –0,9] и x ? [0,1; +1], а можно в одном цикле
предусмотреть особую точку и не вычислять очередное
слагаемое.
void main(void)
{
  float Sum=0, x;
  for(x=–1;x<=1.05; x+=0.1)
  {
?? if(fabs(x)<0.0001)
??? continue; // если в знаменателе 0
?? Sum+=1/x;
  }
  printf("Сумма = %8.2f\n", Sum);
}

      2.4.11. Оператор выбора switch
    Назначение. Организация множественного ветвле-
ния, когда при выполнении алгоритма возможна переда-
ча управления на несколько ветвей в зависимости от усло-
вий, сложившихся при выполнении программы.
    Синтаксис.
switch (Выражение)
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   117


{
  case // Значение1:
  {
?? // Оператор_1;
?? break;
  }
  case // Значение2:
  {
?? // Оператор_2;
?? break;
  }
  // и так далее
  case // ЗначениеN:
  {
?? // Оператор_N;
?? break;
  }
  default:
  {
?? // Оператор_N+1;
  }
}
    Слово switch — это название оператора. Здесь «Выра-
жение» — это целочисленное или символьное выражение,
которое может принять одно из нескольких прогнозируе-
мых значений. Каждая метка case связана с константой,
в тексте они названы «Значение_НОМЕР». Все значения
констант должны быть различны. Слово default также обо-
значает метку.
    Выполнение. Вначале вычисляется значение выраже-
ния, затем вычисленное значение последовательно срав-
нивается с каждой константой «Значение_НОМЕР». При
первом же совпадении выполняются операторы, помечен-
ные данной меткой. Обычно это составной оператор, ко-
торый завершается оператором прерывания break, return
или exit(), как показано в описании синтаксиса. В случае
использования оператора break происходит прерывание
с выходом из switch к следующему по порядку оператору.
Если в составном операторе нет оператора прерывания, то
118                                                 Гл а в а 2



после выполнения операторов, найденных по совпадению
значения, выполняются операторы всех последующих
вариантов по порядку до тех пор, пока не будет встречен
оператор прерывания или не закончится оператор выбо-
ра. Операторы, стоящие за меткой default, выполняются
тогда, когда значение выражения не совпало ни с одним
значением константы «Значение_НОМЕР». Метка default
может отсутствовать.
    Пример 2.35. Для управления используется символь-
ное значение знака операции. При вычислении перемен-
ной S, если sign='+', то значение x прибавляется к S, если
sign='–', вычитается. Если переменная sign отлична от
символов операций '+' или '–', то S=x.
сhar sign;
// здесь sign каким-то образом получает значение
S=0;
switch(sign)
{
   case '+':
   {
?? S+=x;
?? break;
   }
   case '–':
   {
?? S–=x;
?? break;
   }
   default:
?? S=x;
}
     Особенности. Оператор switch способен работать как
переключатель только в том случае, если в каждой вет-
ви case есть оператор прерывания break (или другие, на-
пример, return). В случае использования оператора break
управление из switch передается к следующему по поряд-
ку оператору. Если в ветви case нет оператора прерыва-
ния, то управление передается на следующую ветку case,
и выполняются операторы всех последующих вариантов
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   119


по порядку до тех пор, пока не будет встречен оператор
прерывания или не закончится оператор выбора.
   Пример 2.36. Найти сумму N слагаемых вида
S = sin(x) + cos(x) + sin(x) + cos(x) + ...
      Приведем фрагмент программы, решающий эту зада-
чу.
for(n=1,S=0; n<=N; n++)
{
  switch(n%2==0)
  {
?? case 0:
?? { S+=sin(x); break; }
?? case 1:
?? { S+=cos(x); break; }
  }
}
   Пример 2.37. Если в примере 2.36 убрать оператор
прерывания, то будет найдена сумма N слагаемых вида
    S = cos(x) + sin(x) + cos(x) + cos(x) + sin(x) + cos(x)...
for(n=1,S=0;n<=N;n++)
{
  switch(n%2==0)
  {
?? case 0:
??? S+=sin(x); // при n=2, 4 и т.д. S=S+sin(x)+cos(x)
?? case 1:
??? S+=cos(x); // при n=1, 3 и т.д. S=S+cos(x)
  }
}


      2.5. Механизм функций языка C++
   Язык С++ является процедурно-ориентированным
языком, и это означает, что принципы программирова-
ния C++ основаны на понятии функции.
   Как правило, прикладная программа на С++ содер-
жит несколько файлов кода, где каждый файл — это со-
120                                                  Гл а в а 2



вокупность функций. Функции объединяются в модули,
модули — в проект. В состав языка входят также библи-
отеки стандартных функций, которые содержат функ-
ции обработки данных, например, библиотека <math.h>
содержит математические функции и константы, библи-
отека <stdio.h> — функции обмена с внешними устрой-
ствами.

      2.5.1. Введение в модульное программирование
    Модуль — отдельный файл, в котором группируются
функции и связанные с ними данные. Модуль решает не-
которую задачу обработки данных.
    Для начинающих программистов рекомендуется ис-
пользование модульного стиля программирования, до-
стоинства которого очевидны.
    1. Алгоритмы отделены от данных. Как правило, дан-
ные имеют структуру, определенную логикой приклад-
ной задачи. Алгоритмы обработки данных определяются
составом и структурой данных.
    2. Высокая степень абстрагирования проекта. Дости-
гается при использовании функциональной декомпози-
ции.
    3. Модули кодируются и отлаживаются отдельно друг
от друга. Чем более они независимы, тем легче процесс
отладки. Функции, входящие в состав каждого модуля,
представляют его интерфейс. Для использования модуля
достаточно знать только его интерфейс, не вдаваясь в под-
робности реализации.
    Функциональная декомпозиция — это метод разработ-
ки программ, при котором задача разбивается на ряд лег-
ко решаемых подзадач, решения которых в совокупном
виде дают решение исходной задачи в целом.
    Проектирование приложения строится от абстрактно-
го описания основной задачи — это высший уровень аб-
стракции. Основная задача может быть разбита на ряд бо-
лее простых подзадач — это второй уровень абстракции.
Каждая из подзадач, в свою очередь, разбивается на ряд
еще более простых. Процесс детализации заканчивается,
когда очередная подзадача не может быть больше разде-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   121


лена на более простые составляющие или когда решение
очередной задачи становится очевидным.
    В процессе детализации создается иерархическое де-
рево решения задачи, где каждый уровень дерева являет-
ся решением более детализированной задачи, чем пред-
шествующий уровень.
    Каждый блок представляет собой программный мо-
дуль. Каждый модуль — это законченный алгоритм ре-
шения некоторой конкретной задачи.
    Процесс кодирования выполняется снизу вверх, от на-
писания и полной отладки кода небольших подзадач с их
последующей сборкой на верхнем уровне, при этом каж-
дый модуль безошибочно решает одну задачу. Объем за-
дачи нижнего уровня достаточно небольшой — одна или
две страницы кода (не более 50 строк).
    Приведем пример применения метода функциональ-
ной декомпозиции к решению задачи, поставленной не-
формально.
    Пример 2.38. Жители Средиземья организовали кур-
сы информатики. Список дисциплин, по которым про-
водятся курсы, пока содержит три дисциплины: «При-
кладные пакеты Office», «Офисное программирование» и
«Защита информации», но в дальнейшем предполагается
его изменять и расширять. Занятия ведут приглашенные
преподаватели и специалисты. Количество часов по каж-
дой дисциплине определено. Для слушателей определена
оплата одного курса, а для преподавателей, в зависимо-
сти от квалификации, — оплата одного часа занятий. По
окончании курсов всем выдаются сертификаты. Лучшим
слушателям вручаются похвальные листы.
    Статическая модель приложения моделирует струк-
туры данных, которые предназначены для хранения всей
информации, связанной с задачей. Выделим все сущно-
сти, данные о которых необходимо хранить:
  • курсы (дисциплины);
  • слушатели;
  • преподаватели;
  • аудитории;
  • оплата и т. д.
122                                                Гл а в а 2



    Для хранения данных используются таблицы, сохра-
няющие полные данные о сущностях информационных
процессов.
    Динамическая модель поддерживает сценарий рабо-
ты:
  • кто-то организует занятия, проводит рекламу и обе-
    спечивает материальную базу;
  • кто-то отвечает за дидактическую наполненность кур-
    сов;
  • слушатели записываются на курсы, этот процесс за-
    нимает определенное время;
  • по мере комплектации групп приглашается препода-
    ватель и начинаются занятия;
  • для проведения занятий составляется расписание;
  • параллельно или последовательно взимается плата за
    обучение, по окончании курса оплачивается труд пре-
    подавателя;
  • по окончании курса подводятся итоги, выдаются сер-
    тификаты.
    Функциональную декомпозицию задачи можно вы-
полнить в два этапа. На первом этапе изобразим модуль-
ную структуру информационной системы (ИС), определив
потоки данных для всех участников задачи (рис. 2.4).
    В состав ИС входят следующие модули (блоки).
    1. Модуль «Слушатели» управляет информацией
о слушателях курсов.
    2. Модуль «Преподаватели» управляет информацией
о приглашенных преподавателях.




                          Рис. 2.4
           Первый уровень модульной структуры ИС
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   123


   3. Модуль «Бухгалтер» управляет информацией о де-
нежных потоках.
   4. Модуль «Методист» управляет информацией о со-
ставе курсов и их дидактическом содержании, а также
может управлять расписанием.
   5. Модуль «Администратор» имеет доступ к функцио-
нальности отдельных модулей ИС.
   На примере модуля «Слушатели» проведем функцио-
нальную декомпозицию. Логика задачи требует реализа-
ции следующих функций (рис. 2.5).




                                   Рис. 2.5
                       Декомпозиция модуля «Слушатели»


    Обычные операции добавления, удаления, редактиро-
вания позволяют вносить изменения в таблицы данных
о слушателях курсов.
    Функция «Оформить сертификат» рассчитывает ко-
личество часов, проверяет выполнение контрольных ме-
роприятий, вносит данные в итоговый документ.
    Функция «Сведения об оплате» контролирует оплату
курса слушателем.
    Кроме того, модуль должен иметь функции поиска
информации о слушателе по многим критериям: по фами-
лии, по успеваемости, по посещаемости, по оплате, и др.
    Подобным образом выполняется декомпозиция для
всех модулей ИС.
    Так, в модуле «Преподаватели» должны быть реали-
зованы функции: добавить, редактировать, вывести ин-
формацию, рассчитать количество проведенных часов,
рассчитать сумму к оплате, а также многие функции по-
иска по различными критериям.
    Обратим внимание на то, что различные модули ИС
могут иметь сходную функциональность, например,
функции поиска одинаковы в нескольких модулях.
124                                              Гл а в а 2



   Среди функций модулей можно увидеть типичные
алгоритмы обработки данных: добавление, удаление, по-
иск, суммирование, сортировка и др.

      2.5.2. Назначение и виды функций
    Функция — это самостоятельный именованный алго-
ритм решения некоторой законченной задачи.
    Фактически, функция является одним из конструируе-
мых пользователем типов данных, и как объект программы:
  • имеет имя;
  • имеет тип;
  • может иметь параметры (аргументы функции).
    Назначение функций можно рассматривать двояко.
Во-первых, утилитарное назначение, при котором функ-
ция используется только для того, чтобы сократить код
программы. Тогда в виде функции записывается выраже-
ние, которое повторяется в тексте программы несколько
раз. Во-вторых, как требуют принципы модульного под-
хода, использование функций позволяет получать хоро-
шо структурированные программы.
    Язык С++ имеет библиотеки стандартных функций.
Библиотечные функции С++ хранятся в компилирован-
ном виде и присоединяются на этапе сборки. Объявления
библиотечных функций содержатся в заголовочных фай-
лах с именами <имя.h>. Чтобы объявление стало доступно
программе, в тексте программы записывается директива
препроцессора #include <имя.h>. При этом текст заголо-
вочного файла <имя.h>, в котором есть объявление функ-
ции, включается в код программы на этапе препроцессор-
ной обработки. В этом смысле объявление функции — это
аналог объявлению переменных. Подробное описание всех
библиотек языка С++ можно найти в справочной системе.
    Пользователь также может определять собственные
функции и объединять их в библиотеки.

                Создание простой функции
   Любую функцию следует описать. Описание функции
вводит в употребление собственно функцию и содержит
абстрактное описание внешних данных функции и испол-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   125


няемого ею алгоритма. В языке С++ все функции описы-
ваются на одном уровне, вложений не допускается.
    Структура описания простой функции не отличается
от структуры функции main() и в общем виде такова:
Тип_функции Имя_функции
(Тип_параметров Имена_параметров)
{
// описания локальных переменных;
// описание алгоритма;
return возвращаемое_значение;
// отсутствует, если функция типа void
}
    Отдельные составляющие могут быть опущены, кро-
ме имени и блока тела функции. Первая строка описания
функции называется заголовком функции, в ней указаны
все внешние характеристики функции.
    «Тип функции» — это тип возвращаемого функцией
значения или void для функций, которые не возвращают
значения. Типом функции может быть имя базового типа
или указатель.
    «Имя функции» — это имя main для главной функции
программы или любое, не совпадающее с ключевыми сло-
вами и именами других объектов программы.
    «Имена_параметров» — это формальные параметры
функции: перечисленные через запятую имена аргу-
ментов функции вместе с их типами. Как правило, это
входные данные для функции, т. е. те, которые функция
получает извне. Они могут быть и результатом работы
функции, но об этом позже. В списке параметров указы-
вается void, если параметров нет. Пустой список параме-
тров означает, что список параметров может быть произ-
вольной длины.
    Пример описания простой функции.
// функция возведения в квадрат
// описана перед функцией main()
float sqr(float x)		  // тип, имя, один параметр
{
   return x*x;		      // сразу возвращает значение
}
126                                                  Гл а в а 2



// теперь функция main() может к ней обратиться
void main(void)
{
   float a, b;
   a=2;
   b=sqr(a);
   printf("\n%f", b);  // здесь а — фактический параметр
}

               Замечания о типе функции
    Поскольку функция возвращает значение, она обла-
дает типом. В этом смысле функция рассматривается как
данное, тип которого конструируется пользователем. Дан-
ное должно иметь значение. Для функции значением явля-
ется значение выражения, записанного в операторе return:
  • если возвращается простой объект, то тип функции —
    какой-нибудь базовый тип;
  • если возвращается объект сложного конструируемо-
    го типа (массив, структура и подобные), то тип функ-
    ции — это указатель (адрес) объекта;
  • если функция не возвращает значения, ее тип void и в
    теле функции может не быть оператора return;
  • если тип вообще не указан, это не ошибка, тип функ-
    ции по умолчанию целый (int).
    Если главная функция программы main начинается
void main (void), то это означает, что функция не возвраща-
ет значения и не имеет параметров.
    Если заголовок функции main(), то это означает, что
тип функции int, а число параметров произвольно. В этом
случае в теле main() должен быть оператор return, возвра-
щающий значение функции в окружающую среду, напри-
мер, return 1; или return 0;.
    Если функция main() имеет параметры, то они переда-
ются как параметры командной строки при вызове про-
граммы.
    Тело любой функции содержит:
  • описания локальных переменных;
  • описание алгоритма;
  • возврат в точку вызова по оператору return.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   127


   Описания объектов в теле функции используются,
чтобы объявить локальные переменные функции — те,
которыми функция пользуется для решения своих част-
ных задач. Областью действия локальных переменных
является тело функции.
   Описание алгоритма не представляет особенностей.
Это должен быть общий алгоритм решения некоторой
самостоятельной задачи. Он замкнут в себе, абстрактен.
Единственное, что связывает его с внешним миром, это
входные данные, приходящие извне, и результат работы
алгоритма, который он должен передать в вызывающую
функцию (вернуть во внешний мир).
   Возврат из функции в точку вызова выполняет опера-
тор return, который передает управление в вызывающую
программу и возвращает одно значение. Может иметь две
формы:
return выражение; // выход из функции с передачей значения
return;           // выход из функции без передачи значения
    Таким образом, возвращаемое значение может быть
только одно. На самом деле это не так, далее мы рассмо-
трим механизм указателей, который позволит решать за-
дачи передачи данных.
    Оператор return в тексте функции может быть не один,
если алгоритм функции требует, чтобы вариантов выхода
из нее было несколько.

                             Обращение к функции
   Под обращением к функции понимается реальное
выполнение ее алгоритма, каждый раз с различными
входными данными. Выполняется из любой другой
функции программы с использованием механизма вы-
зова функции через операцию обращения. Обращение
к функции зависит от типа функции и может иметь две
формы.
   1. Первая форма обращения — оператор-выражение.
   Используется для функций, возвращающих значение.
Значение функции — это одно значение базового типа или
указатель, которое может быть использовано в выраже-
ниях или печати в виде обращения к функции.
128                                                   Гл а в а 2



      Синтаксис оператора-выражения:
имя_функции (фактические параметры)
   Это обращение можно использовать везде, где значе-
ние функции должно быть вычислено, например, в выра-
жении присваивания:
переменная = имя_функции(фактические параметры);
      в списке вывода при печати:
printf("форматная_строка", имя_функции(фактические_
параметры));
   Покажем на примере обращения к библиотечной
функции sin().
y=sin(x);               // значение функции вычислено
                        // и присвоено
printf("%6.2f",sin(x)); // значение функции напечатано
sin(x);                 // значение функции вычислено, но
                        // что происходит с вычисленным
                        // значением?
    2. Вторая форма обращения — оператор-функция.
    Если функция не возвращает значения (функция типа
void), то обращение к ней выглядит как обычный опера-
тор программы и имеет специальное название «оператор-
функция», синтаксис которого:
имя_функции (фактические параметры);
    Внешне оператор-функция выглядит так же, как
обычный оператор программы. Например, обращение
к библиотечной функции printf():
printf("%d, %d",a, b);

      Формальные и фактические параметры функции
    В описании функции ее внешние данные названы фор-
мальными параметрами. Это название подчеркивает, что
данные описания формальны, абстрактны, не участвуют
в реальных действиях, а только описывают взаимосвязь
данных в теле функции. Формальные параметры функ-
ции — это всегда имена переменных. В заголовке функ-
ции они объявляются, поэтому и должны быть указаны
вместе с типом.
    При обращении к функции ей передаются фактиче-
ские параметры. Это параметры, значения которых из-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   129


вестны на момент обращения к функции, и с которыми
функция отрабатывает очередной вызов. Фактические
параметры подставляются на место формальных при
каждом обращении к функции. Они могут быть в общем
случае константами, переменными, или выражениями.
   Тип параметров, их количество и порядок следования
называются совместно «сигнатура параметров». Есть
непреложное правило C++: в описании функции и в обра-
щении сигнатуры параметры должны строго совпадать.
Это означает, что формальные и фактические параметры
должны соответствовать друг другу по количеству, типу
и порядку следования.
   Пример 2.39.
   Пример иллюстрирует разные варианты обращения
к функции, возвращающей среднее арифметическое зна-
чение трех чисел.
float Avg(float a, float b, float c)
{
   float S;		                // локальная переменная
   S=(a+b+c)/3.;
   return S;		               // тип совпадает с типом функции
}
void main(void)
{
   float x1=2.5, x2=7, x3=3.5;
   float y;
   // фактические параметры – переменные
   y=Avg(x1, x2, x3);
   // обращение в присваивании
   printf("x1=%f, x2=%f, x3=%f y=%f\n", x1, x2, x3, y);
   // фактические параметры – константы вещественного типа
   y=Avg(2., 4., 7.);
   printf("x1=%f, x2=%f, x3=%f y=%f\n", 2., 4., 7., y);
   // фактические параметры – выражения
   y=Avg(x1*2., x2+4., sin(PI/2.));
   printf("x1=%f,x2=%f,x3=%f,y=%f\n",2*x1,x2+4.,sin(PI/2.),y);
   // обращение в функции вывода, фактические параметры
   // произвольные, то есть константы, переменные,
   // выражения
130                                                  Гл а в а 2



    printf("x1=%f,x2=%f,x3=%f,y=%f\n",
    2.,x2,x3+0.7,Avg(2.,x3+0.7));
    // оператор-обращение может входить в другие
    // выражения
    y=(Avg(0.5, 1.7, 2.9)+Avg(x1,x1+2,x1+2.))*0.5;
    printf("y=%f\n",y);
}

      2.5.3. Описание и объявление функции.
             Прототип функции

   С точки зрения структуры программы, в C++ все
функции описываются на одном уровне. Поясним разли-
чие в терминах описание и объявление.
   Описание функции предоставляет программисту всю
информацию о ней, как внешнюю (тип, имя, сигнатура
параметров), так и внутреннюю (тонкости реализации ал-
горитма). Если рассматривать функцию как данное кон-
струируемого типа, то описание функции как раз и кон-
струирует данный тип с указанным именем.
   Объявление функции предоставляет только внешнюю
(интерфейсную часть), для которой важно только умение
правильно использовать функцию, т. е. обратиться к ней.
Заголовок (первая строка описания) функции как раз
и предоставляет такую информацию.
   Любой объект программы должен быть объявлен пе-
ред первым его использованием. Это непреложное прави-
ло относится и к функциям. «Объявление» или «описа-
ние» функции в программе должно появиться до первого
обращения к ней, и здесь возможны варианты.
   1. Описание функции фактически расположено перед
текстом вызывающей программы. В этом случае описание
функции есть одновременно и ее объявление.
   Пример 2.40.
// функции без параметров,
// описание опережает обращение
void f1(void)    // описание функции f1
{
   printf("Функция 1\n");
}
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   131


void f2(void)    // описание функции f2
{
  printf("Функция 2\n");
}
void main(void) // функции известны до момента обращения
{
  printf("\nГлавная функция main\n");
  f1();		        // обращение к функции f1
  f2();		        // обращение к функции f2
}
    В этом случае описание функций играет роль их объ-
явления.
    2. Описание функции фактически расположено по-
сле текста вызывающей программы. Значит, обращение
к функции появляется перед ее описанием. Чтобы функ-
ция стала известной вызывающей программе, кроме опи-
сания, нужно еще и объявление функции. Объявление
функции (в C++ это еще называется прототип) — это ее
заголовок, за которым стоит знак завершения оператора
«;». Прототип может быть записан в начале программы,
если функция глобальна, или в теле main(), если функция
локализована в main(), или в теле любой функции, где
функция известна локально. Прототип функции — это
аналог описания переменных.
    Пример 2.41.
    Использованы те же самые функции без параметров,
что и в примере 2.40. Прототип объявляет функцию.
void f1(void);    // прототип функции f1
void f2(void);    // прототип функции f2
// обращение опережает описание
void main(void)
{
   printf("\nГлавная функция main\n");
   f1();		        // обращение к функции f1
   f2();		        // обращение к функции f2
}
// описание функций после вызывающей программы
void f1(void)     // описание функции f1
{
132                                               Гл а в а 2



  printf("Функция 1\n");
}
void f2(void)   // описание функции f2
{
  printf("Функция 2\n");
}
   3. Наилучший способ организации проекта, это выне-
сение описаний в отдельные файлы.
   Все описания функций выносятся в отдельный файл,
который называется заголовочным файлом. Он подклю-
чается к любой программе, которая их использует. Это
обычные текстовые файлы, содержанием которых явля-
ется описание собственных функций пользователя, а так-
же констант и других данных, глобальных по отношению
к проекту в целом. Заголовочные файлы, как правило,
имеют расширение .h или .hpp (от head — голова), лег-
ко добавляются к любому проекту, и включаются в про-
граммный код директивой препроцессора
#include "Имя_файла.h".

      2.5.4. Передача параметров в функцию. Изменяемые
             значения параметров

   В языке C++ существуют два способа передачи пара-
метров в функцию.
   1. По значению. До сих пор рассматривался синтаксис
именно этого способа передачи данных. Его механизм —
это создание локальной копии параметра в теле функ-
ции. В таком случае значения фактических параметров
нельзя изменить в результате обращения. Это позволяет
защитить входные данные от нежелательного изменения
функцией.
   2. По ссылке. Изменение механизма передачи данного
в функцию формально выглядит добавлением признака
адресной операции к имени параметра в описании функ-
ции:
Тип_ функции Имя_функции
(Тип_параметра &Имя_параметра)
   Механизм такого способа передачи данных заключа-
ется в том, что функция и вызывающая программа ра-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   133


ботают с адресом объекта в памяти (фактически, с одной
и той же областью данных). Как результат, функция мо-
жет изменить значения фактических параметров. Как
следствие, фактическим параметром, соответствующим
формальному параметру-ссылке, может быть только имя
переменной.
    Пример 2.42. Функция находит площадь и пери-
метр треугольника, заданного длинами сторон. Возвра-
щаемых значений два — площадь и периметр. Эти зна-
чения функция вернет через параметры. Кроме того,
нужна проверка условия существования треугольника.
Это логическое значение функция вернет через опера-
тор return (1, если треугольник существует, и 0, если не
существует).
#include <stdio.h>
#include <math.h>
int Triangle(float a, float b, float c, float &p, float &s)
{
   // функция имеет два варианта выхода
   // параметры a, b, c передаются по значению
   // (только входные данные),
   // параметры p, s, по ссылке
   // (как входные данные, так и результат)
   float pp;			                        // полупериметр
   if(a+b<=c||a+c<=b||b+c<=a) // треугольник не существует
?? return 0;
   else
   { 				                              // треугольник существует
?? p=a+b+с;
?? pp=0.5*p;
?? s=sqrt(pp*(pp–a)*(pp–b)*(pp–c));
?? return 1;
   }
}
    При обращении фактическими параметрами, подстав-
ляемыми на место формальных параметров-значений, мо-
гут быть выражения, а фактическими параметрами, под-
ставляемыми на место формальных параметров-адресов,
могут быть только переменные.
134                                                  Гл а в а 2



void main(void)
{
float A, B, C;		
// длины сторон – фактические параметры
float Perim, Square;
// периметр и площадь – фактические параметры
// пример обращения
printf("Введите длины сторон треугольника\n");
scanf("%f%f%f", &A, &B, &C);
if(Triangle(A, B, C, Perim, Square)==1)
?? printf("Периметр = %6.2f, площадь = %6.2f\n", Perim,
                                                  Square);
   else
?? printf("Треугольник не существует\n");
}
   При обращении к функции происходит следующая
цепочка событий (рекомендуется наблюдать данный про-
цесс в отладчике).
   1. Управление передается в функцию.
   2. Выделяется память для параметров функции, вы-
числяются значения формальных параметров и копиру-
ются в локальную память. Так передаются внешние дан-
ные, необходимые для работы функции.
   3. Создаются локальные переменные функции (те, ко-
торые объявлены в теле функции).
   4. Выполняется алгоритм функции.
   5. По оператору return управление передается в точку
вызова, при этом в вызывающую программу передаются
новые данные (результат функции).
   6. Локальные переменные, в том числе формальные
параметры, умирают, память высвобождается.

      2.5.5. Перегруженные функции
   Согласно правилам описания функций принято, что
имя функции отражает ее внутреннее содержание, так
или иначе сообщает пользователю о том, какой алго-
ритм реализует эта функция. Например, имена мате-
матических функций sin(), sqrt(), fabs() говорят сами за
себя, имена функций ввода-вывода printf(), scanf() под-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +       135


черкивают, что ввод-вывод является форматированным
(суффикс f) и т. д. Вместе с тем список возможных имен,
описывающий абстрактный смысл алгоритма, является
ограниченным.
    Перегрузка функций широко используется в совре-
менных компиляторах C++. Принцип перегрузки за-
ключается в том, что одно имя может реализовать разные
алгоритмы. Это означает, что можно описать несколько
функций с одним и тем же именем. Они должны отли-
чаться друг от друга либо количеством параметров, либо
типом параметров. Использование одного имени в разных
целях называется перегрузкой.
    Возможна перегрузка:
  • по числу параметров;
  • по типу параметров.
    Таким образом, перегруженные функции различают-
ся по сигнатуре параметров.
    Механизм работы перегруженных функций основан
на обработке вызовов, в которых показана сигнатура фак-
тических параметров. Их типы или их количество сооб-
щают компилятору, какой именно функции сопоставить
данный вызов.
    Пример 2.43. Пример перегрузки функции по числу
параметров.
    Пусть требуется функция, которая вернет наибольшее
из своих параметров. Именем функции должно быть аб-
страктное имя, соответствующее смыслу алгоритма, на-
пример, имя max.
    Число параметров может быть различным, так, про-
тотипы функций могут выглядеть:
int max(int, int);		                 // функция получает два параметра
int max(int, int, int);              // функция получает три параметра
   Для каждого алгоритма требуется своя реализация,
поэтому для каждой реализации пишется функция.
int max(int x,int y)
{
   return x>y?x:y;
}
int max(int x,int y,int z)
136                                                    Гл а в а 2



{
    return x>y?(x>z?x:z):(y>z?y:z);
}
   В зависимости от сигнатуры фактических параме-
тров, переданных при вызове, будет вызван и отработает
нужный алгоритм, например:
int Angle1, Angle2, Angle3;
// вызов функции с двумя параметрами
int Angle_max=max(Angle1, Angle2);
// вызов функции с тремя параметрами
Angle_max=max(Angle1, Angle2, Angle3);
   Пример 2.44. Пример перегрузки функции по типу па-
раметров.
   Функцию max() можно перегрузить еще раз, так, что-
бы она находила наибольшее значение из элементов мас-
сива. Тогда имя будет прежнее, а тип параметров совер-
шенно иной. Прототип функции будет таким:
int max(int *,int);		     // функция получает два параметра
   Первый параметр — это указатель на массив, а вто-
рой — число элементов массива. Это будет перегрузкой
функции по типу параметров.
   Реализация алгоритма для массива:
int max(int x[],int n)
{
   int m=x[0];
   for(int i=0;i<n;i++)
?? if(x[i]>m) m=x[i];
??? return m;
}
   При обработке вызова компилятор сопоставит сигна-
туру фактических параметров требуемой реализации ал-
горитма, и безошибочно передаст управление функции,
которая может это сделать.
int a[10];
int Angle_max;
Angle_max=max(Angle1,Angle2); // найдет наибольший угол
int Max_value;
Max_value=max(a, 10);         // найдет наибольший
                              // элемент массива
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   137

     2.6. Локальные и глобальные данные.
     Время жизни и область действия объектов
   В тексте программы термином «объект» называют
переменные, именованные константы, функции, в целом
имена данных различных типов. Объект программного
кода присутствует в тексте своим именем. Каждый объект
должен быть объявлен.
   Область действия объекта — это область программ-
ного кода, в которой объект известен (т. е. действует его
объявление). Если объект объявлен в начале программы,
вне тела всех функций, то он известен везде внутри того
файла, где объявлен.
   Время жизни объекта — это понятие, связанное с об-
ластью действия: период времени в процессе выполнения
программы, когда объект фактически занимает память
(память выделяется при объявлении).
   Локальные (внутренние) объекты объявлены внутри
тела блока. Локальные объекты функции объявлены вну-
три тела функции.
   Область действия локального объекта — блок, в кото-
ром он описан. Описание действует от точки описания до
конца блока.
   Время жизни локального объекта — только время вы-
полнения блока. При входе в блок память выделяется,
при выходе память освобождается.
   Глобальные (внешние) объекты объявлены вне тела
функции на внешнем уровне.
   Область действия глобального объекта — от точки
объявления до конца файла с кодом программы, в кото-
ром объявлен объект.
   Время жизни глобального объекта — время выполне-
ния программы.
   Параметры функций по механизму действия тоже
можно отнести к локальным или глобальным.
   Параметр, передаваемый по ссылке, действует по ме-
ханизму глобального объекта. Это единый объект, так
как функция и вызывающая программа работают с одним
адресом объекта. Это удобное средство для того, чтобы
сделать открытым адресное пространство.
138                                                  Гл а в а 2



   Параметр, передаваемый по значению, действует по
механизму локального объекта. Это объект, который соз-
дается и живет в течение времени работы функции. Это
надежный механизм защиты внешних данных от случай-
ного их изменения функцией.

      2.6.1. Принцип локализации имен
    Этот термин имеет много синонимов, например, про-
странство имен, приоритет имен, принцип сокрытия
имен. Применяется в случае, когда локальное имя какого-
нибудь объекта в теле функции совпадает с именем гло-
бального объекта. Что касается выбора имен, то имя любо-
го объекта в любом блоке уникально, но в разных блоках
имена могут повторяться, неся различную смысловую на-
грузку. Особенно это касается имен рабочих переменных.
    Пример 2.45.
int A=90;
void F(int x)
{
   int A=0; // каким же будет значение А в теле функции?
}
    Принцип локализации имен заключается в том, что
на время действия локальной переменной глобальная пе-
ременная с тем же именем временно прекращает свое су-
ществование. Она возобновляет свое значение при завер-
шении работы функции, как только заканчивается время
жизни локальной переменной.
    Пример 2.46. Чтобы увидеть механизмы локализации
данных и принцип локализации имен, этот пример следу-
ет выполнять в отладчике.
#include <stdio.h>
#include <conio.h>
// глобальные данные программы
int a,n=1;
void f1(void); // объявление функций глобально
void f2(void);
void f3(int);
void main(void)
{
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   139


   int i;      // локальная переменная функции main
   a=10;       // функция main изменяет глобальную
               // переменную
               // все функции имеют одинаковые права на
               // изменение глобального данного
  for(i=1;i<=3;i++)
  {
?? n++;        // main изменяет значение n, нумеруя
               // последовательность вызовов функции f1
  printf("\nMain. Вход № %d", n);
  f1();        // f1 тоже меняет значение n, потому что main
  }            // и f1 имеют одинаковые права на изменение n
  for(i=1;i<=3;i++)
  {
?? a++;        // main изменяет значение переменной a
?? printf("\nMain. Глобальная а=%d",a);
?? f2();       // в функции f2 значение переменной а свое
  }
?	             // как передача данного в функцию защищает
               // его от изменения?
  f3(a);
  printf("\nГлобальное а после обращения к f3=%d",a);
  }

   // f1 печатает номер обращения
   void f1()
   {
   n++;        // функция меняет глобальную переменную n
   printf("\nФункция f1. Вход %d",n);
   }

  // f2 печатает значение локальной переменной
  void f2()
  {
?? int a=90; // а — локальное данное функции f2
?? printf("\nФункция f2. Локальная а=%d", a);
  }

   // f3 печатает значение локальной переменной
140                                                     Гл а в а 2



    void f3(int a) // глобальная переменная передается
    {              // как параметр, защищена от изменения
    a++;           // локальное данное функции f3
    printf("\nФункция f3. Не меняет глобальное а=%d", a);
}

      2.6.2. Классы памяти
    Существуют три класса памяти, к которым может
быть отнесен объект программного кода: auto, static,
register. Они классифицируют переменные по схеме выде-
ления памяти. Приписываются перед объявлением типа
переменной, например,
auto     int i;
static int n;
register int k;
    Класс auto называется автоматическим классом па-
мяти, он действует по умолчанию. Регистровый класс
памяти (register) раньше использовался для того, чтобы
явно указать компилятору, что этот объект должен не-
посредственно размешаться в регистрах процессора, что
позволяло повысить быстродействие программ. Компи-
ляторы современного уровня являются оптимизирующи-
ми, и сами определяют механизмы выделения памяти,
поэтому объявление register носит рекомендательный ха-
рактер, и объявленный объект будет, скорее всего, класса
auto. Класс static называется статическим классом памя-
ти, используется для того, чтобы вынести на глобальный
уровень объявление локального объекта.
    Механизм действия классов памяти зависит от того,
как локализован объект.
    Объекты auto существуют только внутри того блока,
где они определены. Память для объекта выделяется при
входе в блок, а при выходе освобождается, т. е. объекты
перестают существовать. При повторном входе в блок для
тех же объектов снова выделяется память, значения пере-
менных не сохраняются.
    Объекты static существуют в течение всего времени вы-
полнения программы. Память выделяется один раз при
старте программы и при этом обнуляется. При повторном
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   141


входе в блок, где объявлен статический объект, его зна-
чение сохраняется. Вне блока, где объявлен статический
объект, его значения недоступны.
   Пример 2.47.
void f_auto(void)
{
  // переменная K по умолчанию имеет класс auto
  int K=1;        // локальный объект автоматической памяти
  printf("K=%3d ",K);
  K++;
  return;
}
void main(void)
{
  for(int i=1;i<=3;i++)
?? f_auto();
}
   Результат выполнения программы обусловлен лока-
лизацией объекта К:
К=1 К=1 К=1
   В том же примере покажем действие статического
объекта:
void f_stat(void)
{
// переменная K статическая
   static int K=; // локальный объект статической памяти
   printf("K=%3d ",K);
   K++;
   return;
}
void main(void)
{
   for(int i=1;i<=3;i++)
   f_stat();
}
   Результат выполнения программы обусловлен «глоба-
лизацией» объекта К с изменением класса памяти:
К=1 К=2 К=3
     Вне тела функции f_stat объект недоступен.
142                                                   Гл а в а 2


      2.7. Производные типы данных
   В языке C++ есть две группы типов: базовые типы
и производные типы.
   Синонимами названия «базовый тип» являются на-
звания «стандартные», «предопределенные». Реализация
этих типов заложена в стандарте языка. Производным ти-
пом является такой тип, который описывается пользова-
телем перед употреблением. Полезно напомнить, что тип
данного определяет его размещение в памяти и набор опе-
раций.
   К производным типам относятся функции, массивы,
указатели, структуры и объединения.

      2.7.1. Одномерные массивы

                  Определение массива
    Массив — это упорядоченное множество данных одно-
го типа, объединенных общим именем.
    Тип элементов массива может быть почти любым ти-
пом С++, не обязательно это базовый тип.
    Обязательные атрибуты массива — это тип элементов,
число элементов и размерность.
    В главе 1 пособия приведены блок-схемы алгорит-
мов, использующих как одномерные, так и двумерные
массивы.
    Чтобы ввести в употребление массив, его необходимо
описать (конструировать). Можно одновременно выпол-
нить инициализацию элементов массива. Смысл описания
и объявления для массивов идентичен. Описание массива
выполняется, как и для обычных переменных, в разделе
описаний.
    Синтаксис.
Тип_массива Имя_массива [количество_элементов];
   Здесь «количество_элементов» — это константа, задан-
ная явно или именованная (константное выражение).
   Пример 2.48.
#define N 10
int mas[3];     // одномерный массив mas содержит 3
		              // элемента целого типа
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +     143


int matr[2][10];         // одномерный массив matr содержит два
		                       // одномерных массива по 10 элементов
		                       // в каждом
float w[N];              // одномерный массив w содержит N
		                       // вещественных элементов
char c[5][80];           // массив из 5 строк, по 80 символов в строке
   Примечание. Элементы массива нумеруются с 0, т. е.
для массива, описанного как int mas[3] имеются элементы
mas[0], mas[1], mas[2].
   При объявлении массива имя массива сопоставляется
всей совокупности значений. Элементы массива разме-
щаются в памяти подряд в соответствии с ростом индекса
(номера элемента внутри массива). Размер выделяемой
памяти такой, чтобы поместить значения всех элементов.
Такие массивы называются статическими, место в па-
мяти выделяется на этапе компиляции, именно поэтому
размер массива определен константой.
   Чтобы определить общий размер памяти, занимаемой
массивом, можно использовать операцию sizeof(). Как из-
вестно, ее аргументом может быть имя объекта или имя
типа, в том числе объекта сконструированного типа.
sizeof(имя_типа)       // в байтах для любого данного
                       // этого типа
sizeof(имя_переменной) // в байтах для этой переменной
sizeof(имя_массива)    // в байтах для переменной
                       // с учетом длины

                          Операции над массивами
   Над массивом как единой структурой никакие опера-
ции не определены. Над данными, входящими в массив,
набор операций определен их типом. При работе с масси-
вом можно обращаться только к отдельным его элемен-
там. Операция обращения к одному элементу массива на-
зывается операцией разыменования. Это бинарная опера-
ция [], синтаксис которой:
Имя_массива[индекс]
   Первый операнд «Имя_массива» показывает, что про-
исходит обращение к данному, в составе которого много
значений, т. е. ко всем элементам массива.
144                                                           Гл а в а 2



    Второй операнд «индекс» дает возможность выделить
один элемент из группы, и может быть только целочис-
ленным. В общем случае, индекс — это выражение целого
типа, определяющее номер элемента внутри массива (счет
с нуля), например:
mas[0];       // обращение к первому элементу массива
              // (его номер равен 0)
matr[1][3]; // обращение к элементу матрицы, стоящему
              // на пересечении 1-ой строки и 3-го столбца
char c[i][2]; // обращение ко 2-му символу i-ой строки текста
   Замечание. Контроль выхода индекса за границы мас-
сива не существует.
   Пусть имеем массив int   mas[4];
   На рисунке 2.6 показано размещение элементов этого
массива в памяти.
           Имя mas сопоставлено всей совокупности данных
...    mas[0]       mas[1]        mas[2]          mas[3]          ...
      Индекс = 0   Индекс = 1   Индекс = 2      Индекс = 3
                               Рис. 2.6
          Размещение в памяти элементов одномерного массива

   Для каждого элемента массива выделено по 4 байта,
как для данного типа int. В целом для всего массива вы-
делено 4 ? 4 = 16 байт. Значения элементов массива неиз-
вестны.

      Начальная инициализация элементов массива
   При описании массива можно выполнить начальное
присваивание значений его элементам, для этого нужно
задать список инициализирующих значений. В списке
инициализации перечисляются через запятую значения
элементов массива.
   Например, в году всегда 12 месяцев, известно значе-
ние числа дней в каждом месяце, значит, такая структура
может быть задана массивом:
int month[12]={31,28,31,30,31,30,31,31,30,31,30,31};
   Эквивалентом инициализации является простое при-
сваивание вида:
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   145


month[0]=31;             // январь
     …и т. д.
month[11]=31; // декабрь
   Механизм инициализации прост, но имеет некоторые
особенности.
   1. Если значение размера массива опущено, то число
элементов массива равно числу значений в списке ини-
циализации:
int month[]={31,28,31}; // количество элементов равно 3
   Чтобы программно определить число элементов в та-
ком массиве, используется операция sizeof:
int len;		     // число элементов
len=sizeof(month)/sizeof(int);
    2. Если число элементов в списке инициализации
меньше, чем объявлено в описании, то число элемен-
тов массива равно количеству объявленных элементов,
а остальные значения будут равны нулю:
int month[12]={31,28,31,30};
    Количество элементов равно 12, их значения 31, 28,
31, 30, 0, 0,…
    3. Если число элементов в списке инициализации
больше, чем объявлено в описании, то это синтаксическая
ошибка:
int month[2]={31,28,31,30};                       // ошибка

                        Массивы переменной длины
    Одним из недостатков статических массивов, что
обусловлено реализацией, является то, что длина тако-
го массива в тексте программы определена константным
выражением, следовательно, жестко задана в программе.
Часто бывает необходимо, чтобы число элементов массива
изменялось при работе программы. Существуют приемы,
которые используются, чтобы работать с массивом, длина
которого может изменяться:
  • #define определенные константы;
  • массив условно переменной длины;
  • динамические массивы.
    Механизмы работы с динамической памятью изложе-
ны в п. 2.7.4 (глава 2).
146                                               Гл а в а 2



    Рассмотрим два первых приема. Механизм #define
определенных констант заключается в изменении текста
программы перед ее компиляцией, значит, препроцессор
может редактировать код программы, внеся в него лю-
бое количество изменений. Длина массива записывается
в директиве #define, например:
#define N 20
   Имя N теперь константа, и в тексте программы для
управления алгоритмами обработки массива следует ис-
пользовать ее имя. Числовое значение константы (в этом
примере 20) записывается в тексте один раз в самом нача-
ле, и перед очередным запуском программы может быть
изменено один раз, остальные изменения выполнит пре-
процессор. После этого программа нуждается в повторной
компиляции и сборке.
    Пример 2.49. Выполним ввод данных массива и вывод
на печать.
#define N 10
// статический массив. Длина массива равна 10
// значение константы записано один раз
void main(void)
{
   int a[N];
   int i;
   printf("\nВведите %d значений\n",N);
   for(i=0;i<N;i++)
?? scanf("%d",&a[i]);
   for(i=0;i<N;i++)
?? printf("%5d",a[i]);
   printf("\n");
}
   В данном примере в массиве 20 значений, но если нужно
больше или меньше, в коде изменяется только одна строка:
#define N 50
      или
#define N 10
   После этого код должен компилироваться заново.
   Смысл второго приема заключается в том, что дли-
на массива, даже если она изменяется, может быть
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   147


оценена заранее. Например, в студенческой группе не
более 30 человек, в телефонной книге не более 1 млн
записей и т. д. Если знать, какова возможная наиболь-
шая длина массива, то именно это значение и следует
выбрать для описания массива. Для того чтобы знать
реальную длину массива, вводится специальная пере-
менная, которая принимает значение при выполнении
программы, а затем использует его для управления ал-
горитмами обработки массива. Оба приема можно со-
вместить.
   Пример 2.50.
#define N 20      // наибольшая длина массива равна 20
void main(void)
{
int a[N];		       // память выделена для 20-ти элементов
int i;
int Len;		        // фактическая длина массива меньше 20
printf("\nВведите длину массива < %d\n",N);
// ограничение длины
scanf("%d", &Len);
printf("\nВведите %d значений\n", Len);
// переменная Len управляет циклами
for(i=0;i<Len;i++)
   scanf("%d", &a[i]);
for(i=0;i<Len;i++)
   printf("%5d", a[i]);
printf ("\n");
}
      Наибольшая длина массива равна N, фактическая
длина равна Len, где Len < N. В пределах диапазона [0..N]
длина массива может изменяться.

        Алгоритмы работы с одномерными массивами
   Алгоритмы работы с одномерными массивами осно-
ваны на использовании циклических алгоритмов, в кото-
рых выполняется последовательное обращение к элемен-
там массива. Управляющей переменной в таких алгорит-
мах должен быть индекс массива.
148                                                      Гл а в а 2



   Приведем фрагменты алгоритмов решения некоторых
задач для массивов. Будем ориентироваться на абстракт-
ное решение задачи для произвольного массива произ-
вольной длины. Такую возможность дает только исполь-
зование функций обработки массивов. В функцию следует
передать массив (передается адрес) и длину массива. Если
функция не изменяет длину массива, она передается по
значению, если изменяет, то по адресу. Объявление фак-
тических массивов, т. е. тех, с которыми фактически бу-
дет работать функция, и присваивание значений их эле-
ментам происходит в вызывающей программе.
   Приведем программный код задач, алгоритмы кото-
рых даны в примерах 1.7–1.14 (глава 1). Решение каждой
задачи оформлено в виде функции.
   Пример 2.51. Сформировать новый одномерный мас-
сив из положительных элементов заданного массива.
int New_Arr(int x[],int n,int y[],int &k)
{
   k=0;
   for(int i=0;i<n;i++)
?? if(x[i]>0)
?? {
??? y[k]=x[i];
??? k++;
?? }
   return k;        // равенство нулю значения функции
		                  // свидетельствует о неуспехе
}
    Пример 2.52. Вычислить сумму элементов одномерно-
го массива.
int Sum(int a[],int Len)
{
   int S=0;
   for(int i=0;i<Len;i++)
?? S+=a[i];
   return S;
}
   Пример 2.53. Найти количество положительных и от-
рицательных чисел в данном массиве.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   149


void Counts(int a[],int Len, int &K1,int &K2)
{
  K1=K2=0;
  for(int i=0;i<Len;i++)
  {
?? if(a[i]>0)
?? K1++;
  else
?? if(a[i]<0)
  K2++;
  }
}
    Пример 2.54. Дан массив произвольной длины. Найти
наибольший элемент массива и определить его номер.
    Практически, если известен номер элемента, то из-
вестно и его значение. Поэтому в этом коде отыскивается
не «значение и номер», а только номер.
int N_max(int a[],int Len)
{
   int K=0;        // номер наибольшего элемента
   for(int i=1;i<Len;i++)
?? if(a[i]>a[K])
??? K=i;
   return K;
}
   Пример 2.55. Удалить из массива, в котором все эле-
менты различны, наибольший элемент.
void Del_max(int a[],int &Len)
{
  // номер наибольшего элемента находит функция N_max,
  // к ней нужно обратиться
  int k;
  k=N_max(a,Len);
  // сдвиг от k-го элемента до конца массива
  for(int i=k;i<Len-1;i++)
?? a[i]=a[i+1];
  Len--;          // параметр передается по адресу,
		                // длина массива изменится
}
150                                                    Гл а в а 2



   Пример 2.56. Вставить произвольное число m в од-
номерный массив A[n] после элемента с заданным но-
мером k.
void Insert(int a[],int &Len,int k,int m)
{
  // сдвиг от конца массива до k+1-го элемента
  for(int i=Len-1;i>=k;i--)
?? a[i+1]=a[i];
  // место свободно
  a[k]=m;
  Len++;           // параметр передается по адресу, длина
массива изменится
}
    Пример 2.57. Определить, является ли заданная по-
следовательность различных чисел a1, a2, …, an монотон-
но убывающей.
int Decrease(int a[],int Len)
{
   int flag=1;   // flag=1 – последовательность убывает
		               // flag=0 – последовательность не убывает
   int i;
   i=1;
   while(i<Len&&flag==1)
?? if(a[i]>a[i+1])
??? i++;
?? else
??? flag=0;
   return flag;
}
   Пример 2.58. Определить, есть ли в одномерном мас-
сиве хотя бы один отрицательный элемент.
int Negative(int a[],int Len)
{
   int flag=0;
   int i;
   i=0;
   while(i<Len&&flag==0)
?? if(a[i]<0)
??? flag=1;
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +                    151


?? else
??? i++;
  return flag;
}

       2.7.2. Многомерные массивы
   В синтаксисе C++ определены только одномерные
массивы. Массивы большей размерности трактуются как
массивы массивов. Все особенности использования ста-
тических многомерных массивов можно рассмотреть на
примере двумерных массивов (матриц).

                      Описание двумерного массива
   Описание двумерного массива требует, чтобы были
указаны два размера: число строк и число столбцов ма-
трицы, например:
int a[2][5];             // массив из 2-х одномерных массивов,
		                       // по 5 элементов в каждом
    В памяти элементы двумерного массива размещают-
ся построчно подряд по возрастанию индексов. Индексы,
как и раньше, нумеруются с 0.
    Пример инициализации двумерных массивов:
int a[3][4]={
   {1,2,3,4},            // значения элементов нулевой строки
   {2,4,6,8},            // значения элементов первой строки
   {9,8,7,6}             // значения элементов второй строки
   };
   При размещении в памяти будет выделено место под
запись 3 ? 4 = 12 элементов, и они будут размещены ли-
нейно, как на рисунке 2.7, в следующем порядке.

   1      2     3     4            2      4     6    8          9      8     7    6
       Нулевая строка                  Первая строка                Вторая строка
                                  Рис. 2.7
                   Размещение элементов двумерного массива
   Операции над двумерным массивом не разрешены,
кроме операции доступа к его элементам (разыменова-
ния). Обращение к произвольному элементу массива
выполняется по индексу: a[i][j] — адресуется элемент
152                                                  Гл а в а 2



массива, стоящий на пересечении i-го столбца и j-й
строки.
   В п. 1.4 (глава 1) приведены блок-схемы алгоритмов,
использующие двумерные массива.

      Алгоритмы работы с двумерными массивами
    Алгоритмы работы с двумерными массивами похожи
во многом на алгоритмы работы с одномерными массива-
ми. В большинстве случаев требуется обращение ко всем
элементам матрицы, тогда алгоритм просмотра содержит
вложенный цикл, у которого во внешнем цикле управ-
ляющей переменной служит номер строки матрицы, а во
внутреннем — номер столбца. Тогда просмотр элементов
происходит построчно.
    Пусть есть описание матрицы:
#define N 5
#define M 7
int a[N][M];
   Здесь размер матрицы определяют define-константы.
Для матрицы условно переменной длины следует описать
размер по максимуму и ввести переменные, реально опре-
деляющие размер матрицы.
int a[25][25];		
// максимальное число строк, столбцов
int n, m;			           // реальное число строк, столбцов
printf("Введите размер матрицы (строк, столбцов <25)\n");
scanf("%d%d",&n,&m); // теперь это наибольшие значения
			                    // параметров циклов управления
   Для обращения к элементам матрицы по строкам цикл
записывается так:
for(i=0;i<n;i++)
  for(j=0;j<m;j++)
  {
?? // в теле цикла обращение к переменной a[i][j]
  }
   Если переменить эти циклы местами, просмотр будет
происходить по столбцам:
for(j=0;j<m;j++)
  for(i=0;i<n; ++)
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   153


  {
?? // в теле цикла обращение к переменной a[i][j]
  }

     Использование функций при работе с двумерными
                      массивами
    Использование функций при обработке матриц пред-
полагает два кардинально различных подхода. В первом
случае матрица существует или рассматривается как
самостоятельная структура данных, к которой необхо-
димо применить какой-либо алгоритм обработки. В ка-
честве параметра такой функции будет использована
вся матрица целиком. Для решения задачи обработки
в общем виде, в функцию следует передать имя матрицы
и ее размеры (как параметры функции), при этом функ-
ция получает матрицу как двумерный массив. Компи-
лятор С++ должен знать, каков способ разбиения этой
структуры на строки, поэтому число строк матрицы
можно опустить, а число данных в каждой строке опу-
скать нельзя. Оно должно быть указано обязательно как
константное выражение в квадратных скобках при пе-
редаче матрицы. Так, прототип функции, получающей
матрицу в качестве входного данного, может выглядеть
так:
int function(int a[][M],int n,int m);
// здесь M – константное выражение
    В качестве примера рассмотрим функции для вво-
да и вывода матрицы на экран. Предполагается, что
матрица условно переменного размера, поэтому чис-
ло строк и столбцов матрицы по описанию определено
define-константами N = 5 и M = 5. Реальный размер ма-
трицы определяют переменные n, m, значения которых
вводятся.
    Блок-схемы алгоритмов ввода и вывода элементов ма-
трицы приведены в п. 1.4.1 (глава 1).
#include <stdio.h>
#define N 5
#define M 5
void input_matr(int a[][M],int &n,int &m);
154                                                  Гл а в а 2



// важно, что длина строки – это константа
void print_matr(int a[][M],int n,int m);
// n – число строк, m – число столбцов
void main(void)
{
   // главная программа описывает входные данные
   int n, m;		            // реальные размеры матрицы
   int matr[N][M];        // описан двумерный массив
   input_matr(matr,n,m); // передан в функцию ввода
   print_matr(matr,n,m); // передан в функцию вывода
}
// описание функции ввода
// параметры функции – имя и размеры массива
void input_matr(int a[][M],int &n,int &m)
// n, m возвращаются по ссылке
{
   int i, j;
   printf("Введите размер матрицы не более %d на %d\n", N,
M);
   scanf("%d%d", &n,&m);
   printf("Введите матрицу.\n");
   for(i=0;i<n;i++)
?? for(j=0;j<m;j++)
??? scanf("%d", &matr[i][j]);
}
// описание функции вывода
// параметры функции – имя и размеры массива
void print_matr(int a[][M],int n,int m)
{
   int i, j;
   for(i=0;i<n;i++)
   {
?? for(j=0;j<m;j++)
??? printf("%5d",mas[i][j]);
??? printf("\n");         // разбиение вывода на строки
   }
}
   Во втором случае матрица рассматривается как мас-
сив из одномерных массивов, при этом для обработки от-
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   155


дельных строк матрицы можно использовать функции
обработки одномерных массивов. Зная, что элементы ма-
трицы — это одномерные массивы, каждый из них можно
по очереди передавать в функцию, которая работает с од-
номерным массивом.
    Приведем код программ, реализующих примеры 1.15–
1.19 (глава 1). Алгоритм решения каждой задачи реали-
зован с помощью функции.
    Пример 2.59. Вычислить сумму элементов строк за-
данного двумерного массива.
void Sum_Rows(int a[][N],int n,int m,int S[])
{
  int i,j;
  for(i=0;i<n;i++)
  {
?? S[i]=0;
?? for(j=0;j<m;j++)
??? S[i]=S[i]+a[i][j];
  }
}
   Пример 2.60. Найти наибольший элемент двумерного
массива и его индексы.
int Maxx(int a[][N],int n,int m,int &Maxi,int &Maxj)
{
   int Max=a[0][0];
   int i,j;
   Maxi=Maxj=0;
   for(i=0;i<n;i++)
?? for(j=0;j<m;j++)
??? if(a[i][j]>Max)
??? {
???? Max=a[i][j];
???? Maxi=i;
???? Maxj=j;
????? }
?? return Max;
}
   Пример 2.61. Вставить в двумерный массив строку,
состоящую из нулей, после строки с номером k.
156                                                     Гл а в а 2



int Insert_Row(int a[][N],int &n,int m,int k)
{
   int i,j;
   if(k>m)
?? return 0;		             // если неверно задано значение k
   for(i=n-1;i>=k;i--)     // раздвигаем строки
?? for(j=0;j<m;j++)
??? a[i+1][j]=a[i][j];
   n++;
   // заполняем нулями освободившуюся строку
   for(j=0;j<m;j++)
?? a[k][j]=0;
   return 1;
}
    Пример 2.62. Удалить из двумерного массива строку
с номером k.
int Del_Row(int a[][N],int &n,int m,int k)
{
   int i,j;
   if(k>m)
?? return 0;       // если неверно задано значение k
   // сдвигаем строки
   for(i=k;i<n-1;i++)
?? for(j=0;j<m;j++)
??? a[i][j]=a[i+1][j];
   n--;
   return 1;
}
   Пример 2.63. Дана матрица A[n, m]. Найти количество
строк, содержащих хотя бы один нуль.
int Cou_Rows(int a[][N],int n,int m)
{
   int i,j;
   int k=0;
   int flag;
   for(i=0;i<n;i++)
   {
?? j=0;
?? flag=0;
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   157


?? while(j<m && flag==0)
?? {
??? if(a[i][j]==0)
??? {
???? flag=1;
???? k++;
??? }
??? else j++;
??? }
  }
  return k;
}

     2.7.3. Указатели
    Указатели — такие объекты (переменные), значени-
ем которых являются адреса других объектов (или какой-
либо области памяти).
    Кроме того, значением указателя может быть пустое
значение, не равное никакому адресу. В некоторых би-
блиотеках, например, <stdlib.h>, эта константа определе-
на значением NULL.

                            Объявление указателей
   Описание переменных типа указатель обязательно
должно показывать тип переменной, которую адресует
указатель. Сама переменная типа указатель имеет размер
2 или 4 байта в зависимости от модели памяти.
   Признаком того, что объявляется указатель, является
символ «*».
int *ip;   // указатель на ячейку, содержащую целое число
float *fp;
// указатель на ячейку, содержащую действительное число
char *cp; // указатель на ячейку, содержащую символ
void *pp; // указатель на ячейку неизвестного типа
     Пример 2.64.
     Пусть объявлены указатели:
char *pa;
int *pb;
double *pc;
158                                                                Гл а в а 2



   Тогда размещение переменных и указателей в памяти
будет таким, как на рисунке 2.8.
              pa                   pb                    pc
      адрес char 4 байта    адрес int 4 байта   адрес double 4 байта
      значение DS:FF12     значение DS:FF08      значение DS:FF00
       адресует 1 байт      адресует 4 байта      адресует 8 байт
                              Рис. 2.8
             Размещение переменных и указателей в памяти

           Определение операций над указателями.
               Операция получения адреса &

   Это унарная операция, которая может быть примене-
на к операнду любого типа. Возвращает 16-ричный адрес
объекта, определяющий его размещение в памяти.
   Пример 2.65.
int x=3; // выделены 2 байта по какому-то адресу
         // и присвоено значение
int *px; // выделены 2 байта для хранения адреса типа int
     Операция &x получит адрес переменной х, который
можно присвоить переменной, предназначенной для хра-
нения адреса, это px.
px = &x; // адрес можно присвоить указателю
   Операция применяется только к именованным объек-
там, размещенным в памяти. Бессмысленно ее примене-
ние к константам, выражениям, внешним объектам.

 Операция получения значения по указанному адресу *
    Синонимы — операция разыменования, раскрытия
ссылки или обращения по адресу. Это унарная операция,
операндом может быть только указатель. Возвращаемое
значение имеет тип той переменной, на которую пока-
зывает указатель, и возвращает значение, размещенное
в той области памяти, на которую ссылается указатель.
    Пример 2.66.
int x=3; // выделены 2 байта по какому-то адресу
         // и присвоено значение
int *px; // выделены 2 байта для хранения адреса типа int
         // операция &x получит адрес переменной х
px = &x; // адрес переменной x можно присвоить указателю
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   159


int new_x; // новая переменная new_x
new_x = *px;
     Переменная new_x получила значение той перемен-
ной, которая хранится по адресу, имеющему значение px,
следовательно px знает адрес x. Поэтому переменная new_x
получит значение, равное 3.
   Тип данного void может адресовать объект любого
типа, но к нему нельзя применить операцию «*».
   Примеры недопустимого использования типа void.
int x=3;
float y=2.5;
void *p_k;               // указатель на void
void *p_y;               // указатель на void
p_k = &k;
p_y = &y;

              Операция присваивания для указателей
    Операция присваивания в С++ имеет особенности,
связанные с преобразованием типов.
    При присваивании указателей возможные ошибки не-
соответствия типов могут вызвать не только потерю дан-
ных, но и привести к трагическим последствиям, точно
так же, как если адрес перепутал почтальон. Тем не ме-
нее, преобразование типов указателей может быть выпол-
нено так же, как и для простых типов, но с использовани-
ем операции «*», например:
int *x;
float *y;
y=(int *)x;
x=(float *)y;
    Механизмы, связанные с таким преобразованием,
очень тонкие. Попытаемся показать это на примере.
    Пример 2.67.
    Объявим переменную L типа unsigned long и запишем
в нее 16-ричную long константу 0x12345678L.
    Объявим три указателя (на char, int и long), и каждому
из них присвоим адрес этой константы (&L).
    При присваивании будем выполнять приведение ти-
пов.
160                                                    Гл а в а 2



unsigned long L=0x12345678L;             // длинное целое
  char *c=(char *)&L;
  int *i=(int *)&L;
  long *l=(long *)&L;
  printf("\nЗначение L=%#lx",L);
  printf "\nАдрес L (то, что &L)=%p",&L);
  printf("\nАдрес с=%p *c=%#x",c,*c);
  printf("\nАдрес i=%p *i=%#x",i,*i);
  printf("\nАдрес l=%p *l=%#lx",l,*l);
      Вывод будет таким:
Значение L = 0x12345678
Адрес L (то, что &L)=0016FBC8
Адрес с=0016FBC8 *c=0x78
Адрес i=0016FBC8 *i=0x5678
Адрес l=0016FBC8 *l=0x12345678
    Здесь отчетливо видно, что адреса всех объектов c, i, l
одинаковы, и это означает, что все они адресуют одну и ту
же область, выделенную переменной L. Однако же значе-
ния, извлекаемые из одной и той же области различны,
и зависят от типа указателя.

                Унарные операции ++ и – –
    Унарные операции ++ и – – изменяют значение адреса
в зависимости от типа данных, с которым связан указа-
тель, а именно:
  • для char на 1 байт;
  • для int на 4 байта;
  • для double на 8 байт.
    Эта операция называется смещением указателя. В сле-
дующем примере показано, что выделение адресов в сег-
менте данных происходит не справа налево, а от старших
байт вниз.
    Пример 2.68.
int a=0;
int b=20;
int c=30;
int *pa=&a;
int *pb=&b;
int *pc=&c;
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   161


printf("\nАдрес %p Значение %d", a,*pa);		
// FFF4, значение 10
printf("\nАдрес %p Значение %d", pb,*pb);		
// FFF2, значение 20
printf "\nАдрес %p Значение %d", pc, pc);		
// FFF0, значение 30
// операция смещения указателя приведет к просмотру
объектов
// a, b, c, если использовать pa –– или pc++
for(int k=1; <=3;k++)
   printf("\nАдрес %p Значение %d",pa ––, *pa);
// выводится то же, что и в трех предыдущих операторах
вывода

                            Сложение и вычитание
    Складывать адреса бессмысленно, но можно приба-
вить к адресу целое число, например, pa+число. Будет по-
лучено новое значение адреса, смещенное относительно
старого указателя в зависимости от типа указателя, на
число*sizeof(тип_указателя) в байтах.
    Вычитание адресов можно применить к указателю и чис-
лу или к двум указателям. В первом случае будет получено
новое значение адреса, смещенное относительно старого
указателя, как и при сложении. Во втором случае разность
(со знаком), это расстояние в единицах, кратных размеру
одного объекта указанного типа. Например, смещение pb на
+1 — это адрес a, смещение pb на 1 — это адрес c.
    Пример 2.69.
printf("\nАдрес %p Значение %d",pb+1,*(pb+1));
// значение 10
printf("\nАдрес %p Значение %d",pb–1,*(pb–1));		
// значение 30
printf("\nРасстояние между с и a=%d",pc–pa);		
// расстояние = 1

                              Операции отношения
   Все операции отношения могут использоваться для
сравнения значений адресов. Разрешается сравнивать толь-
ко указатели одинакового типа или указатель сравнить
162                                               Гл а в а 2



с константой NULL. Многие функции стандартных библио-
тек С++ возвращают указатели. Если функция не может
вернуть адрес, то возвращаемым значением будет NULL.
    Приоритеты операций, разрешенных над указателями:
  • унарные операции косвенной адресации «*» и получе-
    ния адреса «&»;
  • аддитивные операции;
  • операции сравнения;
  • операция присваивания.

                    Указатели и массивы
    Синтаксис языка С++ определяет имя массива как адрес
его первого элемента (с нулевым значением индекса). Все
следующие элементы располагаются подряд в порядке воз-
растания адресов. Обращение к элементам массива может
быть выполнено с помощью операции [ ] (прямая адреса-
ция) или с помощью операции «*» (косвенная адресация).
    В первом случае для нумерации элементов массива
используются целочисленные индексы, нумерующие эле-
менты массива.
    Во втором случае для определения номера элемента
внутри массива используется смещение указателя от пер-
вого элемента.
    Например, если объявлен массив:
int mas[]={10,20,30,40};
то mas — это адрес первого элемента массива (адрес
mas[0]).
    Адрес следующего элемента mas[1] или mas+1, следу-
ющего mas[2] или mas+2, и т. д.

              Косвенная адресация в массивах
      Пусть объявлен массив
int mas[]={10,20,30,40};
      Пусть его длина определена как
int n=sizeof(mas)/sizeof(int);
   Для прямой адресации в массиве используется рабо-
чая переменная, которая определяет целочисленное зна-
чение индекса элемента массива:
int i;
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +         163


for(i=0;i<n;i++)
  // обращение к mas[i]
   Для косвенной адресации в массиве используется ра-
бочая переменная, которая определяет значение адреса
элемента массива:
int *pti; // тип этого указателя, как у элементов массива
          // (синоним массива)
for(pti=mas; pti<mas+n;pti++)
// обращение к *pti
   Обращение к элементам массива при изменении ин-
декса и обращение к элементам массива при смещении
указателя показано на рисунке 2.9.
 ...           10               20              30               40
                       Выделение памяти для указателя pti
          4 байта            4 байта         4 байта          4 байта
       mas[0] при i = 0 mas[1] при i = 1 mas[2] при i = 2 mas[3] при i = 3
          *pti при       *(pti + 1) при   *(pti + 2) при   *(pti + 3) при
         pti = mas        pti = mas + 1   pti = mas + 2    pti = mas + 3
                                    Рис. 2.9
                    Прямая и косвенная адресация в массивах

int i;
int *pti;
pti=mas;
   После присваивания pti=mas, указателю доступен
адрес массива:
printf("\n Первый элемент массива=%d", *pti;)
printf("\n Второй элемент массива=%d", *++pti);
// *(pti+1)
printf("\n Третий элемент массива=%d", *++pti);		
// *(pti+2)
printf("\n Последний элемент массива=%d", *(pti+3));
   Приведем пример различной адресации в массиве при
вычислении суммы элементов массива. Это обычный ал-
горитм обработки массива. Для решения задачи необхо-
дим последовательный просмотр всех элементов массива.
   Пример 2.70.
#define N 5
void main(void)
{
164                                               Гл а в а 2



int mas[N]={1,2,3,4,5};
int Sum;
int i;
// прямая адресация
// обращение к элементам массива через операцию []
for(i=0,Sum=0;i<N;i++)
   Sum+=mas[i];
printf("\nСумма=%d", Sum);
// косвенная адресация
// обращение к элементам массива через операцию *
int *pti;
for(pti=mas,Sum=0;pti<mas+N;pti++)
   Sum+=*pti;
printf("\nСумма=%d", Sum);
// косвенная адресация
// обращение к элементам массива смещением указателя
// относительно начала массива
for(pti=mas,i=0,Sum=0;i<N;i++)
   Sum+=*(mas+i);
printf("\nСумма=%d", Sum);
// напечатаем номера и адреса элементов этого массива
// спецификатор формата для вывода адресов %р
int k;
for(pti=mas,k=0;pti<mas+N;pti++)
   printf("\nНомер=%d, Адрес=%p",k++,pti);
}

      2.7.4. Динамические массивы (массивы динамической
             памяти)

    При статическом распределении памяти для элемен-
тов массива их общее количество должно быть известно
при компиляции, когда происходит распределение памя-
ти. Часто это значение неизвестно заранее, и его необхо-
димо определить в процессе выполнения программы.

       Динамическое выделение памяти в языке С++
   Для динамического выделения памяти в C++ введены
специальные операции выделения динамической памя-
ти new и высвобождения delete. Операция new выделяет
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   165


в куче (heap) память требуемого размера для объекта,
операция delete разрушает объект, возвращая память
в кучу.
    Синтаксис.
Указатель=new Имя_объекта[количество_элементов];
   Операция new пытается открыть объект с именем
«Имя_объекта» путем выделения sizeof(Имя_объекта) байт
в куче.
    Синтаксис.
delete имя_объекта;
    Операция delete удаляет объект с указанным именем,
возвращая столько же байт в кучу.
   Объект существует с момента создания до момента
разрушения или до конца программы.
   Память для размещения статических объектов в С++
распределяется во время компиляции, для динамиче-
ских — во время выполнения программы. Этот механизм
требует пояснений.
   При выполнении приложения операционная система
выделяет процессу виртуальное адресное пространство,
которым процесс владеет единолично. Данные и коды их
обработки в процессе работы приложения должны нахо-
диться в оперативной памяти. Память, выделенная про-
цессу, распределяется так, как показано на рисунке 2.10.




                                     Рис. 2.10
                           Распределение памяти в «куче»

Данные размещаются в младших адресах, коды — в стар-
ших. Между ними остается свободная область адресов,
называемая кучей (heap). Управление памятью в куче
выполняет специальная утилита операционной системы,
называемая диспетчером кучи. Выделение и высвобожде-
ние динамической памяти в неуправляемых приложени-
ях С++ не контролируется операционной системой, и на-
166                                                  Гл а в а 2



ходится целиком в ведении программиста. Динамическая
память может быть выделена для простого объекта, что не
имеет смысла, или для сложного объекта, занимающего
много места в памяти, например, массива.
    Покажем механизмы выделения памяти для простого
объекта.
    Пусть в коде программы объявлена переменная int,
и указатель на int. При объявлении память будет выделе-
на статически, в отладчике можно узнать адреса. Напри-
мер, память распределена так, как в примере:
int a;       // 4 байта в статической памяти,
             // адрес &a=0x0032f960
int *p_a;    // 4 байта в статической памяти,
             // адрес &p_a=0x0032f954
      Только после выполнения операции
*p_a=new int;
// 4 байта в динамической памяти, адрес 0x00121c18
объекту p_a выделена память. Ее адрес становится значе-
нием переменной p_a:
p_a = 0x00121c18
    По значению адреса видно, что он находится в другой
области памяти. Собственного имени эта область не име-
ет, обращение к ней выполняется через синоним имени:
*p_a=99;
p_a=&a; // a=99
    При высвобождении адреса операцией delete:
delete p_a; указатель p_a, оставаясь на прежнем месте, пе-
рестает быть связанным с областью памяти, адресованной
0x00121c18, и его можно использовать для других целей.
   Пример 2.71. Приведем пример использования опера-
ций new и delete.
name *ptr;           // здесь name любой тип, кроме функции
if(!(ptr=new name)) // может оказаться равным NULL
{
   printf("Нет места в памяти.\n");
   exit();
}
                     // использование объекта по назначению
delete ptr;          // разрушение объекта
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   167


   Пример 2.72. Приведем пример создания динамиче-
ского одномерного массива.
int *mas;		              // указатель на массив
printf("Введите количество элементов в массиве");
scanf("%d",&N);
mas=new int[N];		        // выделение памяти для массива
if(mas==NULL)
{
   printf("\nНет памяти");
   return;
}
// массив существует, адресация массива
// выполняется через имя указателя
delete mas[]; 		         // массив разрушен
   Примечание. При выделении памяти переменной
(массиву) через указатель, переменная (массив) не имеет
собственного имени. Обращение к переменной (массиву)
выполняется только посредством указателя, который
играет роль синонима имени.
   Объект динамической памяти разрушается при ис-
пользовании операции delete или при завершении работы
программы, если не был разрушен ранее.

                  Динамические двумерные массивы
   Динамические двумерные массивы объявляются как
указатель на указатель. Память выделяется для каждой
строки отдельно, так и высвобождается тоже для каждой
строки. Адресация не зависит от способа выделения памя-
ти и может быть как прямой, так и косвенной. Размеще-
ние в памяти для каждого массива линейное, примерная
схема выделения памяти показана на рисунке 2.11.
   Пример 2.73. Приведем фрагмент кода программы,
которая выделяет память для динамического двумерного
массива.
int **a; // адрес динамической памяти
int i,j;
printf("Введите количество строк и столбцов\n");
scanf("%d%d",&n,&m);
// первый этап: выделение памяти для массива указателей
168                                                      Гл а в а 2




                           Рис. 2.11
  Схема выделения памяти для динамического двумерного массива


// для строк матрицы нужно n элементов размером int
a=new int *[n];
if(a==NULL)
{
   printf("\n Нет памяти\n");
   return NULL;		        // Выход из функции
}
// второй этап: выделение памяти для каждой строки
// матрицы
// выполняется n раз, выделяется по m элементов
for(i=0;i<n;i++)
{
   a[i]=new int[m];
   if(a[i]==NULL)
   {
?? printf("\n Нет памяти");
?? return NULL;		               // выход из функции
}
}
   Пример 2.74. Приведем фрагмент кода в качестве при-
мера работы с элементами массива.
printf("Введите матрицу размером %d строк и %d
столбцов\n", n, m);
  for(i=0;i<n;i++)
?? for(j=0; <m; ++)
scanf("%d", &a[i][j]);
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   169


printf("\nРезультат");
for(i=0;i<n;i++)
{
  for(j=0;j<m;j++)
?? printf("%d ",a[i][j]);
printf("\n");
}
   Высвобождение памяти, занятой динамическим дву-
мерным массивом, осуществляется тоже в два этапа: сна-
чала высвобождается память, занятая строками, затем
высвобождается двойной указатель на массив.
for(i=0; i<n; i++)
  delete a[i];     // разрушаются строки
  delete a;        // высвобождается указатель на матрицу

                              Массивы указателей
   Массивы указателей могут использоваться для хране-
ния адресов объектов и управления ими. Эта возможность
применяется для объектов большого размера или для ди-
намических объектов.
   Синтаксис определения массива указателей:
Тип_массива * Имя_массива[количество_элементов];
     Определение с одновременной инициализацией:
Тип_массива * Имя_массива[] ={инициализатор};
Тип_массива * Имя_массива[количество_элементов]=
{инициализатор};
   Здесь «Тип_массива» может быть базовым или произво-
дным, а «инициализатор» – это список значений адресов.
   Например:
int Data[6];     // массив целочисленных значений
int *pD[6];      // массив указателей
int *pI[]={&Data[0],&Data[1],&Data[2]}; // с инициализацией
     Здесь каждый элемент массивов pD и pI является ука-
зателем на объекты типа int, следовательно, значением
каждого элемента pD[i] и pI[i] может быть адрес объекта
типа int. Элементы массива pD не инициализированы,
значит, имеют неопределенные адреса. В массиве pI три
элемента, значения которых — это адреса конкретных
элементов массива Data.
170                                                        Гл а в а 2



   В качестве простого примера рассмотрим програм-
му сортировки по возрастанию одномерного массива без
перестановки его элементов. Здесь элементы исходного
массива не меняются местами, т. е. остаются в прежнем
порядке, а сортируется массив указателей на элементы
массива *pA. С его помощью определяется последователь-
ность просмотра элементов массива A[N] в порядке возрас-
тания их значений.
   Рисунок 2.12 иллюстрирует исходную и результирую-
щую адресации элементов массива A элементами массива
указателей *pA.




                                Рис. 2.12
                      Массивы в задаче сортировки:
а — массивы до сортировки; б — массивы после сортировки.



      Приведем код примера.
      Пример 2.75.
#define N 10
void main(void)
{
  int A[N]={10,1,3,2,6,5,4,8,7,9};
  int *pA[N];
  int *buf;      // буфер для перемены адресов
  int i,j;
  for(i=0;i<N;i++)
?? pA[i]=&A[i]; // копирование адресов (см. рис. 2.12а)
  for(i=0;i<N–1;i++)
?? for(j=i+1;j<N;j++)
?? {
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   171


??? if(*pA[i]>*pA[j])
??? {
??? // перестановка в массиве адресов (см. рис. 2.12б)
???? buf=pA[i];
???? pA[i]=pA[j] ;
???? pA[j]=buf;
??? }
  }
  printf("\n Массив, отсортированный по возрастанию:\n");
  for(i=0;i<N;i++)
?? printf("%d ",*pA[i]); // вывод по возрастанию
  printf("\n Массив в исходном порядке:\n");
for(i=0;i<N;i++)
  printf("%d", A[i]);    // вывод в исходном порядке
}

     2.7.5. Указатели и функции
   Механизмы указателей при работе с функциями ис-
пользуются для решения многих практических задач.

                     Передача параметров по адресу
    Ранее рассматривался механизм передачи параме-
тров в функцию по значению (см. п. 2.5). При обращении
к функции и передаче ей параметров создается локаль-
ная копия объекта в теле функции. Значение объекта
вызывающей программы, передаваемое в функцию как
фактический параметр, не может быть изменено в теле
функции.
    Чтобы определить функцию, возвращающую более
одного значения, нужно дать ей возможность изменить
значения параметров. В качестве параметра следует пе-
редавать не значение объекта вызывающей программы,
а его адрес. При этом используется механизм указателей.
Адресная операция (&) применяется к имени параметра.
Синтаксис этого описания:
Тип_функции Имя_функции(Тип_параметра &Имя_параметра)
    Механизм этого способа передачи данных заключает-
ся в том, что функция и вызывающая программа работа-
ют с адресом объекта в памяти, следовательно, обе могут
172                                              Гл а в а 2



изменить значение этого данного. При этом и в вызываю-
щей программе и в функции этот параметр должен быть
именованным объектом.
    В классическом языке С этот механизм отсутствует.
В C++ признак передачи параметра по ссылке указывает-
ся в списке формальных параметров при описании функ-
ции и в прототипе.
// передача параметра по адресу в стиле C++
void change_5(int &ptr)
// формальный параметр – адрес объекта
{
?? ptr+=5;
   }
   void main(void)
   {
?? int x=5;
?? printf("x=%d\n",x);
?? change_5(x);
?? printf("А теперь x=%d\n",x);
}

           Массивы как параметры функций
    Особенность массива в том, что он является указате-
лем. Имя массива — это адрес его нулевого байта. Ког-
да параметром функции является массив, то, согласно
синтаксису С++, в функцию передается его адрес, сле-
довательно, функция будет изменять элементы масси-
ва, так как включается механизм передачи данных по
адресу.
    Способов записи формальных параметров массивов
в заголовке функции может быть два:
тип_функции имя_функции(тип_массива Имя[])
тип_функции имя_функции(тип_массива *Имя)
   Как видим, длина массива отсутствует в описании
формального параметра. Конструкции «Имя[]" и "*Имя»
различны внешне, но одинаковы по выполняемым меха-
низмам, если «Имя» — это имя массива. Длина массива,
как правило, определена его описанием или передается
в функцию как параметр.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   173


    В теле функции элементы массива адресуются любым
способом независимо от синтаксиса формального параме-
тра. При обращении к функции указывается только имя
массива.
    Несомненным достоинством этого механизма явля-
ется возможность простой и надежной реализации алго-
ритмов обработки массивов переменной длины. При этом
задачи обработки массивов решаются в общем виде. В ка-
честве параметров в функцию следует передать имя мас-
сива и его длину. Если содержимое массива будет изме-
нено функцией, это изменение доступно и вызывающей
программе. Если функция не изменяет длину массива, ее
следует передать как параметр-значение, если изменяет,
то как параметр-адрес, например:
int function(int a[],int n);
// а – имя массива, n – длина массива
int function (int a[],int &n);
// а – имя массива, n – длина массива
    Независимо от способа передачи, фактическим пара-
метром при обращении к функции должно быть имя мас-
сива.
    Для двумерных массивов задача не может быть реше-
на так просто, потому что двумерный массив при переда-
че в функцию разбивается на строки. Функция должна
знать способ разбиения на строки, поэтому число строк
данных можно опустить, а число данных в каждой строке
опускать нельзя. Оно должно быть указано обязательно
как константное выражение в квадратных скобках при
передаче матрицы. Так, прототип функции, получающей
матрицу в качестве входного данного, может выглядеть
так:
int function(int a[][M],int n,int m);
// здесь M – константное выражение
   Примером использования массивов в качестве пара-
метров функций могут служить функции ввода и вывода
одномерных массивов. Эти функции решают алгоритми-
ческие задачи в общем виде.
   Пример 2.76.
#define N 40
174                                                    Гл а в а 2



// функция вывода массива произвольной длины
void print_mas(int mas[],int len) // параметры – имя и длина
{
   int i;
   printf("Массив:\n");
   for(i=0;i<len; ++)
?? printf("%5d ", mas[i]);
   printf("\n");
}
// функция ввода массива произвольной длины
void input_mas(int *mas,int &len) // параметры – имя и длина
// длина передается по ссылке
{
   int *ip;
   printf("Введите количество элементов массива <
%d\n",N);
   // N – наибольшая длина
   scanf("%d",&len);
   printf("Введите элементы массива\n");
   for(ip=mas;ip<mas+len;ip++)
?? scanf("%5d",ip);                   // признак & не нужен
}
// функция преобразования массива
void transform_mas(int *mas,int len)
// параметры – имя и длина
{
   int i;
   for(i=0;i<len;i++)
   mas[i]=mas[i]*2;
}
   В вызывающей программе массив должен быть объяв-
лен, может получить значения. В обращении к функции,
чтобы передать массив, нужно указать только его имя:
void main(void)
{
  int a1[N],a2[N];    // объявлены два массива
  int n1,n2;		        // их длины
  // каждый массив введен, преобразован, распечатан
  input_mas(a1,n1);
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   175


    transform_mas(a1,n1);
    print_mas(a1,n1);
    input_mas(a2, 2);
    transform_mas(a2,n2);
    print_mas(a2,n2);
}
   Следует обратить внимание на то, что главная про-
грамма теперь занимается только управлением и переда-
чей данных. Логика ее работы прозрачна, текст не пере-
гружен подробностями алгоритмов.

            Функции, возвращающие адреса объектов
    Такие функции используются при работе с динамиче-
скими данными, т. е. массивами и строками. Тип функ-
ции (возвращаемого ею значения) может быть одним из
базовых типов или указателем. Во втором случае возвра-
щаемое значение — это адрес какого-либо объекта в памя-
ти. Сам объект может иметь произвольный тип и может
быть объектом базового, но чаще конструируемого типов.
В случае динамических данных функция может породить
новый объект и вернуть его адрес.
    Возвращаемое функцией значение должно быть при-
своено переменной типа указатель.
    Такими функциями являются многие библиотечные
функции, которые требуют выделения памяти под вновь
созданный объект, и, как правило, возвращают вновь соз-
данное значение. Например, многие функции работы со
строками библиотеки <string.h>, многие функции ввода
данных библиотек <stdio.h> и <stdlib.h> и др.
    Пример 2.77. Приведем пример функции, возвращаю-
щей указатель.
int *func(int n)
{
   int *a;		     // объявлен указатель
   *a=n;		       // его значение равно значению параметра n
   return a;     // возвращается адрес
}
void main(void)
{
176                                                 Гл а в а 2



  int b;
  b=*func(12); // простая переменная b получает значение
		               // возвращенного функцией адреса
  printf("%d",b);
  int *d;
  d=func(12); // указатель d получает значение адреса,
		               // который вернула функция
  printf("%d",*d);
}
   Более полезным будет пример, в котором функция
возвращает массив динамической памяти. Количество
данных, для которых нужно выделить память и присво-
ить значения, является внешним параметром функции,
и передается из вызывающей программы.
int *new_mas(int n)
{
   int *mas;
// область оперативной памяти, связанная с указателем
   int *ip;
   // выделена память: mas – это реальный адрес массива
   mas=new int[n];
   printf("Введите %d элементов.", n);
   for(ip=mas; ip<mas+n; ip++)
?? scanf("%d", ip);
   return mas; // вернуть объект
}
   Обращение к функции требует, чтобы ее значение
было присвоено указателю, адресующему массив.
int *My_Arr;
My_Arr=*new_mas(5);
   Имя массива в функции main() – My_Arr, его длина
равна 5, для массива выделена память и введены зна-
чения.

      2.7.6. Символьные строки
   Для объявления объектов символьного типа использу-
ются ключевые слова char или unsigned char.
   Данные символьного типа занимают один байт. Вну-
треннее представление символьного данного — это его
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   177


целочисленный код. Такое представление позволяет обра-
щаться к символам как к числовым величинам, что дает
некоторые преимущества.
   1. Можно использовать все операции отношений для
того, чтобы сравнивать символы друг с другом. При этом
сравниваются коды символов, например:
char c1, c2;
c1=getchar();
// функция getchar получает символ с клавиатуры
c2=getchar();
   Любую операцию отношения можно использовать для
сравнения символов.
int k=(c1==c2); // k=1, если символы равны, k=0, если нет
k=(c1>c2);      // k=1, если код с1 больше кода с2, иначе 0
     Для проверки условия «символ с1 является цифрой»,
можно использовать упорядоченность кодов цифр по воз-
растанию
k=(c1>='0'&& c1<='9')
   2. При выполнении арифметических операций над
символами, операции выполняются над значениями вну-
тренних кодов символов: можно применять арифметиче-
ские операции, например, +, –, ++, – –, чтобы получить
код символа.
   3. Можно использовать символьные переменные как
управляющие переменные, чтобы организовать циклы
обработки символьных или строковых данных, напри-
мер, перебор в алфавитном порядке:
char c;
for(c='a';c<='z';c++)
{ // например, сравнение символа со значениями с
}
     Здесь символьная переменная c является операндом
арифметической операции ++, выполняемой над значе-
нием ее внутреннего кода.
    Коды символов иногда знать необходимо. Для опреде-
ления кода символа используется функция getch() библи-
отеки <conio.h>. Эта функция читает с клавиатуры сим-
вол, и если присвоить результат переменной целого типа,
то будет получен код символа.
178                                                 Гл а в а 2



      Пример 2.78.
#include <conio.h>      // для geth ()
#define ESC 0x11b
// шестнадцатеричный код клавиши [Esc]
void main(void)
{
   int key;
   do
   {
?? key =getch();        // код символа
?? printf("%d\n", key);
   } while(p!=27);      // обрабатывается событие
"Нажатие Esc"
}
    Строка символов рассматривается как массив симво-
лов (типа char[]). Каждый символ хранится в отдельном
байте, включая специальные символы. В конце строки
должен быть нулевой байт '\0', как признак конца стро-
ки. Он добавляется автоматически при инициализации
строки и при вводе строки. Общее число символов в стро-
ке определяется с учетом нулевого символа, и равно «дли-
на строки +1». При формировании строки вручную необхо-
димо заботиться о том, чтобы этот символ был добавлен.
Так, длина константы 'W' равна одному байту, а длина
строки "W" равна двум байтам.
    Операции с массивами в языке С++ не допускаются,
следовательно, и для строк в целом операций нет. Сим-
вольная строка в выражении — это адрес массива симво-
лов. Указатель на строку может быть использован везде,
где можно использовать указатель.
    Объявить строковую переменную можно двумя спосо-
бами.
    1. Как статический массив. Считается, что это плохой
стиль, так как длина строки может изменяться ограни-
ченно. На самом деле при обработке текстов, так или ина-
че, ограничение на длину строки существует, и оно может
быть достаточно расплывчатым.
char Str[80];            // длина не более 79 символов
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +      179


   2. Как указатель. При этом создается динамическая
строка данных типа char, для хранения которой необхо-
димо выделение памяти.
char *Str;
Str=new char[80];                        // длина строки и здесь
                                         // определена числом
   При инициализации, независимо от способа объявле-
ния строки, всегда происходит выделение памяти под за-
пись значений строки.
char *Str1="строка 1";    // длина строки 9 байт
char Str2[9]="строка 2";  // длина строки 9 байт,
                          // как объявлено
char Str1[]="строка 3";   // специальный инициализатор
char Err[4]="ошибка";     // длина строки больше,
                          // чем объявлено
char Err[10]="не ошибка"; // длина строки меньше
                          // объявленной,
                          // остальные символы нули


                      Ввод и вывод символов и строк
    Для ввода и вывода текстовой информации инструмен-
тов довольно много, это функции библиотеки <stdio.h>.
    1. Форматированный ввод-вывод символов и строк.
    Используются функции форматированного ввода
printf(), scanf(). Управляющие форматы для символов —
%c, для строк — %s. При вводе строка вводится только до
первого пробела.
    2. Ввод-вывод символов.
    Используются функции getchar(), putchar(). Функция
getchar() читает из входного потока по одному символу за
обращение. Чтение данных начинается после нажатия
клавиши [Enter]. Функция putchar(символ) выводит сим-
вольное значение в стандартный выходной поток, обычно
это экран.
    3. Ввод-вывод строк.
    Используются функции gets(), puts(). Функция
gets(строка) читает из входного потока последователь-
ность символов до нажатия клавиши [Enter]. Чтение
180                                                    Гл а в а 2



начинается после нажатия клавиши [Enter]. Функция
puts(строка) выводит строку в стандартный выходной по-
ток.
    Прототипы функций:
char *gets(char *Str);		          // вернет NULL при ошибке
int puts(const char *Str)		       // вернет EOF при ошибке
   Пример 2.79. Пример использования функций ввода
и вывода строк.
#include <stdio.h>
void main(void)
{
  char Str[80];
  printf("Введите строку\n");
  gets(Str);
  printf("Введена строка:\n");
  puts(Str);
}
   Следующий пример покажет, как можно вводить стро-
ки при работе с текстом как с массивом строк.
   Пример 2.80.
#include <stdio.h>
void main(void){
  char text[3][20];
  for(int i=0;i<3;i++)
?? gets(text[i]);
}

                         Строки и указатели
     Особенности строк связаны с представлением их в па-
мяти как массивов однобайтовых переменных. Соотноше-
ние строк и указателей такое же, как соотношение ука-
зателей и массивов, но в конце строки есть нулевой байт
'\0'. Для статических строк память выделяется на этапе
компиляции программы, для динамических строк при
выполнении программы, но в любом случае массив дол-
жен где-то разместиться.
     Пусть есть два описания:
char Str1[20] ; // массив, в который можно записать строку
char *Str2;     // указатель, с которым можно связать строку
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   181


    Для статического массива Str1 память будет выделена
автоматически при обработке описания компилятором.
Строке, с которой можно связать указатель *Str2, память
не выделяется, поэтому, если далее следуют операторы:
gets(Str1);		                        // ошибки нет
gets(Str2);		                        // ошибка
    то первый из них допустим, а второй приведет к ошиб-
ке во время выполнения программы, так как gets() вводит
строку в участок памяти с неизвестным адресом. Перед
использованием строки следует связать адрес области па-
мяти, в котором может разместиться строка, с указателем
Str2. Во-первых, переменной Str2 можно присвоить адрес
уже определенного символьного массива. Во-вторых,
можно выделить динамическую память в требуемом раз-
мере с помощью операции new, а затем полученный адрес
связать с указателем Str2. Например:
Str2=Str1;     // указатель Str2 адресует строку Str1
Str2=new char[80];
    Во втором случае выделен блок памяти 80 байт и свя-
зан с указателем Str2. Строка не имеет собственного име-
ни, а имя указателя Str2 является его синонимом.
    Символьная строка, встреченная в выражении (на-
пример, Str1), — это адрес массива символов. Может
встречаться везде, где можно использовать указатель.
Для доступа к отдельным символам строк применяются
обычные механизмы прямой или косвенной адресации.
    Для прямой адресации используются индексы элемен-
тов массива. Выделим динамическую память для строки
Str2, и выполним копирование в нее исходной строки Str1
в цикле do, управляемом индексом. Реальное число сим-
волов в исходной строке, чаще всего, неизвестно, поэто-
му используется цикл с выходом по событию «достигнут
конец строки». Нулевой символ должен быть перенесен
в новую строку:
char Str1[80]="Первая строка.";
char *Str2;
Str2=new char[80];
// оператор do выполняет посимвольное копирование,
// перенесет нулевой байт в новую строку
182                                                    Гл а в а 2



i=0;
do
  Str2[i]=Str1[i];
while(Str1[i++]!='\0');   // проверка достижения конца строки
puts(Str2);
    Для косвенной адресации используются указатели
типа char * в качестве переменных, управляющих обра-
боткой строки. Текущий указатель будет адресовать ров-
но один символ строки, но в отладчике будет видна остав-
шаяся часть строки до нулевого байта '\0'. Покажем этот
механизм на примере.
    Пример 2.81.
char     *pts1, *pts2;
    Это рабочие переменные для косвенной адресации.
Управляет циклом переменная pts1. Ее начальное значение
равно адресу исходной строки Str1. *pts1 — это значение оче-
редного символа строки, pts2++ смещает указатель. Выход
из цикла происходит, когда найден признак конца строки:
char Str1[80]="Первая строка.";
char *Str2=new char[80];
char *pts1, *pts2;
pts1=Str1;
// подготовка цикла, это настройка указателей
pts2=Str2;
do
   *pts2++=*pts1; // сначала присваивание, затем смещение
while(*pts1++!='\0');
puts(Str2);
      В стиле C++ этот цикл выглядит так:
pts1=Str1;
pts2=Str2;
while((*pts2++=*pts1++));
puts(Str2);
    Большинство ошибок при работе со строками связа-
ны с механизмами выделения памяти для динамических
строк. Если при объявлении указателя текстовая строка
проинициализирована, то выделена память, равная дли-
не этой строки, и нельзя пытаться записать в эту строку
больше символов, чем выделено. Если же при объявлении
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   183


указателя текстовая строка не проинициализирована, то
память под запись строки вообще не выделена, и этот указа-
тель можно использовать только как рабочую переменную
для косвенной адресации при работе с какой-либо строкой.
   В примере 2.82 описан и проинициализирован одно-
мерный массив Rainbow[] указателей типа char*, каждый
элемент которого является строкой. Для вывода строк ис-
пользуется функция puts(), но и функция printf() со специ-
фикатором преобразования %s допускает использование
указателя на строку в качестве параметра. В выходной
поток выводится не значение указателя Rainbow[i], а со-
держимое адресуемой им строки.
   Пример 2.82.
#include <stdio.h>
void main(void)
{
// объявлен массив строк,
// каждое слово – название цвета радуги
// память выделена при инициализации
char *Rainbow[]={"Красный","Оранжевый","Желтый",
"Зеленый", "Голубой","Синий","Фиолетовый"};
   int i, len;
   len=sizeof(Rainbow)/sizeof(Rainbow[0]);
   // определена длина массива строк
   for(i=0;i<len;i++)
?? puts(Rainbow[i]);
}
   В результате выполнения программы мы увидим на
экране названия цветов радуги:
Красный
Оранжевый
     и т. д.

                     Строки как параметры функций
    Когда строка является параметром функции, то переда-
ча строки в функцию выполняется так же, как и для масси-
вов. Строка в качестве формального параметра в заголовке
функции описывается как одномерный массив типа char:
char Имя_строки[Константа];
184                                                Гл а в а 2



или как указатель типа char:
char *Имя_строки;
    Строка в качестве фактического параметра в вызы-
вающей программе может быть статической или дина-
мической. Всегда через параметр в функцию передается
адрес начала символьного массива, содержащего строку.
И функция, и вызывающая программа имеют одинако-
вые права на изменение содержимого строки.
    Отдельно передавать длину строки нет необходимо-
сти, так как, во-первых, строка имеет признак конца '\0',
который позволяет управлять циклами перебора симво-
лов строки, не выходя за ее пределы, а во-вторых, ее дли-
ну всегда можно определить, используя функцию strlen()
библиотеки <string.h>.
    Рассмотрим пример функции преобразования строки,
которая не изменяет размер строки, а только инвертирует
ее содержимое.
    Пример 2.83.
void invert(char Str[])
{
  char Buf;
  int i,j,m;
  for(m=0;Str[m]!='\0';m++);
  // переменная m найдет положение '\0'
  for(i=0, j=m–l;i<j;i++,j––)
  {
?? Buf=Str[i];
?? Str[i]=Str[j];
?? Str[j]=Buf;
  }
}
   Функция не возвращает значения, так как она изме-
нит содержимое строки, при этом символ '\0' остается на
своем месте в конце строки. Пример использования функ-
ции invert():
void main(void)
{
  char S[]="0123456789";
  // вызов функции
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   185


    invert(S);
    puts(S);
}
     Результат выполнения программы:
9876543210
   Для многих функций библиотеки <string.h>, а также
некоторых других, компилятор выдает предупрежде-
ния о том, что функция не является безопасной, напри-
мер:
warning C4996: 'strcpy': This function or variable may be unsafe.
   Предупреждение относится к улучшениям Microsoft
по безопасности функций стандартных библиотек. Дан-
ные предупреждения можно игнорировать по ряду при-
чин, например, безопасные функции при выполнении
требуют дополнительного времени на обеспечение безо-
пасности, что в общем случае не требуется.
   Для подавления этого предупреждения достаточно ди-
рективой #define определить макрос
_CRT_SECURE_NO_WARNINGS:
#define _CRT_SECURE_NO_WARNINGS

     2.7.7. Структуры
   Структура — это множество именованных данных,
объединенное в единое целое.

                  Определение. Описание структуры
    Как и массив, структура предназначена для логиче-
ского объединения данных в более крупные единицы, чем
данные простых типов. Массив всегда состоит из одно-
типных элементов, и все они имеют общее имя. Элементы
(компоненты, поля) структуры могут быть разных типов,
и все имеют различные имена.
    Описание структуры конструирует новый тип дан-
ного, объединяющий в себе разнотипные разноименные
компоненты, имеет синтаксис:
struct Имя_структурного_типа
{
// Определения элементов;
};      // ";" завершает описание
186                                                  Гл а в а 2



    Здесь struct — ключевое слово, обозначающее струк-
турный тип. «Имя_структурного_типа» — произвольное
имя, которое идентифицирует сконструированный тип;
«Определения элементов» (компонентов, полей) — описа-
ния объектов, входящих в состав структуры, каждый из
которых есть прототип одного из данных, входящих в со-
став вводимого структурного типа.
    Описание структурного типа заканчивается точкой
с запятой.
    Пример структуры «товар на складе»:
struct Goods
{
   char *name;      // наименование
   float price;     // оптовая цена
   float percent;   // торговая наценка в %
   int vol;         // объем партии товара
   char date[9];    // дата поставки партии товара
};
     Полное имя структурного типа «struct Goods». Это имя
является именем типа данного, который в общем виде
описывает объект «товар на складе». Наименование това-
ра будет связано с указателем типа char* и именем name,
оптовая цена единицы товара будет значением типа float
с названием price и т. д.
     Введенное описание структурного типа именует аб-
страктный тип данного, сконструированного програм-
мистом, и далее может использоваться для объявления
переменных этого типа, так же как для базовых типов
используются спецификаторы, например, double или
int.
     Синтаксис такого объявления:
struct Имя_структурного_типа Имя_переменной; // переменная
struct Имя_структурного_типа *Имя_переменной; // указатель
   Так вводятся фактические объекты указанного типа
или указатели на них.
   Например,
struct Goods        food;
struct Goods        *p_food;
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +         187


   Служебное слово typedef позволяет ввести собственное
обозначение для любого определения типа. Для структур-
ного типа синтаксис таков:
typedef struct
{
   // определения элементов;
}
// обозначение_структурного_типа;
     «обозначение_структурного_типа» — это абстрактное
имя типа, произвольно введенное программистом.
   Пример для того же объекта:
typedef struct
{
   char *name;		                     // наименование
   float price;		                    // оптовая цена
   float percent;		                  // торговая наценка в %
   int vol;		                        // объем партии товара
   char date[9];		                   // дата поставки партии товара
} Goods;
   Это описание вводит структурный тип struct{опре­
деления элементов}, и присваивает ему «обозначение_
струк­турного_типа» Goods. Обозначение имеет тот же
смысл, что и ранее (название, имя), и так же использует-
ся для объявления объектов структурного типа, но без ис-
пользования слова struct, например:
Goods food1, food2, food3;
    Объявлены три структуры: food1, food2, food3, каждая
из которых представляет реальный объект.
    Инструкция typedef назначает имя структурному
типу, который может в то же время иметь второе имя,
вводимое стандартным образом после служебного слова
struct. Это имя может быть синонимом первому.
typedef struct Merchandise
{
  char *name;		         // наименование
  float price;		        // оптовая цена
  float percent;		      // торговая наценка в %
  int vol;		            // объем партии товара
  char date[9];		       // дата поставки партии товара
188                                                   Гл а в а 2



} Goods;
    Здесь Goods — обозначение структурного типа, вве-
денное с помощью typedef, а имя Merchandise введено для
того же типа стандартным способом. После такого опреде-
ления структуры объекты этого типа могут вводиться как
с помощью названия struct Merchandise, так и с помощью
обозначения того же типа Goods.
    Изложенная последовательность определения струк-
тур (определить структурный тип, затем ввести пере-
менные этого типа) является самой логичной из всех, но
в языке С++ имеются еще две схемы определения данных
типа структура.
    Во-первых, структуры можно ввести в употребление
одновременно с определением структурного типа:
struct Имя_структурного_типа
{
// определения_элементов;
} Список_структур; // это имена переменных структурного типа
   Пример одновременного определения структурного
типа и объектов этого типа:
struct Student
{
   char name[15];		              // имя
   char surname[20];		           // фамилия
   int group;			                 // группа
} student_1, student_2, student_3;
     Здесь определен тип с именем Student и три объекта
этого типа student_1, student_2, student_3, которые явля-
ются полноправными объектами. В каждую из этих трех
структур входят элементы, позволяющие представить
имя (name), фамилию (surname), группу (group).
   После приведенного определения в той же программе
можно определять любое количество структур, используя
структурный тип Student:
struct Student   leader, freshman;
   Во-вторых, можно определять структуры, не вводя
названия типа. Безымянный структурный тип обычно ис-
пользуется в программе для однократного определения
структур:
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   189


struct
{
   // определения элементов;
} Список_структур;  // имена переменных структурного типа
   Пример безымянного структурного типа, описываю-
щего конфигурацию персонального компьютера:
struct
{
   char processor[10]; // тип процессора
   int frequency;		    // тактовая частота в МГц
   int memory;		       // объем основной памяти в Мбайт
   int disk; 		        // объем жесткого диска в Гбайт
} IBM_586, IBM_486, Compaq;
     Введены три объекта с именами IBM_586, IВМ_486,
Compaq. В каждую из них входят элементы, в которые
можно занести сведения о характеристиках конкретных
компьютеров. Структурный тип «компьютер» не имено-
ван, поэтому если в программе потребуется определять
другие структуры с таким же составом элементов, то при-
дется полностью повторить приведенное выше определе-
ние.
   Для работы с объектами структурного типа следует
объявлять переменные этого типа, например:
struct Merchandise dress, footwear, toy;
     Если имя структурного типа введено с помощью
typedef, то определение не содержит слова struct, напри-
мер:
Goods *food, *drink;
   Описание структурного типа не связано с выделением
памяти. Только при объявлении объекта типа структуры,
ему выделяется память в таком количестве, чтобы могли
разместиться данные всех элементов структуры. Реаль-
ный размер памяти в байтах, выделяемый для структу-
ры, можно определить с помощью операции sizeof:
sizeof(Имя_структурного типа);
или
sizeof(Имя_объекта_структурного_типа);
   Инициализация структур похожа на инициализацию
массивов. При объявлении объекта структуры в фигур-
190                                            Гл а в а 2



ных скобках после имени и знака присваивания размеща-
ется список начальных значений элементов, например:
struct Goods coat=
{
   "Черная шляпа",1000.00,15.0,100,"12.01.04"
};
     При этом элементы объекта coat получают соответ-
ствующие начальные значения.

               Операции над структурами.
               Доступ к элементам структур
   Для структур стандарт языка С++ разрешает присваи-
вание, если операнды являются однотипными. Для мас-
сива в целом операция присваивания не допускается.
struct Goods dress;
      Допустимо следующее присваивание:
dress=coat;
   Никакие операции сравнения для структур не опре-
делены. Сравнивать структуры следует только поэле-
ментно.
   Для доступа к элементам структур используется опе-
рация разыменования «точка» или уточненные имена по-
лей структуры.
   Синтаксис.
Имя_структуры.Имя_элемента
   Здесь «Имя_структуры» — это имя объекта структур-
ного типа, а «Имя_элемента» — это имя одного из эле-
ментов в соответствии с определением структурного
типа.
   Например, в примере с инициализацией структуры
типа struct goods:
   coat.name — указатель типа char* на строку «пиджак
черный».
   Перед точкой стоит имя конкретной структуры, для
которой при ее объявлении выделена память.

              Структуры, массивы и указатели
   Рассматривая соотношение между этими типами,
можно выделить возможные варианты.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   191

   Массивы и структуры в качестве элементов структур
    Массив, как и любые другие данные, может быть эле-
ментом структуры, тогда для обращения к каждому эле-
менту такого массива требуется операция разыменования
элемента массива [].
    Элементом структуры может быть другая структура, это
называется вложение структур. Например, структурный
тип для представления сведений о студенте, дополнительно
к тем элементам, которые уже есть (имя, фамилия, группа),
может содержать данное «дата рождения». Это может быть
структура с элементами «число», «месяц», «год».
    В тексте описания структурных типов должны быть
размещены в такой последовательности, чтобы использо-
ванный в описании структурный тип был уже определен
ранее:
struct Date		                        // тип "дата"
{
   int day;		                        // число
   int month;		                      // месяц
   int year;		                       // год
};
    При обращении к такому элементу операция «точ-
ка» используется дважды, так как имя поля нуждается
в уточнении дважды.
    Пример 2.84.
void main(void)
{
  // конкретная структура
  struct Student stud_1=
  {
?? "Павел","Колесников",145,22,04, 988
  };
  printf("\n Введите группу:");
  scanf("%d",&stud_1.group);
  printf("Сведения о студенте:");
  printf("\n Фамилия: %s", stud_1.surname);
  printf("\n Имя:%s", stud_1.name);
printf("\n Группа: %d\n", stud_1.group);
printf("\n Дата рождения: %d.%d.%d", stud_1.date.day,
192                                                    Гл а в а 2



???? stud_1.date.month, stud_1.date.year);
}
  Объект stud_1 типа struct Student получает значение
элементов при инициализации. Затем с помощью ввода
изменяется элемент stud.group, и содержимое структуры
выводится на экран. Для доступа к элементам вложенных
структур используются дважды уточненные имена.

                    Массивы структур
   Массивы структур вводятся в употребление так же,
как и массивы других типов данных, с указанием имени
структурного типа, например:
struct Goods   List[MAX];
     Определен массив List, состоящий из MAX элементов,
каждый из которых является структурой типа Goods. Имя
List, это имя массива, элементами которого являются струк-
туры. List[0], List[l] и т. д., все они структуры типа Goods.
     Для доступа к полям структур, входящих в массив
структур, используются уточненные имена с индексиро-
ванием первого имени (имени массива). Индекс записы-
вается непосредственно после имени массива структур,
например: List[0].price — элемент с именем price структу-
ры типа Goods, входящей в качестве элемента с нулевым
индексом в массив структур List[].
     При размещении в памяти массива структур элемен-
ты массива размещаются подряд в порядке возрастания
индекса. Каждый элемент массива занимает столько ме-
ста, сколько необходимо для размещения структуры.
     Как и массивы других типов, массив структур при
определении может быть инициализирован. Инициализа-
тор массива структур должен содержать в фигурных скоб-
ках список начальных значений структур массива. В свою
очередь, каждое начальное значение для структуры — это
список значений ее компонентов (также в фигурных скоб-
ках).

                 Указатели на структуры
   Указатели на структуры вводятся в употребление так
же, как и указатели на данные других типов.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +        193


     Например, для безымянных структурных типов:
struct Goods *p_goods;
struct
{ 			                                // безымянный структурный тип
   char processor[10];               // тип процессора
   int frequency;		                  // частота в МГц
   int memory; 		                    // память в Мбайт
   int disk;		                       // емкость диска в Мбайт
} *point_IBM, *point_2;
     Если название структурного типа введено с помощью
typedef, то объявление указателя выглядит как обычное
объявление указателя.
   При определении указателя на структуру он может
быть инициализирован. Наиболее корректно в качестве
инициализирующего значения применять адрес струк-
турного объекта того же типа, что и тип определяемого
указателя.
   Пример 2.85.
struct Particle
{
   double mass;
   float coord[3];
} dot[3], point, *p_point;
// инициализация указателей
struct Particle *p_d=&dot[0];
   Значение указателя на структуру может быть опреде-
лено и с помощью обычного присваивания:
p_point=&point;
   Если используется указатель на структуру, адресую-
щий конкретный объект, то доступ к ее элементам обеспе-
чивается с использованием операции косвенного разыме-
нования «стрелка (–>)», синтаксис которой:
Указатель_на_структуру–>Имя_элемента
    Операция имеет два операнда: «Указатель на структу-
ру», который адресует левый операнд, и «Имя элемента».
Тип результата операции «стрелка» совпадает с типом
правого операнда, т. е. того элемента структуры, на кото-
рый она нацелена. Имеет самый высший ранг, наряду со
скобками и операцией «точка» обеспечивает доступ к эле-
194                                                    Гл а в а 2



менту структуры через адресующий ее указатель того же
структурного типа.
   Пример 2.86.
p_point–>mass		         // эквивалентно (*p_point).mass
p_point–>coord[0]       // эквивалентно (*p_point).coord[0]
   Изменить значения элементов структуры можно, ис-
пользуя присваивание:
p_point–>mass=18.4;
for(int i=0;i<n;i++)
  p_point–>coord[i]=0.1*i;

                    Структуры и функции
   Возможны всего два варианта: структура может быть
передана функции как параметр, или структура может
быть значением, возвращаемым функцией. И в том, и в
другом случае могут использоваться указатели на объек-
ты структурных типов. Рассмотрим возможные вариан-
ты. Пусть есть структура:
struct Person
{
   char *name;
   int age;
};
   Покажем обязательные синтаксические конструк-
ции в прототипах функций, которые работают со струк-
турами:
   1) параметр функции — объект структурного типа:
void F1(struct Person Имя_объекта);
   2) параметр функции — указатель на объект струк-
турного типа:
void F2(struct Person *Имя_объекта);
      3) функция возвращает структуру:
struct Person F3(Список_параметров);
      4) функция возвращает указатель на структуру:
struct Person *F4(Список_параметров);
   Механизмы передачи параметров и возвращения зна-
чения функцией подробно рассмотрены в параграфе 2.5.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   195

     2.8. Файлы
    В языке С++ нет средств ввода-вывода. Этим обеспе-
чивается аппаратная независимость языка. Ввод-вывод
реализуется посредством библиотек стандартных функ-
ций. Библиотека stdio.h содержит средства ввода-вывода
(обмена с устройствами), в том числе с файлами на дис-
ке. С точки зрения языка нет разницы, с устройством или
файлом происходит обмен.
    Существует три уровня ввода-вывода:
  • верхнего уровня (потоковый);
  • записями (низкоуровневый);
  • для консоли и портов — системно-зависимый обмен.
    В данном пособии рассмотрим только работу с файлами.

     2.8.1. Определение и типы файлов
    Файл — именованная область внешней памяти, в кото-
рой содержится некоторая информация. Например, тексты
программ хранятся в виде текстовых файлов. Файлы так-
же могут хранить данные, а программы могут обращаться
к файлам данных для чтения информации или записи.
    Файлы удобно использовать, когда программа обрабаты-
вает большой объем информации, или когда данные должны
храниться на внешних устройствах, или когда данные мо-
гут быть исходными для нескольких программ обработки.
    Программы, которые работают с данными, хранящими-
ся в файле, временно размещают их в оперативной памяти.
Этот прием позволяет увеличить скорость обработки дан-
ных и снизить сложность программ. Данные из файлов, бу-
дучи прочитаны программой, становятся значениями объ-
ектов программы, например, массивами, матрицами и др.
    По механизму хранения данных и обращения к ним
файлы разделяются на файлы последовательного доступа
и файлы прямого доступа.
    Файлами последовательного доступа являются тек-
стовые файлы. Такие файлы подготавливаются в тексто-
вом редакторе и хранят данные в символьном представле-
нии. Их можно легко просматривать и редактировать, но
невозможно получить доступ к определенному данному,
пока не прочитаны все данные, находящиеся перед ним.
196                                                    Гл а в а 2



    Файл прямого доступа — это двоичный файл. Хранит
данные одного типа, не обязательно базового. Каждое дан-
ное хранится во внутреннем представлении, и его размер
определен типом данного. Чтобы получить любое данное,
можно переместить указатель файла непосредственно на
это данное, и выполнить операцию обмена.
    Программа, использующая файл данных, должна вы-
полнить следующие действия.
    1. Открыть (закрыть) поток — объявить указатель на
поток и связать его с физически существующим файлом.
    2. Передать данные в файл (из файла) — для этого су-
ществуют функции ввода-вывода.
    Кроме того, можно (и нужно).
    3. Отсекать ошибки обмена данными. Для этого пред-
назначены функции обработки ошибок.
    4. Управлять буфером обмена. Это исполняют функ-
ции буферизации потока.
    5. Для файлов прямого доступа существуют функции
перемещения указателя потока.
    6. И многое другое.

           Объявление файловой переменной
   Для объявления логического имени файла использу-
ется тип FILE, описание которого находится в библиотеке
<stdio.h>. FILE — это структура данных, которая хранит
данные о файле, такие как размер буфера и пр.
   Объявление файла:
FILE *Имя_файла;
    Здесь «Имя_файла», это имя переменной, связанной
с файлом, указатель на стандартную структуру данных
типа FILE.
   Это объявление аналогично объявлению обычных пе-
ременных:
   Например:
FILE *in, *out; // файл in для ввода, out для вывода
FILE *my_file; *my_other_file;
    Этот указатель можно назвать логическим именем
файла, под которым файл будет известен программе, и бу-
дет использоваться во всех последующих операциях.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   197

     2.8.2. Открытие и закрытие файлов
    Перед использованием файл следует открыть. Смысл
этой операции в том, чтобы связать логическое имя файла
с файлом, физически существующим на диске. Логиче-
скому имени файла присваивается значение, возвращае-
мое функцией fopen(). В случае ошибки открытия файла,
fopen() возвращает NULL. Функция имеет два параметра
строкового типа.
    Формат обращения к функции:
имя_файла=fopen("Имя_физического_файла","Режим_
открытия_файла");
     Пример 2.87.
in=fopen("input.txt","r");
out=fopen("output.txt","wb");
    «Имя_физического_файла» — это строка, значение ко-
торой определяет имя файла, возможно, с указанием пол-
ного пути к нему. «Режим_открытия_файла» — это строка,
определяющая режим доступа к потоку и тип файла, со-
держит один или два символа. Первый символ определяет
тип операций обмена.
    r — для чтения. Файл должен существовать на диске.
Логическое имя файла связывается с физическим име-
нем. Позиция чтения устанавливается перед первым бай-
том файла.
    w — для записи. Если файл существует на диске, то он
будет открыт для записи. Позиция записи устанавлива-
ется перед первым байтом файла. Если в файле была ин-
формация, она будет утеряна. Если файл не существует,
он будет создан.
    a — для добавления в конец. Если файл существовал
на диске, он будет открыт для записи. Позиция записи
устанавливается перед признаком конца файла. Если
файла не было, он будет создан.
    Признак + после типа файла, r+, w+, a+, расширяет
возможности операций обмена, модифицируя тип фай-
ла. С таким типом файл открывается как для чтения, так
и для записи.
    r+ — существующий файл открывается как для чте-
ния, так и для записи в любом месте файла. Запись в ко-
198                                                        Гл а в а 2



нец недопустима, так как недопустимо увеличение разме-
ра файла.
    w+ — новый файл открывается для записи и последу-
ющих изменений. Если файл существует, прежнее содер-
жимое стирается. Последующие операции записи и чте-
ния допустимы в любом месте файла, в том числе в конец,
т. е. размер файла может увеличиваться.
    a+ — файл открывается или создается и становится до-
ступным для изменений, т. е. для записи и чтения в любом
месте файла. В отличие от w+, при открытии существую-
щего файла его содержимое не уничтожается, в отличие
от r+ можно добавить запись в конец файла.
    Второй символ определяет тип файла, следовательно,
тип хранения данных.
    t — текстовый файл, действует по умолчанию.
    b — двоичный файл.
    Физический файл может находиться где угодно. Имя
файла можно указывать с полным путем. Если имя крат-
кое, файл будет отыскиваться только в текущем каталоге.
fopen("c:\\work\\f.txt","wt");
   Имя физического файла может изменяться, тогда па-
раметр функции fopen() должен быть переменной строко-
вого типа:
char *name_of_file=new char[50];
puts("Введите имя файла\n");
gets(name_of_file);
fopen(name_of_file,"wt"); // запишет в файл, который укажет
                          // пользователь при работе
   Как пример, приведем функции вывода одномерного
массива. Вывод массива на экран описан функцией Print_
mas, параметрами которой являются имя массива и его
длина.
   Пример 2.88.
#include <stdio.h>
// вывод массива на консоль
void Print_mas(int mas[],int len) // len – длина массива
{
   int i;
   printf("Массив:\n");
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   199


  for(i=0; i<len;i++)
?? printf("%5d", mas[i]);
  printf("\n");
}
    Если массив должен быть выведен в файл, то функ-
ция принимает еще один параметр — имя файловой пере-
менной FILE *out, а операция вывода printf заменяется на
fprintf.
// вывод массива в файл
void Print_mas(FILE *out,int mas[],int len)
{
   int i;
   fprintf(out, "Массив:\n");
   for(i=0;i<len; i++)
?? fprintf(out, "%5d", mas[i]);
   fprintf out, "\n");
}
    Файловая переменная объявляется в вызывающей
программе, связывается с файлом на диске и передается
функции как фактический параметр.
    Существуют некоторые обычные ошибки открытия
файла, например, файл не найден, диск заполнен, не-
достаточно динамической памяти для выполнения опе-
рации и пр. При любой ошибке открытия файла fopen()
возвращает NULL. Это используется для того, чтобы об-
рабатывать возможные ошибки ввода-вывода, используя
условный оператор. В случае возникновения одной из
штатных ошибок ввода-вывода, ее код errno распознает
и обрабатывает функция perror().
    Функция perror() возвращает сообщение об ошибке,
а fprintf() переназначает вывод строки сообщения об ошиб-
ке в стандартный поток stderr.
    Пример 2.89.
FILE *my_file;
if((my_file=fopen("f.txt","wt"))==NULL)
// текстовый файл для записи
{
   perror("Ошибка открытия файла");
   // если есть ошибка, ее код = errno,
200                                                Гл а в а 2



    // perror анализирует номер ошибки
    // и выводит поясняющий текст
    exit();
}
    Прототип функции perror() находится в директиве
препроцессора <stdio.h>. Там же определена переменная
errno типа int. Ею пользуются многие функции, в том чис-
ле функции ввода-вывода. Функция fopen(), обнаружив
ошибку, заносит ее код в переменную errno. Функция
perror() выводит на экран текстовую строку (свой аргу-
мент), затем двоеточие, пробел и сообщение об ошибке,
содержимое и формат которого определены реализацией.
    Если файл не найден, а ошибка не анализируется, по-
ток ввода перенаправляется на стандартный поток ввода-
вывода (консоль), с попыткой чтения из буфера обмена.
    Файл необходимо после использования закрыть. За-
крытие файла — это высвобождение логического имени
файла. Используется, чтобы отвязать логическое имя
от физического файла. Логическое имя не перестает су-
ществовать, и может быть использовано повторно для
других целей, например, для изменения режима работы
с файлом.
    Синтаксис.
fclose(имя_файла);
      Пример 2.90.
fclose(in);
fclose(out);
    При завершении работы программы все открытые
в ней файлы будут закрыты, даже если операция закры-
тия не была выполнена программистом. Если файл за-
крывает программист, то все данные из буфера выводят-
ся в файл перед его закрытием. Если же файл закрыва-
ется при завершении программы, то некоторые данные
могут быть потеряны вследствие механизма буфериза-
ции обмена.
    Признак конца файла (end-of-file) присутствует в кон-
це файла всегда. Чтобы его распознать в потоке, исполь-
зуется макроопределение feof. С его помощью можно про-
верить, найден ли в потоке признак конца файла.
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   201


     Объявление
int feof(FILE *stream);
   Как видим, тип возвращаемого значения int, следова-
тельно, данная функция возвращает целое значение (точ-
нее, логическое). Функция feof() проверяет данный поток
на наличие end-of-file в текущем положении указателя
потока. Возвращаемое значение отлично от нуля, если
при выполнении последнего оператора ввода для потока
найден end-of-file, и равно нулю, если end-of-file не обна-
ружен.
   Файл может хранить произвольное количество дан-
ных. При вводе данных из файла в массив можно опреде-
лить это число, тем самым узнать длину массива. Фак-
тическим признаком конца файла является сочетание
клавиш [Ctrl + Z]. Если данные вводятся в текстовом ре-
дакторе, этот признак невидим. При вводе данных с кла-
виатуры его можно ввести фактически.
   Пример 2.91.
   Пусть длина массива объявлена:
#define LEN_MAX                      100
   Это ограничение на длину необходимо учесть. Если
входных данных больше 100, длина массива будет огра-
ничена значением LEN_MAX. Если данных меньше, при-
знак конца файла ограничит ввод, и длина массива будет
равна числу данных во входном потоке. В этом примере
данные вводятся из входного потока stdin.
void Input_mas(FILE *in,int *mas,int &len)
{
   len=0;
   do
   {
?? scanf("%d", &mas[len]); // размер массива
?? len++;
   }
// в цикле выполняется ввод пока не встречен конец файла,
// или длина массива < 100
   while(!feof(stdin)&&len<LEN_MAX);
   len--;
}
202                                                     Гл а в а 2


      2.8.3. Чтение и запись для текстовых файлов
    Все функции ввода-вывода для консоли, которые были
рассмотрены ранее, работают по принципам потокового
ввода-вывода, используя стандартные текстовые потоки
stdin, stdout, srderr.
    При работе с текстовыми файлами используются функ-
ции библиотеки <stdio.h>, отличительным признаком ко-
торых является буква f в начале имени функции. Каждая
из них имеет дополнительный параметр — логическое имя
файла, для которого выполняется данная операция.
    Для чтения символов из файла:
int fgetc(FILE *stream);
int fputc(int C, FILE *stream);
     Функция fgetc() читает символ (int) из входного потока
stream.
     Функция fputc() выводит символ C в выходной поток
stream.
      Для чтения строк из файла:
char *fgets(char *s,int n,FILE *stream);
int fputs (const char *s,FILE *stream);
     Функция fgets() читает не более n–1 символа в строку s
(char *) из входного потока stream. Константа n определят
наибольшее количество считываемых символов. Чтение
происходит до обнаружения признака новой строки или
конца файла. Если символов меньше, будет прочитано их
реальное количество.
    Функция fputs() выводит строку s в выходной поток
stream. Возвращает число записанных символов.
    Для форматированных данных:
fprintf(Имя_файла,"форматная_строка",список_вывода);
fscanf(Имя_файла,"форматная_строка",список_ввода);
    Здесь «Имя_файла» — логическое имя файла.
    Пример 2.92.
    В качестве примера приведем функции чтения из фай-
ла двумерного массива, и вывода матрицы в файл.
// чтение матрицы из файла
// в первой строке файла первые два числа
// обозначают размер матрицы
void Read_matr(FILE *in,int matr[][10],int &n,int &m)
Ос н о в ы п р о г р а м м и р о ва н и я н а я з ы к е C + +   203


{
   fscanf(in,"%d",&n); // Количество строк
   fscanf(in,"%d",&m); // Количество столбцов
   int i, j;
   for(i=0;i<n;i++)
?? for(j=0;j<m;j++)
??? fscanf(in,"%d",&matr[i][j]);
}
// вывод матрицы в файл
void Print_matr(FILE *out,int matr[][10],int n,int m)
{
   int i, j;
   for(i=0;i<n;i++)
   {
?? for(j=0;j<m;j++)
??? fprintf(out,"%6d", matr[i][j]);
   fprintf(out,"\n");
   }
}
     Некоторые функции библиотеки <stdio.h> для рабо-
ты с файлами в новых версиях языка относятся к небез-
опасным. Компилятор выдает предупреждение, в кото-
ром рекомендует использовать безопасную версию, как
правило, имеющую префикс _s, например, вместо fopen()
использовать fopen_s(). Можно использовать безопасные
функции, или подавлять предупреждения директивой
#define _CRT_SECURE_NO_WARNINGS

     Вопросы для самопроверки
1. Определите назначение и правила записи имен в языке С++.
2. Дайте определение и назначение констант. Как определяет-
   ся тип константы?
3. Перечислите типы данных. Что такое явное и неявное преобра-
   зование типов? Какова роль объявления типов в программе?
4. Поясните роль определения переменной в программе.
5. Почему происходит преобразование типов при присваива-
   нии? Поясните механизм преобразования типов.
6. Какова структура программы на языке С++?
7. Что такое директивы препроцессора? Поясните назначение
   и механизм действия директив #define и #include.
204                                                     Гл а в а 2


8. Каково назначение операторов языка программирования?
    Приведите примерную классификацию операторов языка
    С++.
9. Поясните цель использования функций при составлении
    программного кода. Почему функции имеют тип, и какого
    типа может быть возвращаемое функцией значение? Как
    функция возвращает значение?
10. Чем описание функции отличается от ее объявления? Когда
    функцию можно только описать, а когда функцию следует
    объявить?
11. Чем передача параметров по ссылке отличается от передачи
    параметров по значению?
12. Что такое время жизни имени? Как область действия имени
    зависит от времени ее жизни?
13. Как передаются в функцию массивы?
14. Укажите особенности передачи в функцию строк.
15. Дайте определение массива как производного типа дан-
    ных. Какие характеристики массива должен указать про-
    граммист при его использовании в программе?
16. Поясните отличия между статическим и динамическим мас-
    сивами. Как выделяется память для хранения статических
    и динамических массивов?
17. Что такое указатель? Когда он используется? Поясните осо-
    бенности переменной «указатель».
18. Какие операции выполняются над указателями? Почему су-
    ществуют ограничения?
19. Как применяются указатели для работы с массивами? Что
    такое косвенная адресация в массивах?
20. Что такое строка? Каковы особенности их представления?
21. Как создаются динамические строки?
22. Что такое структура? Чем структуры как тип данных отли-
    чаются от массивов? Как структуры используются в каче-
    стве параметров функций?
23. Что называется файлом? Когда они используются?
24. Какие действия следует выполнить при использовании фай-
    ла? Что такое логическое имя файла и как оно связано с фи-
    зическим именем?
25. Какие существуют типы операций обмена с файлом? Как
    тип операции обмена задается в программе?
26. Всегда ли необходимо закрывать файл после его использова-
    ния? Если файл не закрыт, то что с ним происходит?
                                                Гл ава 3

                        Задачи и упражнения




   Тема 1. Простые программы на языке С++

П    ростыми можно считать такие задачи, у которых ал-
     горитм решения линейный, т. е. все действия выпол-
няются в порядке записи описывающих их операторов.
Простые задачи сводятся к линейному процессу со сле-
дующими основными пунктами:
  • ввести исходные данные;
  • выполнить вычисления по формулам;
  • вывести результат.
    Последовательность решения должна складываться
из следующих этапов.
    1. Анализ условия задачи.
    2. Определение необходимых входных данных: сколь-
ко их, какого типа каждое данное, какое имя следует при-
своить переменной, обозначающей данное. Тип перемен-
ной должен быть определен в объявлении, а имя должно
быть значимое, т. е. подчеркивать назначение перемен-
ной, ее логический смысл.
    3. Определение выходных данных программы: сколь-
ко их, какие типы, как назвать переменные для обозначе-
ния результатов.
    4. Определение списка рабочих переменных, если не-
обходимо.
    5. Определение необходимых формул вычисления, их
последовательности и правил записи.
    6. Кодирование алгоритма.
    При кодировании необходимо соблюдать синтаксиче-
ские правила и следить за стилем программирования. Эти
требования можно сформулировать следующим образом.
206                                                 Гл а в а 3



    1. Объявить все переменные программы.
    2. Правильно оформить ввод данных. Перед каждым
оператором ввода необходимо записать инструкцию, ко-
торая подскажет пользователю, что он должен сделать
в данный момент времени.
    3. Правильно записать формулы вычислений.
    4. Грамотно оформить вывод результата. Вывод сле-
дует дополнить необходимыми заголовками и пояснения-
ми, числовые данные форматировать.
    Пример 1.1. Пусть требуется вычислить длину окруж-
ности, площадь круга и объем шара одного и того же ра-
диуса.
    Опишем последовательность решения.
    1. Анализ алгоритма показывает, что он линейный.
    2. Входная переменная одна, это значение радиуса,
в общем случае величина вещественная. Обозначим его
именем r.
    3. Выходных данных три. Обозначим их именами l, s,
v. Все переменные имеют вещественный тип.
    4. Формулы вычислений общеизвестны.
#include <stdio.h>
// библиотека стандартного ввода-вывода
#include <math.h>
// библиотека математических функций
#define PI 3.1415926 // значение константы ?
void main(void)
{
   float r; 		           // объявление всех переменных
   float l, s, v;
   printf("\nДлина окружности, площадь круга и объем шара
:\n");
   // вывод заголовка
   printf("\nВведите значение радиуса:\n");
   // приглашение для ввода данных
   scanf("%f", &r);      // ввод исходного данного
   // вычисления по формулам:
   l=2.*PI*r;
   s=PI*r*r;
   v=4.*PI*r*r*r/3.;
За д ач и и у п р аж н е н и я                                    207


   // Вывод результатов
   printf("r=%6.2f, l=%6.2f, s=%6.2f, v=%6.2f\n ", r, l, s, v);
} // End of main
    Многие ошибки начинающих программистов вызваны
незнанием информации о типах данных. Объявление пе-
ременной в программе указывает ее имя и тип. Тип пере-
менной определяет способ хранения переменной, а имен-
но сколько памяти выделено для переменной и как ее зна-
чение размещено в этом объеме. Тип также определяет
диапазон значений, которые может принять переменная,
и операции, которые можно к ней применить. Способ хра-
нения переменных вещественного типа (double, float) ра-
дикально отличается от способа хранения данных целых
типов (int, char). Тип констант, если они есть в тексте про-
граммы, определяется их записью. Так константа 2 будет
целочисленной, а константы 2.0 или 2. будут веществен-
ными. При вычислении значений выражений, в которых
смешаны данные разных типов, выполняется преобразо-
вание (приведение) типов. Например, если в программе
объявлены целочисленные переменные:
int a=1, b=2;
float f;
и выполнено деление, а значение присвоено переменной
вещественного типа:
f=a/b;
то результат будет равен 0.0, потому что сначала выпол-
няется целочисленное деление, а потом присваивание.
Чтобы результат был равен 0.5, нужна запись с использо-
ванием явного преобразования типов:
f=(float)a/float(b);
   Пример 1.2. Особенности, связанные с преобразовани-
ем типов, рассмотрим на следующем примере. Дано зна-
чение угла, измеренное в градусах, минутах и секундах.
Требуется перевести значение угла в радианную меру.
Формула вычисления:
                                          ?град ? 360
                                 ?рад =               .
                                             2??
// программа имеет скрытую ошибку
208                                                     Гл а в а 3



  #include <stdio.h>
  #include <math.h>
  void main(void)
  {
  int Grad, Min, Sec;   // исходные данные всегда целые
  float GRAD;		         // новая переменная для
			                     // вычисления полного значения угла
  float Rad;		          // итоговое значение
  printf("Введите значение угла в градусах, минутах
и секундах:\n");
  scanf("%d%d%d", &Grad, &Min, &Sec);
  // полное значение угла:
  GRAD=Grad+Min/60+Sec/3600;
  // перевод в радианы:
  Rad=Grad*M_PI/360; // константа M_PI объявлена в
<math.h>.
  printf("Значение угла в радианах: %12.6f\n",Rad);
  } // End of main
    Для проверки стоит выполнить два тестовых примера,
вот их результаты:
Введите значение угла в градусах, минутах и секундах:
2 0 0
Значение угла в радианах: 0.017453
Введите значение угла в градусах, минутах и секундах:
1 59 59
Значение угла в радианах: 0.008727

   Жирным начертанием выделены результаты решения
задачи. Как видим, почти одинаковые входные данные
дают разные результаты. Источником ошибки величи-
ной в один градус является строка, вычисляющая полное
значение угла. При делении чисел целого типа результат
равен нулю, поэтому значения минут и тем более секунд
отброшены при вычислении GRAD.
   Для устранения ошибки используется явное преобра-
зование типов.
#include <stdio.h>
#include <math.h>
void main(void)
За д ач и и у п р аж н е н и я                          209


{
   int Grad, Min, Sec;
   float Rad;
   float GRAD;
   printf("Введите значение угла в градусах, минутах
и секундах\n");
   scanf("%d%d%d", &Grad, &Min, &Sec);
   // полное значение угла:
   GRAD=(float)Grad+(float)Min/60.+(float)Sec/3600.;
   // перевод в радианы
   Rad=GRAD*M_PI/360;
   printf("Значение угла в радианах=%12.6f\n",Rad);
} // End of main
    Пример 1.3. Рассмотрим особенности вычислений с ис-
пользованием данных целого типа. Сформулируем содер-
жательную задачу. Пусть для покупки подарков выделе-
на некоторая сумма в рублях. Требуется узнать, сколько
можно купить подарков, если известна цена одного подар-
ка, и определить, сколько денег останется. Наоборот, если
нужно купить N подарков, то найти наибольшую стои-
мость одного подарка и количество оставшихся денег.
    Приведем решение задачи в целых числах.
#include <stdio.h>
void main(void)
{
  int Sum;          // выделена сумма денег
  int Cost;         // стоит один подарок
  int Cou;          // количество, которое можно купить на
эту сумму
  int N;            // количество, которое хочется купить
  int Rest;         // останется денег
  printf("Введите сумму и цену одного подарка\n");
  scanf("%d%d", &Sum, &Cost);
  // найдем количество и остаток:
  Cou=Sum/Cost; // целочисленное деление
  Rest=Sum%Cost; // остаток от деления
  printf("Можно купить %d подарков, останется %d рублей.
                                             \n",Cou,Rest);
  // найдем стоимость и остаток
210                                                     Гл а в а 3



   printf("Сколько подарков хочется купить?\n");
   scanf("%d", &N);
   Cost=Sum/N;
   Rest=Sum % N);
   printf("Наибольшая стоимость подарка %d\n",Cost);
   printf("Останется %d рублей.\n", Rest);
} // End of main
    Замечание. Операции целочисленного деления и вы-
числения остатка от деления можно применять только
к данным целых типов. Если такие операции нужно вы-
полнить для данных вещественных типов, используются
функции ceil, floor, fmod библиотеки <math.h>. Функция
ceil округляет вещественное число вверх, функция floor
округляет вниз, а функция fmod находит остаток от де-
ления по модулю. Все функции имеют аргументы типа
double и возвращают значение типа double. Приведение
типа при переходе от float к double необязательно, так как
не приведет к потере данных.
    Рассмотрим тот же пример с использованием веще-
ственного типа данных. Все денежные суммы должны
вычисляться в рублях и копейках, следовательно, пере-
менные Sum, Cost и Rest имеют вещественный тип. При
вычислениях необходимо округление вниз для получе-
ния целочисленного значения и округление с точностью
до копеек. Деление должно быть по модулю.
    Теперь покажем решение этой же задачи в веществен-
ных числах.
#include <stdio.h>
#include <math.h>
void main(void)
{
  float Sum; // выделена сумма денег
  float Cost; // стоит один подарок
  int Cou;    // количество, которое можно купить на эту сумму
  int N;      // количество, которое хочется купить
  float Rest; // останется денег
  printf("Введите сумму и цену одного подарка\n");
  scanf("%f%f", &Sum, &Cost);
  // найдем количество и остаток
За д ач и и у п р аж н е н и я                          211


   Cou=(int)floor(Sum/Cost);
   // целое число получено округлением вниз
   Rest=fmod(Sum, Cost); // остаток от деления.
   printf("Купили %d подарков, останется %6.2f рублей.\n",
          Cou, Rest);
   // найдем стоимость и остаток
   printf("Введите число подарков, которое хочется
          купить\n");
   scanf("%d", &N);
   Cost=Sum/(float)N;
   // точность вычислений должна быть 0,01
   Cost=floor(Cost*100)/100.;
   Rest=fmod(Sum, Cost);
   printf("Наибольшая стоимость подарка %6.2f руб.\n",
          Cost);
   printf("Останется %6.2f руб.\n", Rest);
} // End of main
   Важное замечание. Если этот пример получить как
точную копию первого, то хорошо будет работать только
первая формула вычислений. Вторая даст ошибку, вы-
званную наличием погрешности вычислений, которая
должна быть менее одной копейки. Для устранения по-
грешности добавлена строка
Cost=floor(Cost*100)/100.;
     О смысле этой строки предлагается подумать читателю.

                                 Варианты заданий
    Задание 1. Даны длины катетов прямоугольного тре­
угольника. Найти его острые углы, вывести в градусной
мере с точностью до минут. Указание: функция arctg объ-
явлена в библиотеке <math.h>.
    Задание 2. Даны длины катетов прямоугольного тре-
угольника. Найти его периметр и площадь. При выводе
округлить до двух знаков.
    Задание 3. Дан положительный угол в радианах. Най-
ти, сколько градусов и минут содержит данный угол.
    Задание 4. Дано вещественное число. Найти и напеча-
тать его целую, дробную части и округленное значение.
Использовать функции округления.
212                                                   Гл а в а 3



    Задание 5. Камень бросили вверх со скоростью V.
Определить расстояние от земли в некоторые моменты
времени t1 и t2. Вывести с точностью 2 знака.
    Задание 6. Даны координаты точек A(x1, y1) и B(x2, y2)
гиперболы y = k/x + b. Найти и напечатать значения k, b.
    Задание 7. От полуночи минутная стрелка описала
угол K градусов (целочисленное значение). Определить,
какое время (ч, мин) показывают часы. Указание: ис-
пользовать операции целочисленного деления.
    Задание 8. Даны значения переменных A и B. Найти
частное от деления А на В и частное от деления В на А.
Найти остаток от деления А на В и остаток от деления В на
А. Найти вещественные значения дробей A/B и B/A.
    Задание 9. Даны координаты левой верхней и правой
нижней вершин квадрата. Найти длину стороны квадра-
та, найти длину диагонали, найти координаты точки пе-
ресечения диагоналей квадрата.
    Задание 10. Две прямые на плоскости проходят через
начало координат и точки A(x1, y1) и В(x2, y2). Найти в гра-
дусной мере с точностью до градусов угол наклона биссек-
трисы угла, образованного прямыми.
    Задание 11. Дано натуральное четырехзначное число.
Найти сумму его цифр. Указание: использовать операции
целочисленного деления.
    Задание 12. Определить, как наименьшим числом ку-
пюр можно выдать сумму K руб. (K < 9999), если есть ку-
пюры достоинством 1000 руб., 500 руб., 100 руб., 50 руб.
и 10 руб. Оставшуюся мелочь выдать рублями.
    Задание 13. Камень бросили в колодец, через t сек по-
слышался всплеск. Определить расстояние от сруба до
воды.
    Задание 14. Две прямые на плоскости заданы своими
уравнениями. Известно, что они пересекаются. Найти ко-
ординаты точки пересечения заданных прямых.
    Задание 15. На плоскости задан треугольник координа-
тами своих вершин. Найти длины сторон треугольника.
    Задание 16. На плоскости заданы два луча, выходя-
щие из начала координат под углами ? и ? к оси 0х. Найти
в градусной мере с точностью до градусов углы наклона
За д ач и и у п р аж н е н и я                      213


биссектрисы угла, образованного лучами, а также угол
между лучами.
    Задание 17. Зарплата сотрудника складывается из
ставки минимальной зарплаты, умноженной на разряд-
ный коэффициент (вещественное значение в диапазоне от
1 до 3), уральского коэффициента (15%) и премии (в %).
Из зарплаты вычитается подоходный налог (12%). Вво-
дя необходимые исходные данные, вычислить и вывести
зарплату сотрудника в рублях.
    Задание 18. Известно, что прямая, заданная уравне-
нием y = Kх + b, пересекает оси координат в точках А и
В. Найти координаты точек пересечения, вывести с точ-
ностью 2 знака после запятой.
    Задание 19. Участок земли треугольной формы имеет
длины сторон L1, L2, L3. Найти площадь этого участка,
вывести с точностью 2 знака после запятой.
    Задание 20. Прямоугольной формы строительный
блок имеет ширину w, высоту h и глубину l. Найти объем
и площадь поверхности строительного блока.
    Задание 21. Прямоугольной формы строительный
блок имеет ширину w, высоту h и глубину l. Найти, сколь-
ко блоков войдет в квадратный контейнер с длиной сто-
роны L.
    Задание 22. В первый день тренировок спортсмен про-
бежал 10 км. Каждый день он пробегает на 10% больше,
чем в предыдущий день. Найти и вывести на экран путь,
пройденный спортсменом во второй, третий и четвертый
дни тренировок.
    Задание 23. В пачке N листов бумаги размера А4 плот-
ностью Р г/см2. Найти вес пачки бумаги с точностью 2
знака после запятой.
    Задание 24. Известны стоимость конфет, печенья
и яблок. Найти общую стоимость покупки, если куплено
X кг конфет, Y кг печенья и Z кг яблок.
    Задание 25. Известны стоимость системного блока,
монитора, клавиатуры и мыши. Найти, во сколько обой-
дется покупка N компьютеров.
    Задание 26. Известно, что для кормления одного ла-
бораторного животного нужно K1 г корма для мыши, K2 г
214                                                Гл а в а 3



корма для крысы, K3 г корма для морской свинки. Найти,
сколько съедят в день X мышей, Y крыс, Z морских сви-
нок. Найти, сколько корма нужно в месяц.
    Задание 27. В подарке 2 шоколадки по цене K1 руб.,
2 яблока по K2 руб. и коробка печенья стоимостью K3 руб.
Найти, сколько будут стоить N подарков.
    Задание 28. В очереди к врачу N человек. Врач бе-
седует с пациентом примерно 15 мин. Если сейчас 12 ч,
а до бассейна бежать 30 мин, стоит ли занимать очередь,
если надо успеть на сеанс в X ч (сеансы начинаются каж-
дый час)?
    Задание 29. Одна жемчужина диаметром d стоит Cost
руб. Сколько будет стоить ожерелье на шею, обхват кото-
рой D см?
    Задание 30. Летит стая гусей, а навстречу ворона. Во-
рона говорит: «Как много вас, гусей, наверное, N?», на
что вожак отвечает: «Если взять нас столько, и еще пол
столько, и четверть столько, то будет N». Сколько же гу-
сей в стае? Иметь в виду, что гуси и вороны считают не
очень хорошо, и N не может быть любым.

      Тема 2. Использование условного 
      оператора if и переключателя switch
    Условный оператор if изменяет последовательность
выполнения операторов программы в зависимости от
условий, сложившихся при ее выполнении. Классиче-
ская схема оператора if в С++ предполагает разветвление
на две ветки, одна из которых может быть пустой. В более
сложных случаях, когда проверяется множество условий,
используются сложные (вложенные) условные операторы
или сложные логические выражения.
    Оператор переключатель switch используется для
тех же целей, но позволяет организовать множествен-
ное ветвление. Если оператор if может передать управ-
ление только на две ветви, то switch на произвольное
число ветвей.
    Пример 2.1. Требуется найти корни квадратного урав-
нения вида ax2 + bx + c = 0. Выполним этапы решения.
За д ач и и у п р аж н е н и я                        215


    1. Анализ условия задачи. Квадратное уравнение мо-
жет иметь одно или два решения или не иметь их вообще.
Результат решения зависит от определителя уравнения,
вычисляемого по формуле d = b2 – 4ac.
    2. Входными данными являются коэффициенты урав-
нения a, b, c. Чтобы уравнение осталось квадратным, пер-
вый коэффициент должен быть отличен от нуля. Имена
переменных, обозначающих коэффициенты, могут совпа-
дать с их математической записью, т. е. a, b, c. Тип коэф-
фициентов вещественный.
    3. Выходными данными программы будут значения
корней уравнения, если их удастся найти по формулам
       b2 ± d
x1,2 =        . Если же корней нет, об этом следует напе-
         2?a
чатать сообщение.
    4. Для вычисления и хранения значения определите-
ля требуется ввести новую переменную, которая не явля-
ется результатом решения задачи, но необходима для ее
решения. Такие переменные называются рабочими пере-
менными программы. Обозначим ее буквой d, как и в по-
становке задачи.
    5. Определение необходимых формул вычисления
очевидно.
    6. Кодирование алгоритма. При выполнении алгорит-
ма можно выполнить предварительное словесное описа-
ние:
  • ввести значения коэффициентов (названы a, b, c);
  • вычислить дискриминант (назван d);
  • если дискриминант отрицательный, решения нет, вы-
    вести сообщение;
  • если дискриминант больше или равен 0, решение есть,
    вычислить значения корней и вывести на печать.
    В первой ветви условного оператора нужно выполнить
не одно, а три действия, поэтому используется блок {...},
который показывает компилятору, что эти действия сле-
дует воспринимать как единое целое.
#include <stdio.h>
#include <math.h>
void main(void)
216                                                    Гл а в а 3



{
   float a, b, c, d;
   float x1, x2;
   // ввод входных данных
   printf("\nВведите коэффициенты квадратного
уравнения.\n");
   scanf("%f%f%f", &a, &b, &c);
   d=b*b–4*a*c;              // вычисление дискриминанта d
   if(d>=0.0)
?? {
??? x1=(–b+sqrt(d))/(2.*a); // вычисление корней
??? x2=(–b–sqrt(d))/(2.*a);
??? printf("Корни равны x1=%6.2f x2=%6.2f\n", x1, x2);
?? }
   else
??? printf("Корней нет\n"); // печать сообщения
} // End of main
   В этом примере не предусмотрен случай равных кор-
ней, например, при a = 2, b = 4, c = 2. Для того чтобы отсле-
дить этот случай, потребуется внести изменение в текст
программы.
   Пример 2.2. Когда для принятия решения требуется
проверка более одного условия, появляется множествен-
ное ветвление. В данном примере следует предусмотреть
случай равных корней, при этом в условном операторе по-
является второе условие d = 0, а значит, и второй оператор
проверки условия.
   Схема алгоритма условно может быть изображена
так:
if(d>0)
{
   // блок операторов, чтобы вычислить два корня
}
else
if(d==0)
{
   // блок операторов, чтобы вычислить один корень
}
   else
За д ач и и у п р аж н е н и я                          217


  {
?? // вывод сообщения о том, что решения нет
  }
   Структура ветвления рассматривает только взаимо­
исключающие варианты. Выполнение оператора if при ис-
пользовании многих условий, если они не выделены блоком,
разворачивается по принципу матрешки, т. е. каждый else
принадлежит ближайшему сверху if. Отступы в тексте про-
граммы позволяют лучше увидеть логику выбора решения.
#include <stdio.h>
#include <math.h>
void main(void)
{
   float a, b, c, d;
   float x1, x2;
   printf("\nВведите коэффициенты квадратного уравнения\n");
   scanf("%f%f%f", &a, &b, &c);
   d=b*b–4*a*c;
   if(d>0.0)
   {
??? x1=(–b+sqrt(d))/(2.*a);
??? x2=(–b–sqrt(d))/(2.*a);
??? printf("Корни равны x1=%6.2f x2=%6.2f\n", x1, x2);
   }
?? else
?? // d имеет вещественное значение,
?? // сравнивать его с нулем можно только
?? // с некоторой степенью точности, например, так:
?? // |d|<0.00001
?? if(fabs(d)<=0.00001) // приблизительно равен нулю
?? {
??? x1=(–b+sqrt(d))/(2.*a);
??? printf("Корни одинаковы x1=x2=%6.2f\n", x1);
?? }
?? else
??? printf("Корней нет\n");
} // End of main
   Пример 2.3. Диалог с программой в общепринятом виде.
Для полного тестирования программы, алгоритм которой
218                                                   Гл а в а 3



проверяет множество условий, нужно выполнить столько
примеров, сколько вариантов ветвления возможно. В про-
грамме примера 2.2 нужно выполнить три тестовых приме-
ра. Кроме того, пользователь с помощью программы может
решать несколько уравнений. Поэтому необходимо уметь
организовать многократное обращение к программе.
    Для организации повторного выполнения програм-
мы или ее фрагмента используется циклический алго-
ритм. Этот цикл будет управляться внешним событием.
Событие порождает пользователь, нажимая клавишу на
клавиатуре. Общепринято использовать клавишу [Esc]
для завершения процесса, а для продолжения клавишу
[Enter] или любую другую.
    Кроме того, при вводе данных необходимо предусмо-
треть, чтобы введенное значение коэффициента а было бы
отлично от 0. Проверка выполняется в цикле сразу же по-
сле ввода данных. Цикл будет повторен всегда, когда вве-
денное значение не соответствует правилам, и только при
правильных данных программа продолжит работу.
// пример диалога в общепринятом виде
// для управления используется оператор do…while
// с выходом по условию "нажата клавиша [Esc]".
#include <stdio.h>
#include <math.h>
#include <conio.h> // библиотека консольного ввода-вывода
#define ESC 27       // код клавиши [Esc] в символьном виде
void main(void)
{
   float a, b, c, d;
   float x1, x2;
   char key;         // переменная key для обработки события
   // первое выполнение алгоритма обязательно,
   // поэтому необходим цикл do...while
   do
   {
?? // проверка корректности вводимых данных
?? // если значение а близко к нулю, цикл ввода повторяется
?? do
?? {
За д ач и и у п р аж н е н и я                           219


??? printf("\nВведите коэффициенты квадратного
??? уравнения\n");
??? scanf("%f%f%f", &a, &b, &c);
?? } while(fabs(a)<0.001)
?? // ввод выполнен правильно
?? d=b*b–4*a*c;
?? if(fabs(d)<>0.00001)
?? {
??? x1=(–b+sqrt(d))/(2.*a);
??? printf("Корни одинаковы x1=%6.2f x2=%6.2f\n", x1, x2);
?? }
?? else
??? if(d>0.0)
??? {
???? x1=(–b+sqrt(d))/(2.*a);
???? x2=(–b–sqrt(d))/(2.*a);
???? printf("Корни равны x1=%6.2f x2=%6.2f\n", x1, x2);
??? }
?? else
??? printf("Корней нет\n");
?? // обработка события "нажатие клавиши"
?? printf("Клавиша [ESC] – завершение работы,
????? Any Key – продолжение...");
?? // ожидание события "нажатие клавиши"
?? key=getch(); // функция getch() читает код клавиши
   } while(key!=ESC )
   // код клавиши Esc прописан в директиве define
} // End of main
   Пример 2.4. Использование вложенных условных опе-
раторов в программах с проверкой многих условий. При-
мером сложного выбора является оценка знаний ученика
по результатам тестирования. Пусть известен результат
ЕГЭ (от 0 до 100 баллов). Оценка по пятибалльной шкале
должна быть выставлена по правилам:
                             ?2, если       ЕГЭ ? 40;
                             ?3, если 40 < ЕГЭ ? 60;
                             ?
                    Оценка = ?
                             ?4, если 60 < ЕГЭ ? 80;
                             ??5, если 80 < ЕГЭ ? 100.
220                                                Гл а в а 3



   В записи этих правил есть избыточность с точки зре-
ния механизмов выполнения условного оператора. Вет-
вление — это взаимоисключающие варианты, значит,
в первой ветви истинность условия ЕГЭ <= 40 означа-
ет получение результата. Если же это условие ложно,
то к проверке второго условия 40 < ЕГЭ <= 60 прихо-
дят только те значения ЕГЭ, которые не удовлетворяют
первому условию, т. е. только ЕГЭ > 40, а значит их не
нужно включать в запись условия. Так же и в записи
всех последующих условий. Логика вложенных опера-
торов условия присоединяет каждый else к ближайшему
сверху if.
#include <stdio.h>
#include <conio.h>
void main(void)
{
   int Test;		           // ЕГЭ
   int Ball;		           // оценка
   do
   {
?? printf("Введите результат ЕГЭ испытуемого\n");
?? scanf("%d", &Test);
?? if(Test<=40)
??? Ball=2;
?? else
??? if(Test<=60)
????? Ball=3;
??? else
???? if(Test<=80)
?????? Ball=4;
??? else
??????? Ball=5;
?? printf("Оценка в аттестате: %d\n", Ball);
?? printf("Если больше нет испытуемых, нажмите ESC\n");
   } while(getch()!=27);
} // End of main
   Обратите внимание, что цикл по-прежнему управля-
ется событием, но в этом примере вспомогательная пере-
менная key не используется.
За д ач и и у п р аж н е н и я                       221


    Пример 2.5. Использование сложных логических вы-
ражений в программах с проверкой многих условий.
    Использование множественных вложений операто-
ров условия затрудняет «читабельность» программы. За-
частую его можно избежать, объединяя простые условия
в логические выражения везде, где для поиска решения
требуется проверка более
одного условия. Пусть тре-
буется проверить, принад-
лежит ли точка с произволь-
ными координатами (x, y)
некоторой области, напри-
мер, заштрихованной обла-
сти, изображенной на рисун-
ке 3.1.
    Известны длина стороны
                                         Рис. 3.1
квадрата (обозначим L) и ра-    Иллюстрация к примеру 2.5
диус окружности (обозна-
чим R), где не обязательно L>R, т. е. область может быть
пустой.
    Запишем условие математически с помощью системы
неравенств:
                                 x 2 + y2 ? R 2
— условие «точка находится вне окружности»;
                                  ?| x | < L ,
                                  ?        2
                                  ?
                                  ?| y | < L
                                  ?        2
— условие «точка находится внутри квадрата».
   Для соблюдения условия нужно, чтобы все три нера-
венства выполнялись одновременно, поэтому при объеди-
нении их в одно требуется использовать логическую опе-
рацию «И» (конъюнкция) следующим образом:
x*x+y*y>=R*R && fabs(x)<0.5*L && fabs(y)<0.5*L
     Тогда условный оператор запишется:
if(x*x+y*y>=R*R && fabs(x)<0.5*L && fabs(y)<0.5*L)
   printf("Точка принадлежит области \n");
222                                              Гл а в а 3



else
  printf("Точка не принадлежит области \n");
   Если не использовать сложное выражение, то прихо-
дится применять вложенные операторы условия следую-
щим образом:
if(x*x+y*y>=R*R)
   if(fabs(x)<0.5*L)
?? if(fabs(y)<0.5*L)
??? printf("Точка принадлежит области \n");
?? else
??? printf("Точка не принадлежит области \n");
    Квалифицированный программист отдаст предпочте-
ние первому способу.
    Пример 2.6. Использование оператора переключателя
switch для организации множественного ветвления. Опе-
ратор switch использует для управления значение выраже-
ния целочисленного (символьного) типа, и позволяет вы-
брать один из нескольких возможных вариантов ветвле-
ния алгоритма. Покажем, как можно использовать этот
оператор для управления алгоритмом с консоли, напри-
мер, при организации меню пользователя. Значение кода
нажатой пользователем клавиши управляет выбором вет-
ви алгоритма. Код клавиши возвращает функция getch().
Если нажата одна из функциональных (управляющих)
клавиш, то функция возвращает 0 (0хЕ0). Ее повторный
вызов получает расширенный код клавиши.
void main(void)
{
  int key;
  do
  {
?? printf("Выберите действие\n");
?? key=getch();
?? if(key==0)    // нажата управляющая клавиша
?? {
??? key=getch();
??? // ввод не повторяется, символ получен
??? // из буфера ввода
??? switch key // значение key управляет ветвлением
За д ач и и у п р аж н е н и я                       223


??? {
???? case 77: {printf("Стрелка вправо\n"; break;)}
???? case 75: {printf("Стрелка влево\n"; break;)}
???? case 72: {printf("Стрелка вверх\n"; break;)}
???? case 80: {printf("Стрелка вниз\n"; break;)}
???? case 27: {printf("Esc\n"; break;)}
???? default: {printf("Не стрелка\n"; }
??? }
?? }
   } while(key!=27); // выход из цикла по нажатию Esc.
} // End of main
     Оператор break в каждой ветви передает управление
на оператор, следующий за switch. Если break опущен, то
после ветви, на которую пал выбор, выполняются все опе-
раторы, стоящие далее в тексте switch.

                                 Варианты заданий
   Задание 1. Прямая L, заданная на плоскости коорди-
натами двух точек (a, b) и (c, d), разбивает координатную
плоскость на две полуплоскости. Известны также коорди-
наты двух точек (x1, y1) и (x2, y2), не лежащих на данной
прямой.
   Определить, находятся ли точки в разных полупло-
скостях или в одной, и напечатать сообщение. Иметь воз-
можность повторного обращения в диалоге.
   Задание 2. Составить программу для определения кор-
ней системы двух линейных алгебраических уравнений по
правилу Крамера. Решение вывести в виде системы уравне-
ний. Иметь возможность повторного обращения в диалоге.
   Задание 3. Дано натуральное число N, в записи кото-
рого ровно пять знаков.
   Определить, является ли это число палиндромом или
нет, напечатать сообщение текстом. Значение числа вво-
дить в диалоге, иметь возможность повторного обращения.
   Задание 4. Дано натуральное число N, определяющее
возраст человека в годах.
   Дать для этого числа наименование «год», «года» или
«лет». Например, «Вам 21 год» или «Вам 43 года». Иметь
возможность повторного обращения в диалоге.
224                                                  Гл а в а 3



    Задание 5. Окружность на плоскости с центром в на-
чале координат имеет радиус R. Известны также коорди-
наты концов некоторого отрезка (x1, y1) и (x2, y2).
    Определить, пересекает ли отрезок окружность
и сколько раз. Значения координат вводить в диалоге,
иметь возможность повторного обращения.
    Задание 6. Даны длины трех отрезков.
    Определить, можно ли построить треугольник с та-
кими длинами сторон. Если да, то определить, какой это
треугольник: прямоугольный, остроугольный или тупо­
угольный. Значения длин вводить в диалоге, иметь воз-
можность повторного обращения.
    Задание 7. Заданы декартовы координаты точки на
плоскости.
    Перевести в полярные координаты с учетом номера
четверти, где находится точка. Угол перевести в градус-
ную меру с точностью до минут. Значения вводить в диа-
логе, иметь возможность повторного обращения.
    Задание 8. По введенным координатам точки (x, y)
определить номер четверти координатной плоскости, где
находится точка.
    Значения координат вводить в диалоге, иметь возмож-
ность повторного обращения.
    Задание 9. На плоскости заданы три точки своими ко-
ординатами.
    Определить расстояния от точек до начала координат
и напечатать, какая из точек расположена ближе к нача-
лу координат. Значения вводить в диалоге, иметь возмож-
ность повторного обращения.
    Задание 10. Дано натуральное число N, в записи кото-
рого ровно пять знаков.
    Определить, имеет ли это число одинаковые цифры
или нет. Значение числа вводить в диалоге, иметь воз-
можность повторного обращения.
    Задание 11. Окружность с центром в начале коорди-
нат имеет радиус 1.
    Определить, пересекает ли прямая y = kx + b окруж-
ность или хотя бы касается один раз. Значения k и b вводить
в диалоге, иметь возможность повторного обращения.
За д ач и и у п р аж н е н и я                             225


    Задание 12. На плоскости заданы два квадрата коор-
динатами левого верхнего угла и длинами сторон.
    Определить, пересекаются ли они. Значения вводить
в диалоге, иметь возможность повторного обращения.
    Задание 13. На плоскости задано кольцо с центром
в начале координат и радиусами r1 и r2, где r1 < r2. Дана
точка своими координатами (x, y).
    Определить, находится ли точка внутри кольца. Зна-
чения вводить в диалоге, иметь возможность повторного
обращения.
    Задание 14. Прямоугольной формы кирпич имеет сто-
роны A, B, C.
    Определить, пройдет ли кирпич в прямоугольное от-
верстие размером 5?8. Значения вводить в диалоге, иметь
возможность повторного обращения.
    Задание 15. Даны четыре числа.
    Определить, являются ли они элементами арифмети-
ческой прогрессии. Значения вводить в диалоге, иметь
возможность повторного обращения.
    Задание 16. На плоскости задан треугольник длинами
своих сторон.
    Вычислить его медианы:

                       ma = 0.5 ? 2 ? b2 + 2 ? c2 ? a2 ;
                       mb = 0.5 ? 2 ? a2 + 2 ? c2 ? b2 ;
                       mc = 0.5 ? 2 ? b2 + 2 ? a2 ? c2
и найти наибольшую. Значения длин сторон вводить в ди-
алоге, иметь возможность повторного обращения.
    Задание 17. Прямоугольной формы контейнер име-
ет размеры 8?8?12, где 12 — высота контейнера. Дано K
прямоугольных блоков размером n?n?2n.
    Определить, войдут ли эти блоки в контейнер. Если не во-
йдут, то определить, сколько останется. Размер блоков вво-
дить в диалоге, иметь возможность повторного обращения.
    Задание 18. На плоскости заданы три точки своими
координатами.
    Определить длины сторон охватывающего их прямоу-
гольника наименьшего размера. Пусть его стороны парал-
226                                              Гл а в а 3



лельны координатным осям. Значения координат вводить
в диалоге, иметь возможность повторного обращения.
    Задание 19. На плоскости задан квадрат координата-
ми левого верхнего угла и длиной стороны. Задан также
отрезок координатами концов.
    Определить, находится ли отрезок полностью внутри
квадрата или один его конец внутри, или отрезок полно-
стью снаружи. Значения вводить в диалоге, иметь воз-
можность повторного обращения.
    Задание 20. На плоскости задан треугольник коорди-
натами своих вершин.
    Найти наибольшую из сторон треугольника. Значения
координат вводить в диалоге, иметь возможность повтор-
ного обращения.
    Задание 21. Дано цилиндрическое ведро радиусом r
и высотой h. Требуется с его помощью переместить K л
жидкости из одной емкости в другую.
    Определить, можно ли это сделать за одно действие.
Если нет, то определить, сколько раз нужно воспользо-
ваться ведром. Размеры вводить в диалоге, иметь возмож-
ность повторного обращения.
    Задание 22. На плоскости заданы три точки своими
координатами.
    Определить, сколько из них и какие находятся внутри
окружности, для которой известны радиус и координаты
центра. Все значения вводить в диалоге, иметь возмож-
ность повторного обращения.
    Задание 23. Даны прямоугольная коробка размером
w?w?h1 и цилиндрическое ведерко радиуса основания r
и высотой h2.
    Найти, какая емкость больше по объему. Значения
вводить в диалоге, иметь возможность повторного обра-
щения.
    Задание 24. Дано числовое значение денежной суммы
не более 100 рублей.
    Вывести значение числа прописью, например, «2 ру-
бля», «12 рублей», «51 рубль». Анализировать остаток
от деления на 10. Так, для остатка равного 1 наименова-
ние «рубль», для остатка равного 2, 3, 4 наименование
За д ач и и у п р аж н е н и я                        227


«­рубля», для остатка, равного 5, 6, 7, 8, 9, 0 наименова-
ние «рублей». Числа второго десятка — исключение. Зна-
чение денежной суммы вводить в диалоге, иметь возмож-
ность повторного обращения.
    Задание 25. У каждого из трех братьев есть некоторая
сумма денег. Они решили поделить их поровну.
    Определить, кто из них и кому должен передать какую
сумму. Значение сумм вводить в диалоге, иметь возмож-
ность повторного обращения.
    Задание 26. В продаже есть два вида системных бло-
ков по цене K1 и K2 руб., и три вида мониторов по цене
М1, М2 и М3 руб. Известны также стоимость клавиатуры
и мыши.
    Найти, сколько будет стоить самый дешевый компью-
тер и сколько самый дорогой. Значения стоимостей вво-
дить в диалоге, иметь возможность повторного обраще-
ния.
    Задание 27. При кормлении одного лабораторного жи-
вотного нужно в день K1 калорий для мыши, K2 калорий
для крысы. Есть корма калорийностью P1 по цене Х1 руб.,
P2 по цене X2 руб. и P3 по цене X3 руб. за кг.
    Подобрать самый дешевый дневной рацион для X мы-
шей и Y крыс. Значения данных вводить в диалоге, иметь
возможность повторного обращения.
    Задание 28. Для одного подарка выделено K руб.
В подарок можно положить яблоки по цене K1 руб.,
апельсины по цене K2 руб. и печенье по цене K3 руб. за
штуку. В подарок каждый из предметов должен войти
хотя бы один раз. Если получается, то по два одинако-
вых или по три.
    Найти состав подарка. Найти сумму, которая останет-
ся от покупки. Значения данных вводить в диалоге, иметь
возможность повторного обращения.
    Задание 29. Даны два интервала числовой оси [a1, b1]
и [a2, b2].
    Найти соотношение интервалов: пересекаются или
нет, первый принадлежит второму или наоборот. Значе-
ния вводить в диалоге, иметь возможность повторного об-
ращения.
228                                              Гл а в а 3



   Задание 30. Окружность на плоскости с центром в на-
чале координат имеет радиус 1. Известны координаты ле-
вого верхнего угла квадрата со стороной 1.
   Определить, принадлежит ли окружности хотя бы
одна вершина квадрата. Значения вводить в диалоге,
иметь возможность повторного обращения.

      Тема 3. Инструменты С++ для реализации
      циклических алгоритмов
    Если какой-либо фрагмент алгоритма должен быть
выполнен многократно, то это циклический алгоритм
(цикл).
    Циклические алгоритмы можно условно разделить на
две группы.
    1. Арифметический цикл, у которого заранее известно
число повторений.
    2. Итерационный цикл, у которого заранее неизвестно
число повторений.
    Управление циклом выполняет некоторая перемен-
ная величина, которая называется «параметр цикла»
или «управляющая переменная». Это переменная про-
граммы, которая, как правило, изменяется в теле цикла,
определяет число повторений цикла и позволяет вовремя
завершить его работу.
    Можно выделить четыре составные части цикла.
    1. Подготовка цикла: присваивание начальных значе-
ний переменным, в том числе параметру цикла.
    2. Тело цикла: фрагмент, который должен быть повто-
рен многократно.
    3. Изменение параметра цикла: как правило, выпол-
няется в теле цикла.
    4. Проверка условия завершения цикла: в проверке
условия, явно или нет, используется параметр цикла.
    Не всегда эти составляющие присутствуют явным об-
разом.
    В С++ существуют три вида операторов цикла, кото-
рые одинаково можно применять для организации любо-
го циклического алгоритма.
За д ач и и у п р аж н е н и я                      229


1. while:
while (условие)
{ // количество повторений любое
?Тело цикла
}

2. do…while:
do
{ // количество повторений любое
?Тело цикла
}
while (условие);

3. for:
(объявление параметра цикла)
{ // количество повторений фиксировано
?Тело цикла
}
    Пример 3.1. Алгоритм построения таблиц значений
различных функций. Это чаще всего арифметический
цикл. Обычно параметром цикла является аргумент
функции. Для функции задана формула вычисления зна-
чения y(x) = F(x). Известны диапазон изменения аргумен-
та x ? [x0, xn] и шаг изменения ?x.
    Общая схема этого алгоритма на основе цикла while...
do выглядит так:
// печать заголовка таблицы
х = x0;		       // подготовка цикла
while(x<=xn)    // проверка условия завершения
{
   y=F(x);      // алгоритм вычисления значения
		              // вывод строки таблицы
   x+=?x;       // приращение управляющей переменной
}		             // выход из цикла
     Общая схема этого алгоритма на основе цикла do...
while выглядит так:
// печать заголовка таблицы
х = x0;		       // подготовка цикла
do
230                                                    Гл а в а 3



{
  y=F(x);       // алгоритм вычисления значения
		              // вывод строки таблицы
  х += ?x;      // приращение управляющей переменной
}
while(x<=xn);   // проверка условия завершения
   Общая схема этого алгоритма на основе цикла for вы-
глядит так:
// печать заголовка
for(x=x0; x<=xn; x+=?x)
// все составляющие цикла в заголовке
{
   y=F(x);		            // алгоритм вычисления значения
			                     // вывод строки таблицы
}
   Пример 3.2. Функция F(x) может быть достаточно
сложной, тогда в теле цикла нужно позаботиться о пра-
вильной записи блока, вычисляющего функцию. Пусть
для x ? [–?/2; +?/2] требуется вычислить таблицу значе-
ний функции, имеющей разрыв в точках |x| = ?/4, по фор-
муле
                        ?               ?
                        ??sin x для x < 4 ;
                 y(x) = ?
                         ?cos x для x >= ? .
                         ??               4

#include <stdio.h>
#include <math.h>
// в библиотеке math.h определена константа
// M_PI – значение числа ?
void main(void)
{
   float x, y;				
   // аргумент и значение функции
   // вывод шапки таблицы в текстовом режиме экрана
   printf("\n Таблица значений функции\n");
   printf("------------------------------------\n");
   printf("		               x        y        \n");
За д ач и и у п р аж н е н и я                         231


   printf("------------------------------------\n");
   // x – параметр цикла, в заголовке цикла for
   // задано полное управление
   for(x=–M_PI/2.; x<=M_PI/2.; x+=0.2)
   // цикл вычисления таблицы
   {
?? // блок вычисления значения функции использует
оператор if
?? // if(fabs(x)<=M_PI/4.)
??? // логическая запись формулы вычисления
??? y=sin(x);
?? else
??? y=cos(x);
?? printf("%11.2f %11.2f\n" ,x, y);
?? // вывод строки таблицы
   }
} // End of main
    Пример 3.3. Итерационный цикл. Если в формулиров-
ке задачи явно или неявно присутствуют условия «пока
не будет выполнено» или «до тех пор, пока не выполне-
но», то число повторений заранее неизвестно, и это ите-
рационный процесс. Содержание тела цикла может быть
произвольным. Для организации таких алгоритмов ис-
пользуются, как правило, циклы while или do... while.
    Пример использования цикла, управляемого собы-
тием, уже был ранее показан в примерах 2.3 и 2.6 (гла-
ва 2). Еще раз покажем, как использовать цикл do...
while для проверки корректности ввода. Если програм-
ма дружественна пользователю, то при вводе данных
она сначала подскажет, что и как следует вводить, за-
тем выполнит проверку введенных значений и в случае
ошибки будет возвращать пользователя к этапу ввода
данных.
    Требуется найти площадь треугольника, построенно-
го по значениям длин трех заданных отрезков. Известно,
что треугольник существует только тогда, когда длина
каждой его стороны меньше, чем сумма длин двух других
сторон. Если введенные данные не удовлетворяют этому
условию, ввод повторяется.
232                                                    Гл а в а 3



#include <stdio.h>
#include <conio.h>
#include <math.h>
void main(void)
{
   float a, b, c;		     // длины сторон треугольника
   float S;		           // площадь треугольника
   // цикл проверки корректности введенных данных
   do
   //до получения корректных данных
   {
?? printf("Введите длины сторон треугольника\n");
?? scanf("%f%f%f", &a, &b, &c);
?? // тут может появиться ошибка ввода данных
   } while(!(a<b+c&&b<a+c&&c<a+b));
// данные введены корректно
   float pp;
   pp=(a+b+c)/2.;
   S=sqrt(pp*(pp–a)*(pp–b)*(pp–c));
   printf("Площадь треугольника равна: %6.2f\n",S);
} // End of main
    Пример 3.4. Программист, организуя управление ите-
рационным циклом, должен позаботиться и об инициа-
лизации управляющей переменной, и об ее приращении,
и об условии завершения цикла.
    Сформулируем условие задачи. Мяч брошен верти-
кально вверх со скоростью V. Требуется построить табли-
цу зависимости высоты Y от времени t, начиная с момента
броска до момента падения мяча на землю, если
                                       g ? t2
                     Y (t) = V ? t ?          ,
                                         2
где g — константа тяготения, равная 9,8.
    При движении мяч сначала взлетает вверх, затем
падает. Высота подъема и время полета мяча зависят от
начальной скорости броска. Очевидно, что циклом вы-
числения должна управлять переменная t. Для нее из-
вестно начальное значение (t = 0). Шаг изменения можно
оценить из физического смысла задачи и выбрать произ-
За д ач и и у п р аж н е н и я                            233


вольно, например, t = 0,1 с. Момент завершения вычисле-
ний неизвестен в числовом выражении, но известно, что
значение высоты сначала будет возрастать, затем убывать
и при падении мяча на землю станет равно нулю: Y <= 0.
Величина Y — прямая функция t, значит, в этом условии
переменная t присутствует, но неявно. Поскольку в по-
становке задачи условие завершения звучит «до момента
падения», кажется естественным выбрать цикл do.
#include <stdio.h>
#include <conio.h>
#define G 9.8
void main(void)
{
float V, y, t;
printf("Введите значение скорости броска\n");
scanf("%f", &V);
printf("Таблица зависимости высоты от времени Y(t)\n");
printf("------------------------------------\n");
printf(" t        y(t)     \n");
printf("------------------------------------\n");
// подготовка цикла. Момент времени t = 0.1
t=0.1;
do		              // выбран цикл do
{
   y=V*t–0.5*G*t*t;
   printf("\t %6.2f \t %6.2f \n", t, y);
   t+=0.1;        // переход на новую итерацию
} while(y>=0); // в условии t присутствует неявно
getch();		        // для задержки таблицы на экране
} // End of main
    Замечание. Этот вариант имеет недостаток. Послед-
нее значение таблицы будет отрицательным, потому что
точного совпадения координаты y с нулем не будет никог-
да, а цикл do проверяет условие завершения после печати
строки таблицы. Чтобы избежать этой некорректности,
следует выбрать цикл while, в котором отчетливо пропи-
сать условие завершения цикла: while(V*t–0.5*G*t*t>=0).
    В рассмотренных примерах циклические алгоритмы
являются простыми. Сложным (вложенным) циклом
234                                                  Гл а в а 3



называется такой, у которого содержанием циклически
выполняемого фрагмента является также циклический
алгоритм. Типы циклических алгоритмов внешнего
и внутреннего циклов при этом могут быть любыми.
Внутренний цикл, от подготовки до завершения, должен
находиться внутри внешнего, точнее, быть его телом.
    Пример 3.5. Сложный арифметический цикл. Функ-
ция двух переменных F(x, y) или функция с параметром
F(А, x) порождает необходимость использования сложно-
го арифметического цикла тогда, когда оба аргумента из-
меняются. Здесь решается задача полного перебора, т. е.
нахождения всех возможных значений функции при всех
возможных значениях ее аргументов.
    При решении таких задач необходимо выделить обе
управляющие переменные, описать закон их изменения
и выбрать, какая из них по логике задачи главная или
условно главная. Главная переменная будет параметром
внешнего цикла, другая переменная будет параметром
внутреннего цикла. Для каждого зафиксированного
значения главной переменной другая переменная долж-
на пробегать все значения своего диапазона. В сложном
арифметическом цикле можно строить таблицу значений
функции вида F(x, y) для всех возможных значений x и y.
Чтобы значение параметра внешнего цикла не повторя-
лось во многих строках таблицы, его следует выводить
однократно во внешнем цикле как заголовок таблицы.
    Пусть требуется вычислить объемы нескольких ци-
линдрических емкостей:
                                    2
                      V = H ?? ? ? ? ,
                                  d
                                 ?2?

где H — высота; d — диаметр основания цилиндра.
    Высота может изменяться в диапазоне H ? [–1; 5],
?H = 1, а диаметр в диапазоне d ? [0.5; 3.5], ?d = 0.5. Пе-
ременные равноправны, поэтому внешним циклом может
быть любой. Пусть это высота, тогда для одного фиксиро-
ванного значения высоты нужно выводить таблицу значе-
ний функции F(d).
За д ач и и у п р аж н е н и я                          235


#include <stdio.h>
#include <conio.h>
#include <math.h>
void main(void)
{
   float d, h;     // диаметр основания и высота емкости
   float V;        // объем емкости
   // управление внешним циклом, параметр h
   for(h=1.; h<=5.; h+=1.)
   {
   printf("Таблица зависимости объема от диаметра
???? основания\n");
   printf("-----------------------------\n");
?? printf(" Высота = %6.2f\n", h);
?? printf("        d        V        \n");
?? printf("-----------------------------\n");
?? // управление внутренним циклом, параметр d
?? for(d=0.5; d<=3.5; d+=0.5)
?? {
??? V=M_PI*pow(0.5*d, 2.);
??? printf("%6.2f \t %6.2f \n", d, V);
?? }
?? getch();        // удержание экрана после вывода таблицы
?? }
} // End of main
    Очистка экрана перед выводом очередной таблицы
функцией clrscr() не является необходимой. В этом вариан-
те на очередном экране мы будем видеть одну таблицу для
одного значения высоты. Если убрать эту строку, то табли-
цы будут выводиться подряд одна за другой. Удержание
экрана после вывода очередной таблицы обязательно, так
как программа выводит данных больше, чем вмещается на
один экран.
    Пример 3.6. Сложный (вложенный) цикл, управ-
ляемый событием. Изменим текст примера 3.3, добавив
к нему цикл многократного повторения. Новый внешний
цикл просто охватывает весь текст старой программы
и позволяет в диалоге управлять ее многократным повто-
рением.
236                                                   Гл а в а 3



#include          <stdio.h>
#include          <conio.h>
#include          <math.h>
void main(void)
{
float a, b, c;    // длины сторон треугольника
float S, pp;      // S – площадь, pp – полупериметр
// цикл, управляющий процедурой
// многократных вычислений
do
{
   // цикл проверки корректности введенных данных
   do
?? {
??? printf("Введите длины сторон треугольника\n");
??? scanf("%f%f%f", &a, &b, &c);
?? } while(!(a<b+c&&b<a+c&&c<a+b));
   pp=(a+b+c)/2.;
   S=sqrt(pp*(pp–a)*(pp–b)*(pp–c));
   printf("Площадь треугольника равна: %6.2f\n",S);
   // управление внешним циклом
   printf("Если больше нет треугольников, нажмите ESC\n");
   } while(getch()!=27);
} // End of main
    Пример 3.7. В сложном цикле типы алгоритмов могут
быть произвольными. Оба цикла могут быть одного типа,
или внешний цикл может быть итерационным, а внутрен-
ний арифметическим, или наоборот. Изменим пример 3.4,
использующий итерационный цикл, добавив необходимость
исследования решения задачи для различных значений
стартовой скорости V. Пусть V может изменяться в диапазо-
не V ? [–1; 7] c шагом 1. Как видно из постановки задачи, ее
решение должно быть повторено многократно по правилам
арифметического цикла. Переменная V из простой превра-
щается в управляющую. Текст примера нужно изменить до-
бавлением к нему управления по переменной V во внешнем
цикле, при этом запись внутреннего цикла не изменится.
#include <stdio.h>
#include <conio.h>
За д ач и и у п р аж н е н и я                              237


#define G 9.8
void main(void)
{
   float V, y, t;
   // управление внешним циклом, параметр V
   for(V=1; V<=7.; V+=1.)
   {
   printf("Таблица зависимости высоты от времени
???? при V=%6.2f\n", V);
?? printf("-----------------------------\n");
?? printf("        t      y(t)     \n");
?? printf("-----------------------------\n");
?? // управление внутренним циклом, параметр t
?? // подготовка цикла. Момент времени t=0.1
?? t=0.1;
?? while(V*t–0.5*G*t*t>=0)
?? {
??? y=V*t–0.5*G*t*t;
??? printf("\t %6.2f \t %6.2f \n", t, y);
??? t+=0.1; // переход на новую итерацию
?? }
   getch();       // для удержания таблицы на экране
   }
} // End of main


                                 Варианты заданий
   Задание 1. Составить программу, вычисляющую та-
блицу значений функции
                             ?sin x + а, при x < 0;
                             ?
                      y(x) = ?cos ? ? x, при 0 <= x <= 2;
                             ?a2 + x2 , при x > 2,
                             ?

если х ? [–4; 4] с шагом 0,3. Параметр а принимает значе-
ния 1.2, 1.3, 1.4, 1.5, 1.6. Для каждого значения параме-
тра построить отдельную таблицу y(x).
   Задание 2. Составить программу, вычисляющую та-
блицу значений функции
238                                                  Гл а в а 3



                  ? 2 ? x3
                  ?? x2 + 1 , при х < 3;
           y(x) = ?
                   ?1.5 ? tg ? , для остальных x,
                   ??         x

если х ? [–6; +6] с шагом 0.5.
    Задание 3. Напечатать в возрастающем порядке все
трехзначные числа, в десятичной записи которых нет
одинаковых цифр. Иметь возможность повторного обра-
щения в диалоге.
    Задание 4. Составить программу, которая находит
наибольший общий делитель двух натуральных чисел a
и b по следующему алгоритму: до тех пор, пока a и b не
сравняются, вычитать a = a – b при a > b, или b = b – a при
b > a. Исходные числа вводить в диалоге, иметь возмож-
ность повторного обращения.
    Задание 5. Натуральное число является простым, если
оно делится на 1 и на самого себя. Натуральное число яв-
ляется совершенным, если оно равно сумме своих делите-
лей, включая 1, например:
                     6 = 1 + 2 + 3;
                     28 = 1 + 2 + 4 + 7 + 14.
    Составить программу, которая определит, является
ли некоторое число N простым, а если нет, то является ли
оно совершенным. Иметь возможность повторного обра-
щения в диалоге.
    Задание 6. Для любого действительного числа x вы-
числить значение f(x), где f — периодическая функция
с периодом Т = 2, совпадающая на отрезке [0, 1] c функ-
цией y(x) = x2 – 2,25x, а на отрезке [1, 2] с функцией
y(x) = x – 1.25.
    Проверить в цикле на интервале x ? [–4; 4] для четно-
го числа точек.
    Задание 7. Натуральное число является простым, если
оно делится только на 1 и на самого себя. Составить про-
грамму, которая найдет все простые числа от N1 до N2
включительно. Иметь возможность повторного обраще-
ния в диалоге.
За д ач и и у п р аж н е н и я                                239


    Задание 8. Составить программу для проверки знания
таблицы умножения для столбца N, где N = 2, 3, ..., 10
(выбирать в диалоге).
    Подсчитать правильные ответы, выставить оценки: «от-
лично», «хорошо», «удовлетворительно» или «неудовлет-
ворительно» за 10, 9, 8, 7 и менее ответов соответственно.
Иметь возможность повторного обращения в диалоге.
    Задание 9. Составить программу для проверки навыков
сложения и вычитания. Программа в диалоге генерирует
необходимую процедуру «+» или «–» и два операнда, за-
тем спрашивает сумму или разность. При правильном отве-
те печатать поощрительный текст и предлагать повторить
ввод, иначе печатать сообщение об ошибке и предлагать по-
вторить ввод результата до получения правильного ответа.
    Задание 10. Для любого действительного x вычислить
значение f(x), где f —периодическая функция с периодом
T = 2.5, совпадающая на отрезке [0, 1] c функцией y(x) = x2,
а на отрезке [1, 1.5] с функцией y(x) = –x.
    Проверить на интервале x ? [–3; 5], взять не менее 10
точек.
    Задание 11. Для любого натурального числа N найти
все такие натуральные числа x и y, для которых выполня-
ется N = x2 + y2. Иметь возможность повторного обраще-
ния в диалоге.
    Задание 12. Найти все целочисленные координаты то-
чек, попадающих в круг радиуса R с центром в точке (A, B).
Иметь возможность повторного обращения в диалоге.
    Задание 13. Составить программу для вычисления та-
блицы значений функции
                                 U(y) = 16 + y + y2,
где
                             ?
                             ?5 ? x2 ? 0,5, при x <= 0;
                             ?
                     y(x) = ?3 ? x2 + 4 ? x, при 0 < x < 3;
                            ? 2 1
                            ??x ? x , при x >= 3,

если x ? [–2; 4], шаг 0.25.
240                                                   Гл а в а 3



   Задание 14. Найти все натуральные числа от N1 до N2,
запись которых есть палиндром. Иметь возможность по-
вторного обращения в диалоге.
   Задание 15. Найти все натуральные числа от N1 до N2,
запись которых совпадает с последними цифрами записи
их квадрата, например: 62 = 36, 252 = 625 и т. д. Иметь воз-
можность повторного обращения в диалоге.
   Задание 16. Напечатать в возрастающем порядке все
трехзначные числа, в десятичной записи которых есть
одинаковые цифры. Иметь возможность повторного обра-
щения в диалоге.
   Задание 17. Составить программу, вычисляющую та-
блицу значений функции
                        ?x + a, при x < ?1;
                        ?
                Y (x) = ?a, при ? 1 <= x <= 1;
                        ???x + a, при x > 1,

если х ? [–4; +4], шаг 0.5; a ? [1; 5], шаг 1. Считать а па-
раметром и строить отдельные таблицы Y(x) для каждого
а, печатая его в заголовке таблицы.
    Задание 18. Найти все целочисленные степени произ-
вольного числа K от 1 до N включительно. Иметь возмож-
ность повторного обращения в диалоге.
    Задание 19. На клетчатой бумаге нарисовали окруж-
ность целого радиуса R с центром на пересечении ли-
ний. Найти количество клеток, целиком лежащих в этой
окружности. Например, если R = 5, то K = 60.
    Задание 20. Найти все делители некоторых натураль-
ных чисел в диапазоне от N1 до N2. Иметь возможность
повторного обращения в диалоге.
    Задание 21. Найти разложение произвольного нату-
рального числа на простые множители. Иметь возмож-
ность повторного обращения в диалоге.
    Задание 22. Найти все числа в диапазоне от N1 до N2,
которые одновременно кратны m и не кратны n. Иметь
возможность повторного обращения в диалоге.
    Задание 23. Составить программу для вычисления та-
блицы значений функции
За д ач и и у п р аж н е н и я                                     241


                       ?1 ? e ? ( x + y) , при x > 0, y > 0;
                       ?
            F (x, y) = ?x + y, при x > 0, y < 0;
                       ?sin2 (x + y), в остал     льных случаях.
                       ?
   Здесь y ? [0; 2.5] с шагом 0.5 и x ? [0; 2.5] с шагом 0.5.
Построить таблицу на решетке из полного перебора значе-
ний x, y, где y выводить в заголовке.
   Задание 24. Поле шахматной доски определяется па-
рой значений (вертикаль, горизонталь), где первое зна-
чение — буква, а второе — цифра, например, e2, f5. По
двум заданным значениям полей определить, угрожает
ли ферзь, стоящий на первом поле, второму полю. Иметь
возможность повторного обращения в диалоге.
   Задание 25. Числа Фибоначчи образуются по закону
                      f1 = 1, f2 = 1, …, fk+1 = fk–1 + fk.
   Найти все числа Фибоначчи, не превышающие N.
Иметь возможность повторного обращения в диалоге.
   Задание 26. Написать программу, работающую как
простой калькулятор, выполняющий операции «+», «–»,
«*», «/» для двух операндов. Реализовать в диалоге ввод
операндов и выбор операции.
   Задание 27. Составить программу для вычисления та-
блицы значений функции
                         ?x2 + y2 , при x < 0, y < 0;
                         ?
              F (x, y) = ? x + y , при x > 0, y > 0;
                         ? 2
                         ? x + y , в остальных случ
                                   2                  чаях.
    Здесь y ? [0; 2.5] с шагом 0.5 и x ? [0; 2.5] с шагом 0.5.
Построить таблицу на решетке из полного перебора значе-
ний x, y, где y выводить в заголовке.
   Задание 28. Напечатать в возрастающем порядке все
числа в диапазоне от 1 до N, в десятичной записи которых
нет одинаковых цифр. Иметь возможность повторного об-
ращения в диалоге.
   Задание 29. Найти все натуральные числа в диапазоне
от N1 до N2, равные сумме кубов своих цифр. Иметь воз-
можность повторного обращения в диалоге.
242                                                          Гл а в а 3



   Задание 30. Составить программу, вычисляющую та-
блицу значений функции
                   ?sin ? , при x >= 1;
                   ?    x
          f ( x) = ?
                   ?sin (x ? 1) ? ? ? , при ? 1 <= x <= 1,
                        ?
                   ?    ?         2?
если х ? [–2; +2], шаг 0.2.


      Тема 4. Алгоритмы вычисления сумм,
      произведений, количеств, пределов,
      последовательностей. Сложные циклы
   В алгоритмах вычисления сумм, произведений, ко-
личеств, пределов, последовательностей особенностью
является содержание тела цикла. При вычислении сум-
мы к значению суммы многократно прибавляются новые
значения слагаемых. При вычислении произведения
значение многократно умножается на очередной сомно-
житель. При вычислении количеств значение счетчика
увеличивается на 1. При вычислении предела или по-
следовательности значение многократно вычисляется на
базе предыдущего значения. Итоговое значение, кроме
вычисления последовательностей, чаще единственное,
так как все остальные вычисленные значения являются
промежуточными.
   Управление циклами этого вида выполняется также
с использованием управляющих переменных, которы-
ми фактически служит номер вычисляемого значения
(слагаемого, множителя, элемента последовательно-
сти). Если число повторений известно, цикл должен
быть арифметическим. В задачах вычисления с указан-
ной точностью цикл должен быть итерационным, так
как заранее не может быть известно число повторений,
которое понадобится, чтобы достичь заданной точно-
сти.
   Пример 4.1. Вычисление суммы известного числа сла-
гаемых. Пусть требуется вычислить сумму N чисел нату-
рального ряда
За д ач и и у п р аж н е н и я                           243

                          S = 1 + 2 + 3 + 4 + ... + N,
где N — любое наперед заданное число.
    Это арифметический цикл, у которого параметром
является номер слагаемого, который также определяет
и значение очередного слагаемого, включаемого в сумму.
Обозначим его буквой n, тогда общая формула тела цикла
запишется так S = S + n.
    Смысл цикличности в том, что к значению суммы
многократно прибавляются новые значения слагаемых,
обновляя ее. Число повторений цикла равно числу дей-
ствий сложения, которое нужно выполнить для достиже-
ния результата.
    Номер слагаемого (и его значение) n меняется в диа-
пазоне от 1 до N с шагом, равным 1.
void main (void)
{
   int n;   // управляющая переменная
   int S;   // сумма ряда
   int N;   // число слагаемых, включенное в сумму
   printf("Вычисление суммы чисел натурального ряда.\n");
   printf("Введите число слагаемых>\n ");
   scanf("%d", &N);
   S=0;     // инициализация переменной S нулем обязательна
   n=1;     // к нулю готовимся прибавить первое слагаемое
   do
   {
?? S+=n; // тело цикла
?? n++; // приращение параметра цикла
   } while(n<=N);
// печать результата вне цикла
   printf("При %d слагаемых сумма = %d", N, S);
} // End of main
    Поскольку данный цикл арифметический, использо-
вание оператора цикла do... while не является необходи-
мым, но подчеркивает, что любой тип цикла в С++ можно
реализовать с помощью любого оператора цикла.
    Пример 4.2. Организация итерационного цикла на
примере алгоритма суммирования. Пусть требуется най-
ти сумму прогрессии
244                                                     Гл а в а 3



                         1 1 1       1
                 S =1+    + + + ... + + ...
                         2 3 4       n

c точностью ? (например, ? = 0.001).
    Количество слагаемых, которое нужно включить в сум-
му для достижения заданной точности, неизвестно, но из-
вестно условие, определяющее точность вычислений. Пре-
дел значения очередного слагаемого стремится к нулю:
                                1
                          lim       = 0,
                          n >? n

поэтому можно считать, что именно это значение опреде-
ляет требуемую точность вычислений, и можно закончить
вычисления, когда очередное слагаемое настолько мало,
что им можно пренебречь. Все переменные должны иметь
вещественный тип, так как участвуют в вычислении ве-
щественного значения.
void main(viod)
{
   float S;
   float eps;   // значение точности вычислений
   float n;     // номер слагаемого, определяет также
                // его значение, изменяется от 1 с шагом 1
   printf("Вычисление суммы ряда.\n");
   printf("Введите точность вычислений <1\n");
   scanf("%f", &eps);
   n=1;
   S=0;         // входит в подготовку цикла
   do
   {
?? S+= 1/n;
?? n+= 1;
   } while(1./n>eps);     // еps достаточно мало
   printf("Слагаемых %5.0f, Сумма %f8.5", n, S);
} // End of main
   В рассмотренных примерах циклические алгоритмы
суммирования являются простыми. При организации
сложных циклов внутренний цикл полностью, от подготов-
ки до завершения, должен находиться внутри внешнего.
За д ач и и у п р аж н е н и я                        245


   Пример 4.3. Пусть требуется вычислить сумму ряда
по формуле
                                 x x x       x
                         S=x+     + + + ... + + ...
                                 2 3 4       n
    Очевидно, что значение суммы будет зависеть от зна-
чения x. Добавить сложность к этому алгоритму может
одно из следующих условий.
    1. Вычислить суммы для различного числа слагаемых
(n1, n2, n3 и т. д.) в арифметическом цикле или цикле,
управляемом событием.
    2. Вычислить суммы для различных значений x, на-
пример, для x ? [x0, xn] с шагом ?x, или вводимых с кла-
виатуры.
    3. Вычислить суммы для различных степеней точно-
сти, например, для ? ? [?0, ?n] в итерационном цикле.
    Рассмотрим второй случай. Сумма заново вычисля-
ется для каждого значения x, поэтому цикл вычисления
суммы должен быть внутренним, а цикл изменения пере-
менной x внешним. Управляющей переменной внутрен-
него цикла является номер слагаемого n ? [1, N], ее шаг
равен 1. Число повторений N должно быть известно, его
можно ввести. Внешним циклом управляет переменная
x, которая изменяется по закону арифметического цикла,
пусть для определенности x ? [0; 1], шаг 0,1.
void main(void)
{
  float x;       // параметр внешнего цикла
  float n;       // параметр внутреннего цикла
  float S;
  int N; // число слагаемых, включенных в сумму
  printf("Вычисление суммы чисел натурального ряда.\n");
  printf("Введите число слагаемых>1\n");
  scanf("%d", &N);
  // управление внешним циклом
  for(x=0; x<=1; x+=0.1)
  {
?? // тело внешнего цикла
?? // управление внутренним циклом
246                                                        Гл а в а 3



?? S=0;
?? n=1;
?? while(n<=N)
?? {
??? // Тело внутреннего цикла.
??? S+=x/n;
??? n+=1;
?? }
?? printf("При x=%6.2f сумма = %6.2f\n", x, S);
   }
} // End of main
   Пример 4.4. Использование рекуррентных соотноше-
ний при вычислении последовательностей. Кстати, сла-
гаемые сумм и сомножители произведений фактически
тоже образуют вычисляемые последовательности. Часто
имеет смысл использовать соотношения, существующие
между соседними элементами последовательности, чтобы
каждое новое значение вычислять рекуррентно, т. е. ис-
ходя из значения, вычисленного на предыдущем шаге,
например, an = f(an–1).
   Используем этот прием для вычисления значения
функции S(x) в произвольной точке x по формуле разло-
жения в ряд для 5, 10, 15 и 20 слагаемых, если формула
задана:
                          x2 x 4                   xn
            S( x) = x ?     +    ? ... + (?1) n ?      .
                          2! 3!                   (n)!
    Переменная x произвольна и не задана в условии, зна-
чит, ее следует ввести.
    Помимо собственно вычисления суммы требуется
сравнить вычисленные значения для разного числа сла-
гаемых, для чего нужен сложный цикл, где внешним ци-
клом будет арифметический цикл с управлением по коли-
честву слагаемых, включенных в сумму: N = 5, 10, 15, 20,
т. е. N ? [1; 20], шаг 5.
    Управляющей переменной внешнего цикла является
N, в то время как k — управляющая переменная внутрен-
него цикла.
    Внутренний цикл имеет некоторые особенности.
За д ач и и у п р аж н е н и я                                247


    1. При k = 1 начальное значение суммы S равно 0,
а очередное слагаемое а не определено.
    2. Во внутреннем цикле очередное слагаемое вычисля-
                         xn
ется по формуле a =         .
                         n!
    Для возведения числа в степень в С++ есть функция
pow, а для вычисления факториала функции нет. Фак-
ториал, во-первых, растет очень быстро, и для n = 10
и более имеет очень большие значения. Во-вторых, для
его вычисления нужен циклический алгоритм. Если
для вычисления слагаемого использовать рекуррентное
соотношение, то мы избавимся от этих двух недостат-
ков.
    Вычисление степени xn — это произведение n сомно-
жителей x ? x ? x ?...? x. Вычисление факториала, это произ-
ведение чисел натурального ряда, n! = 1 ? 2 ? 3 ? ... ? n. Если
обозначить именем a значение очередного слагаемого, то
последующее значение может быть вычислено по отноше-
нию к предыдущему по формуле
                                          x
                                    a = a? .
                                          k
     Действительно,
                            при k = 1 a = x;
                                                x x2
                            при k = 2 a = a ?    = ;
                                                2 2
                                                x x2 ? x x3
                            при k = 3 a = a ?    =      =
                                                3 2?3     6

и т. д. Значит, в теле внутреннего цикла для вычисления
очередного слагаемого может быть использована именно
эта формула.
    3. Ряд является знакопеременным, т. е. знак слагае-
мого отрицательный для четных слагаемых, и положи-
тельный для нечетных. Однако нет необходимости в фор-
муле вычислений возводить (–1) в степень. Обычно для
решения подобных задач вводится переменная, храня-
щая знак, например, переменная z принимает значения
248                                                  Гл а в а 3



+1 или –1. Смена знака в цикле достигается присваивани-
ем z = –z при переходе к очередной итерации.
#include         <stdio.h>
#include         <conio.h>
void main(void)
{
   int N;		      // управление внешним циклом,
		               // целая переменная
   float x;      // аргумент функции
   float k;      // управление внутренним циклом,
		               // вещественная переменная, участвует
		               // в вычислении
   float a;      // очередное слагаемое
   float S;      // S – сумма
   int z;		      // знак слагаемого
   printf("Введите x = \n");
   scanf("%f", &x);
   // управление внешним циклом по числу слагаемых
   for(N=5; N<20; N+=5)
   {
?? k=1;          // начинаем с номера 1
?? S=0;          // сумма = 0
?? a=1;          // для рекуррентного соотношения
?? z=1;          // знак слагаемого "плюс" для k = 1
?? // управление внутренним циклом
?? while(k<=N)
?? {
??? a=a*x/k; // очередное слагаемое рекуррентно
??? S=S+z*a; // сложение с учетом знака.
??? // переход к следующему слагаемому.
??? k+=1;
??? z=–z;        // смена знака
?? };
?? printf("При %4.0f слагаемых cумма = %8.4f\n",k–1, S);
   }
} // End of main
   Небольшой итог. При вычислении сумм в подготовку
цикла входит обнуление суммы. В теле цикла сумма вы-
числяется многократным прибавлением к значению сум-
За д ач и и у п р аж н е н и я                           249


мы очередного слагаемого. Итоговое значение одно, оно
получено при завершении цикла.
    При вычислении произведений в подготовку цикла
входит присваивание произведению значения 1. В теле
цикла произведение вычисляется многократным умноже-
нием значения произведения на очередной сомножитель.
Итоговое значение также одно, получено при завершении
цикла.
    Пример 4.5. Вычисление последовательностей. Клас-
сическая задача — это нахождение арифметической или
геометрической последовательностей. Для нахождения
значения очередного элемента используется один или не-
сколько предыдущих элементов an = f(an–1), почти как при
использовании рекуррентных соотношений.
    Пусть требуется вычислить элементы арифметической
прогрессии, если заданы первый элемент, знаменатель
и число элементов. Пусть требуется вычислить элементы
геометрической прогрессии, если заданы первый элемент
и знаменатель. Для возрастающей прогрессии вычислять
значения, пока очередной элемент не превысит 1000, для
убывающей прогрессии вычислять значения, пока оче-
редной элемент не станет меньше, чем 0,001.
    В этом примере еще раз обратим внимание на исполь-
зование операторов цикла. Для организации арифметиче-
ского цикла логичнее использовать for, для организации
итерационного цикла while или do... while.
#include <stdio.h>
#include <conio.h>
void main(void)
{
  float Ar, d_Ar;		   // первый элемент и знаменатель
  float Geom, d_Geom; // первый элемент и знаменатель
  int Cou_Ar;		       // число элементов прогрессии

   //----- Задача 1. ---------------------------------
   printf("Введите первый элемент и знаменатель
          прогрессии\n");
   scanf("%f%f", &Ar, &d_Ar);
   printf("Введите число элементов\n");
250                                                         Гл а в а 3



  scanf("%d", &Cou_Ar);
  // управление первым циклом по числу слагаемых
  for(int k=2; k<=Cou_Ar; k++) // номер начинается с 2
  {
?? Ar=Ar+d_Ar;
?? printf("%d-й элемент равен: %6.2f\n", k, Ar);
  }

//------ Задача 2.---------------------------------
printf("Введите первый элемент и знаменатель
???? прогрессии\n");
scanf("%f%f", &Geom, &d_Geom);
if(d_Geom>1)
{
   printf("Возрастающая последовательность\n");
   k=2;
   while(Geom<1000)       // while, так как Geom известно
   {
?? Geom=Geom*d_Geom;
?? printf("%d-й элемент равен: %6.2f\n", k, Geom);
?? k++;
   }
}
   else
?? if(d_Geom<1)
?? {
?? printf("Убывающая последовательность\n");
?? k=2;
?? while(Geom > 0.001)
?? {
??? Geom=Geom*d_Geom;
??? printf("%d-й элемент равен: %8.4f\n", k, Geom);
??? k++;
?? }
   }
   else		        // здесь знаменатель равен 1
?? printf("Все элементы одинаковы\n");
} // End of main
За д ач и и у п р аж н е н и я                        251


   Пример 4.6. Использование операторов break и continue
для циклов do, while, for. Оператор прерывания break вну-
три любого цикла прекращает выполнение цикла с пере-
дачей управления следующему за циклом оператору. Осу-
ществляя выход из цикла при наступлении каких-либо
обстоятельств, позволяет корректно завершить цикл.
В случае вложения прерывает только непосредственно
охватывающий цикл.
   Найдем сумму чисел натурального ряда, не превы-
шающую некоторого заданного значения. Узнаем также,
сколько элементов будет включено в сумму.
#include <stdio.h>
void main(void)
{
   int Max, Sum=0, k; // Max – наибольшее значение суммы
   printf("\nВведите наибольшее значение\n");
   scanf("%d", &Max);
   for(k=1; ;k++)     // бесконечный цикл
   {
?? Sum+=k;
?? if(Sum>Max)        // условие завершения цикла
??? break;            // прерывание. При выходе известно k
   }
   printf("количество элементов %d", k);
} // End of main
     Оператор continue внутри любого цикла выполняет
переход к следующей итерации тела цикла. Противопо-
ложен break. В любой точке цикла прервет текущую ите-
рацию и перейдет к проверке условия завершения цикла.
    Найдем сумму слагаемых вида S = 1/x для x ? [–1; +1]
с шагом 0,1. Особой точкой в этом ряду является точка
x = 0, функция в этой точке не определена. При x = 0 вы-
числение выполнять нельзя, значит, это действие следует
пропустить.
#include <stdio.h>
#include <math.h>
void main (void)
{
  float Sum=0;
252                                                Гл а в а 3



   float x;
   for(x=–1; x<=1.1; x+=0.1)
   {
?? if(fabs(x)<0.0001)
??? continue; // если в знаменателе 0
?? Sum+=1/x;
   }
   printf("Сумма %6.2f", Sum);
} // End of main
    Пример 4.7. Бесконечный цикл. В тех случаях, когда
управление циклом осуществляется не по событиям или
условиям извне, а возникает непосредственно в теле цик-
ла, можно использовать бесконечные циклы. Бесконеч-
ным он может быть назван только с точки зрения синтак-
сиса, потому что условие выхода из цикла не прописано
непосредственно в управлении циклом. Содержимое тела
цикла может быть произвольным, но какие-то действия
внутри должны привести к тому, что процесс когда-то
закончится. Прерывание и выход из цикла выполняет
обычно оператор break.
while(1)
{
?? …
  // проверка условия и выход
}
for(; ; ;)
{
?? …
  // проверка условия и выход.
}

                    Варианты заданий
      Задание 1. Найти число ?, используя произведение
                   ? 2 2 4 4 6 6
                    = ? ? ? ? ? ? ...
                   2 1 3 3 5 5 7
   Точность для печати не менее 5 знаков. Во внешнем
цикле выполнить вычисления для 50, 100, 200, 400 со-
множителей.
За д ач и и у п р аж н е н и я                                     253


   Задание 2. Найти число ?, используя формулу суммы
ряда
          ?      1 1 1 1                     1
            = 1 ? + ? + ? ... + (?1)k +1 ?        .
          4      3 5 7 9                   2?k +1
   Во внешнем цикле выполнить вычисления для 50, 100,
200 слагаемых. Точность для печати не менее 5 знаков.
   Задание 3. Вычислить значение полинома P(x) в про-
извольной точке x, если
                        P(x) = 1 + x + x2 + x3 + ... + xn .
   Выполнить вычисления для 100 слагаемых. Во внеш-
нем цикле составить таблицу, выводящую на экран значе-
ние полинома для х ? [–0.5; 1,1].
   Задание 4. Вычислить значение функции Y(x) в про-
извольной точке x по формуле разложения в ряд
                               x2 x3         xn
              Y ( x) = 1 + x +   +   + ... +    .
                               2! 3!         n!
   Величину х вводить. Во внешнем цикле выполнить
вычисления для 5, 10, 15, 20, 25 слагаемых. Точность для
печати не менее 5 знаков.
   Задание 5. Вычислить значение суммы ряда Y(x) в про-
извольной точке x, если
               Y(x) = sinx + sin2x + sin3x + ... + sinnx.
   Величину x вводить в градусной мере. Во внешнем
цикле выполнить вычисления для 10, 20, 30 слагаемых.
Точность для печати не менее 5 знаков.
   Задание 6. Вычислить значение функции Y(x) в про-
извольной точке x по формуле разложения в ряд
                                   x2 x 4                 x 2n
                    Y ( x) = 1 ?     +    ? ... + (?1)n ?      .
                                   2! 4 !                 2n !
   Величину x вводить. Во внешнем цикле выполнить
вычисления для 5, 10, 15, 20 слагаемых. Точность для пе-
чати не менее 5 знаков.
   Задание 7. Вычислить значение функции Y(x) в про-
извольной точке x по формуле разложения в ряд
                         x2 x3                   xn
            Y ( x) = x ?   +   ? ... + (?1)n ?1 ? .
                         2   3                   n
254                                                                 Гл а в а 3



   Величину x вводить. Во внешнем цикле выполнить
вычисления для 5, 10, 15, 20 слагаемых. Точность для пе-
чати не менее 5 знаков.
   Задание 8. Составить программу для вычисления та-
блицы значений функции
         Y(x) = x(x – 0,5) ? (x – 1) ? (x – 1,5) ... (x – 5),
для x ? [0; 0,9], шаг 0,1. Параметром внутреннего цикла
является величина а в сомножителе вида (х – а).
   Задание 9. Вычислить значение суммы ряда
                      ?
                      ?
                                 (
                     ?????????????
                                        (   ?
                  S = ? 2 + 2 + 2 + ... + 2 ? .
                                            ?
                                                    ))
                                     n корней
    Во внешнем цикле выполнить вычисления для n = 5,
10, 15, 20. Один из тестовых примеров проверить вруч-
ную. Точность для печати не менее 5 знаков.
    Задание 10. Для некоторого натурального числа N
найти все целые x, y, такие, что выполняется равенство:
x2 + y2 = N.
    Во внешнем цикле значение N вводить в диалоге.
    Задание 11. Вычислить значение суммы ряда Y(x)
в произвольной точке x, если
                       ?                 ?                        ?
      Y (x) = x ? sin ? ? + x2 ? sin ?2 ? ? + ... + xn ? sin ? n ? ? .
                      ?4?            ? 4?                    ? 4?
   Величину x вводить в градусной мере. Во внешнем ци-
кле выполнить вычисления для 5, 10, 15, 20 слагаемых.
Точность для печати не менее 5 знаков.
   Задание 12. Найти произведение n сомножителей
                                 1 3 5 7
                           S=     ? ? ? ? ...
                                 2 4 6 8
   Во внешнем цикле выполнить вычисления для 50, 100,
200 сомножителей. Точность для печати не менее 5 знаков.
   Задание 13. Вычислить значение функции Y(x) в про-
извольной точке x по формуле разложения в ряд
                                x2 x3                  x 2n
             Y ( x) = 1 ? x +     ?   + ... + (?1)n ?       .
                                2! 3!                 (2n)!
За д ач и и у п р аж н е н и я                                             255


    Во внешнем цикле выполнить вычисления для 5, 10,
15, 20, 25 слагаемых.
    Задание 14. Составить программу для вычисления та-
блицы значений функции
                 Y(x) = 1 + 2x + 3x2 + 4x3 + ... + 20x19
для x ? [0; 1,2], шаг 0,05.
   Задание 15. Составить программу для вычисления та-
блицы значений функции
                                 (x ? 1)2 (x ? 1)3 (x ? 1)4
            Y (x) = (x ? 1) +            +        +         + ...
                                    2        3        4
    Во внешнем цикле вычислить функции для 5, 10, 15,
40 слагаемых. Во внешнем цикле задать значение x ? [0;
1,2], шаг 0,2.
    Задание 16. Вычислить значение функции Y(x) в про-
извольной точке x по формуле разложения в ряд
                                  cos 2x cos 3x         cos nx
               Y (x) = cos x +          +       + ... +        .
                                    2      3              n
   Значение х ввести в градусной мере. Во внешнем ци-
кле выполнить вычисления для 5, 10, 15, 20 слагаемых.
Точность для печати не менее 5 знаков.
   Задание 17. Вычислить значение функции Y(x) в про-
извольной точке x:
                          (x ? 2) ? (x ? 4) ? (x ? 8) ? ... ? (x ? 64)
                Y (x) =                                                .
                          (x ? 1) ? (x ? 3) ? (x ? 7) ? ... ? (x ? 63)
     Выполнить вычисления для x ? [–1; 1], шаг 0,1.
     Задание 18. Вычислить значение суммы
      S = 1 ? 2 + 2 ? 3 ? 4 + 3 ? 4 ? 5 ? 6 + ... + n(n + 1) ... 2n.
    Во внешнем цикле вычислить сумму для значений
n = 10, 20, 30, 40, 50.
    Задание 19. Составить программу для вычисления
суммы
                     1 1 1        1     1
             S = 1 ? + ? + ... +     ?
                     2 3 4       9999 10000
256                                                Гл а в а 3



   а) последовательно слева направо;
   б) вычислить отдельно суммы положительных и отри-
цательных слагаемых, а затем вторую сумму вычесть из
первой.
   Если результаты различны, объяснить.
   Задание 20. Вычислить значение суммы
                      1 1   1         1
                 S=    +  +   + ... + n .
                      a a2 a3        a
   Величину а вводить в диалоге во внешнем цикле. Для
каждого а выполнить вычисления при различном числе
слагаемых n = 5, 10, 15, 20.
   Задание 21. Последовательность вычисляется по за-
кону
                  1     1 1     1 1 1
            1, 1 + , 1 + + , 1 + + + ,...
                  2     2 3     2 3 4
    Известно, что существует предел этой последова-
тельности. Найти его с точностью ? знаков после запя-
той. Величину точности во внешнем цикле последова-
тельно задать равной 0,1; 0,01; 0,001; 0,0001; 0,00001.
Выводить в виде таблицы значение предела последова-
тельности и значение числа слагаемых, включенных
в сумму.
    Задание 22. Для некоторого наперед заданного нату-
рального числа N найти такую наименьшую степень двой-
ки 2k, которая не превосходит N. Вывести значение k и все
степени двойки. Во внешнем цикле значение N вводить
в диалоге.
    Задание 23. Составить программу для вычисления
суммы
                    1 1 1         1     1
            S =1?    + ? + ... +     ?
                    2 3 4        9999 10000
   а) последовательно справа налево;
   б) вычислить отдельно суммы положительных и отри-
цательных слагаемых, а затем вторую сумму вычесть из
первой.
   Если результаты различны, объяснить.
За д ач и и у п р аж н е н и я                               257


   Задание 24. Составить программу для вычисления
произведения n сомножителей
                      1 3 5        n ?1
                   P = ? ? ? ... ?
                      2 4 6         n
   а) последовательно справа налево;
   б) последовательно слева направо.
   Если результаты различны, объяснить. Значение n
вводить в диалоге.
   Задание 25. Вычислить значение полинома в точке x:
                Y(x) = x10 + 2x9 + 3x8 + ... + 10x + 11.
   Составить таблицу значений полинома, где во внеш-
нем цикле переменная х принимает значения х ? [–2; 2]
при шаге 0,2.
   Задание 26. Вычислить значение полинома в точке x:
               Y(x) = 11x10 + 10x9 + 9x8 + ... + 2x + 1.
    Составить таблицу значений полинома, где во внеш-
нем цикле переменная х принимает значения х ? [–2; 2]
при шаге 0,2.
    Задание 27. Найти все натуральные трехзначные чис-
ла, сумма цифр которых равна некоторому натуральному
числу N. Подсчитать их количество. Значение N вводить
в диалоге.
    Задание 28. Вычислить значение суммы ряда Y(x)
в произвольной точке:
                                        x2 x3         xn
                         Y ( x) = x +     +   + ... +    .
                                        2! 3!         n!
   Величину x вводить в диалоге. Во внешнем цикле вы-
полнить вычисления для 5, 10, 15, 20 слагаемых. Точ-
ность для печати не менее 5 знаков.
   Задание 29. В диапазоне от 1 до некоторого натураль-
ного N найти и вывести на печать все числа, которые де-
лятся на 3, на 2, но не делятся на 5. Найти их количество.
Величину N вводить в диалоге.
   Задание 30. Числа Фибоначчи определяются форму-
лами: f0 = f1 = 1, f2 = 2, и каждое последующее число равно
сумме двух предыдущих.
258                                               Гл а в а 3



   Составить программу, которая найдет n чисел Фибо-
наччи, а также сумму всех чисел Фибоначчи, не превос-
ходящую некоторого N, введенного в диалоге.

      Тема 5. Использование циклических
      алгоритмов в решении содержательных
      задач

    Наиболее важным в программировании является под-
готовительный этап, который называют постановкой за-
дачи, тесно связанный с этапом формализации задачи.
От правильного их выполнения во многом зависит время
и качество программирования.
    Постановка задачи обычно заключается в ее сло-
весном описании. Как известно, на вербальном уровне
точное определение модели невозможно, поэтому сле-
дующий этап — это формализация, т. е. выбор матема-
тической или иной модели, адекватно отражающей суть
задачи. Точных рекомендаций при выборе модели дать
невозможно.
    Важным также является выбор структур данных
и определение их типов.
    До сих пор мы рассматривали уже готовые, формали-
зованные задачи, где математическое описание было дано
или лежало на поверхности. Теперь приведем пример не-
формализованной задачи.
    Пример 5.1. Червячок ползет по дереву вверх, стартуя
со скоростью V м/ч. Каждый последующий час движения
его скорость падает на 10% от предыдущего значения.
Если высота дерева H, то за какое время червячок достиг-
нет вершины, если только это возможно?
    Для решения задачи нужно выяснить, прежде всего,
что выполняется многократно: бежит время, медлен-
но растет пройденный путь, падает скорость. В задаче
все как в жизни. Очевидно, что управлять этим циклом
должна переменная, обозначающая время, так как все
три переменные связаны в формуле вычисления пути при
заданной скорости S = V ? t. Очевидно, что точное усло-
вие завершения процесса сформулировать невозможно,
За д ач и и у п р аж н е н и я                        259


­ оэтому нужно использовать итерационный цикл с усло-
п
вием завершения S < H.
    В подготовку цикла входит присваивание начальных
значений пути S = 0, скорости V и времени t = 1. При-
чем если S и V имеют значения до момента первого вы-
числения, то t = 1 уже готовится к первой итерации. Для
убедительности будем выводить на экран значения пути,
пройденного к исходу каждого часа, и значение скорости
в каждый час времени.
    Момент, завершающий цикл, интересен многими осо-
бенностями и сильно зависит от входных данных.
    1. Первый вариант завершения цикла — червячок
сможет добраться до вершины. Условием завершения яв-
ляется S < H, при этом в теле цикла оператор break отсе-
кает лишнюю итерацию.
    2. Второй вариант — червячок не сможет добраться до
конца дерева, так как скорость падает очень быстро, а вы-
сота большая. Должна быть выполнена проверка условия
V > 0 с некоторой степенью точности, так как возможно,
что скорость упадет практически до 0, а до конца дерева
останется еще очень долгий путь. Кстати, проверка S < H
также выполняется приближенно.
#include <stdio.h>
void main (void)
{
  float V; // скорость предыдущего и скорость нового часа
  float S; // путь
  float H; // высота дерева
  float t;   // время пути
  printf("Высота дерева и начальная скорость движения\n");
  scanf("%f%f", &H,&V);
  printf(" Таблица зависимости пути от времени.\n");
  printf("---------------------------------\n");
  printf(" Время \tПуть \tСкорость \n");
  printf("---------------------------------\n");
  // в подготовку цикла входит присваивание значений пути,
  // скорости и времени
  S=0.;
  t=1.;
260                                                   Гл а в а 3



   while(1)      // бесконечный цикл
   {
?? S=S+V*1.; // пройденный путь S=S+V*t, где t=1.0
?? if(S>H)
?? {
??? printf("Я уже почти добрался до вершины.\n");
??? break;       // чтобы исключить лишнюю итерацию
?? }
?? if(V<=0.01)
?? {
??? printf("Я никогда не доберусь до вершины.\n");
??? break;       // цикл закончен
?? }
?? printf("%6.0f %8.3f %8.3f \n", t, S, V);
?? V*=0.9;       // аналог записи V = V * 0.9;
?? t+=1.;
   }
} // End of main

                   Варианты заданий
    Задание 1. Валяльная фабрика ежегодно увеличи-
вает объем продаж на 2%, снижая себестоимость про-
дукции на 1%. В текущем году объем продаж составил
500 тыс. руб., а себестоимость пары валенок была равна
55 руб.
    Вычислить и вывести на экран таблицу прогнозируе-
мого увеличения объема продаж и снижения себестоимо-
сти на ближайшие K лет.
    Задание 2. Ученица швеи начинает работу, сострачи-
вая в день 2 пары рукавиц. Совершенствуя свое мастер-
ство, она каждый день выполняет в 2 раза больше работы,
чем в предыдущий день. Больше, чем 100 пар в день, со-
строчить нельзя.
    Найти, на который день ученица достигнет вершин
мастерства. Сколько всего пар рукавиц ей при этом при-
дется сшить? Вывести на экран таблицу роста мастерства
швеи по дням.
    Задание 3. На день рождения ребенка бабушка откры-
ла счет в банке и положила на него 5 долл. Каждый год
За д ач и и у п р аж н е н и я                          261


она добавляет 5 долл. Годовой процент по банковскому
счету равен 12%.
    Какая сумма накопится к совершеннолетию ребенка
(к 18 годам), включая последний взнос. Вывести на экран
таблицу ежегодного состояния счета.
    Задание 4. Процент по банковскому вкладу равен 6%.
Если положить в банк сумму N руб., то эта сумма будет
ежегодно увеличиваться.
    Как будет изменяться сумма в течение ближайших 10
лет? Если годовая инфляция составляет 3,5%, то сколь-
ко же на самом деле будут стоить эти деньги? Вывести на
экран таблицу ежегодного состояния счета.
    Задание 5. Пара кроликов дает приплод раз в четыре
месяца, в среднем по 5 крольчат.
    Вычислить и вывести в виде таблицы, каков будет
ежегодный приплод от пары, двух, трех и т. д. до 20 пар.
    Задание 6. Оплата труда приходящей няни осущест-
вляется по часам. За срок до 6 ч она получает по 25 руб.
в час. Начиная с 6 ч работы, каждый последующий час
стоит в 2 раза дороже, т. е. 50, потом 100 и т. д. Родители,
отправляясь на вечеринку, хотят знать сумму, которую
они заплатят няне, но не знают, насколько задержатся.
    Вычислить и вывести на экран таблицу оплат услуг
няни, начиная с одного часа до 24 ч.
    Задание 7. Поженившись, молодые супруги решили
откладывать деньги на покупку автомобиля. Муж может
вложить ежемесячно М руб., жена V руб. Если положить
деньги в банк, то по срочному вкладу годовой процент ра-
вен 12%. Автомобиль мечты стоит N тыс. руб.
    Через какой срок молодые поедут на юг в собствен-
ном авто? Для убедительности выведите таблицу ежеме-
сячных накоплений с учетом процента по банковскому
вкладу.
    Задача 8. Маркетинговое исследование, проведенное
фирмой «Рога и копыта», выявило, что каждый третий
год работы предприятия является очень прибыльным,
а каждый пятый убыточным. Известно, что этот год (те-
кущий) является убыточным, а предыдущий был очень
прибыльным.
262                                                 Гл а в а 3



    Выяснить, какие из ближайших 15 лет будут при-
быльными, а какие убыточными. Вывести на экран толь-
ко года и комментарии.
    Задание 9. По окончании сессии всегда есть некоторое
количество «хвостистов». Деканат решил провести курсы
для отстающих в объеме 40 ч и установил стоимость опла-
ты часа равной 100 руб. Из суммы, оплаченной студента-
ми, преподавателю причитается 40%.
    Найти, сколько денег получит преподаватель, если бу-
дет заниматься с одним, двумя, тремя и т. д. до M студен-
тов. Может ли он озолотиться, если золотой горой считать
сумму 20 тыс. руб. Скольких бездельников ему придется
выучить?
    Задание 10. Незнайка учит английский язык. В пер-
вый день он выучил 2 слова, а каждый последующий день
собрался выучивать на два слова больше, чем в предыду-
щий.
    Найдите и выведите в виде таблицы, на который день
Незнайка выучит 100 слов, 200, 300, 400 и т. д. до 1000.
В английском языке около 50 тыс. слов, а срок жизни Незна-
ек примерно 30 лет. Успеет ли до своей кончины Незнайка
выучить английский язык? Если нет, то сколько незнаечих
жизней понадобится, чтобы выучить английский язык?
    Задание 11. Спортсмен начал тренировки, пробежав
N км. Ежедневно он увеличивает длину пробегаемого
пути на 20%.
    Найти, к исходу какого дня спортсмен пробежит ма-
рафонскую дистанцию. Вывести таблицу длин ежедневно
пройденного пути.
    Задание 12. Старушка решила купить телевизор, ког-
да внук подарил ей 1000 руб. Она положила их в Сбербанк
под 8% годовых. Ежемесячно на этот же счет старушка
вносит 200 руб. Самый дешевый телевизор стоит K руб.
    Через сколько месяцев старушка посмотрит кино на
канале СТС? Вычислить и вывести на экран состояние
счета помесячно.
    Задание 13. Известно, что заяц бежит в K раз быстрее,
чем ползет черепаха. Они стартуют из пункта А в пункт Б,
расстояние между которыми N км.
За д ач и и у п р аж н е н и я                          263


    Вычислить, сколько раз заяц сбегает туда и обратно,
пока черепаха доберется до пункта назначения.
    Задание 14. Мама и дочка идут навстречу друг другу
со скоростью V1 км/ч. Расстояние между ними S км. В мо-
мент начала движения их собачка, которая была у мамы,
видит дочку и начинает бегать от одной к другой со скоро-
стью V2 км/ч, большей, чем V1.
    Найти, какое расстояние пробежала собака, прежде
чем мама с дочкой встретились. Вычислить число пробе-
гов собаки от мамы к дочке.
    Задание 15. В стаде K коров и k коз. Корова дает при-
мерно 25 л молока в сутки, коза примерно 2,5 л.
    Найти, сколько молока приносит ежедневно стадо,
в котором число коров и коз может быть от двух до де-
сяти.
    Задание 16. Заяц бежит в K раз быстрее, чем ползет
черепаха, скорость которой равна V. Они стартуют из пун-
кта А в пункт Б, расстояние между которыми N км.
    Составить таблицу перемещения объектов, если стар-
товый момент времени равен 0, а интервал времени 0,5 ч.
В таблице учесть, что, когда заяц закончит движение, че-
репаха еще ползет.
    Задание 17. Одноклеточная амеба каждые три часа де-
лится на 2 клетки.
    Вычислить и вывести в виде таблицы, сколько клеток
будет через каждые 3 ч в течение двух суток.
    Задание 18. Составить таблицу стоимости порций то-
вара весом от 100 г до 1 кг с шагом 100 г и от 1 кг до 10 кг
с шагом 500 г. Цена вводится с клавиатуры.
    Задание 19. Фабрика по производству тапочек еже-
годно увеличивает объем продаж на 5%. Себестоимость
продукции при этом уменьшается на 1%. В текущем году
объем продаж составил N тыс. руб., а себестоимость пары
тапочек C руб.
    Вычислить и вывести на экран таблицу увеличения
объема продаж и снижения себестоимости на ближайшие
K лет.
    Задание 20. Ученик мастера начинает с изготовления
в день одной табуретки. Совершенствуясь, он каждый
264                                               Гл а в а 3



день изготавливает на одну табуретку больше, чем в пред-
ыдущий день. Больше, чем 20 табуреток в день изготовить
нельзя.
    Найти, на который день ученик достигнет вершин ма-
стерства и сколько табуреток он смастерит за все время
обучения. Для убедительности вывести на экран таблицу
ежедневной производительности.
    Задание 21. Для продавщицы Несчитайкиной разра-
ботать программу, которая по стоимости 1 кг некоторо-
го продукта выдает таблицу стоимости 50, 100, 150, ...,
1000, 2000, 3000, ..., 10 000 г этого продукта.
    Задание 22. Спортсмен бежит по кругу длиной 400 м,
а тренер измеряет среднюю скорость движения на каж-
дом круге. Скорость на первом круге была V км/ч, но на
каждом круге она падает на 10%.
    Если спортсмен пробежит N кругов, то какая скорость
будет на последнем круге? Вычислить и вывести на экран
таблицу скоростей на каждом круге пути.
    Задание 23. Спортсмен бежит по кругу длиной 400 м,
а тренер измеряет среднюю скорость движения на каждом
круге. Начальная скорость была V1 км/ч, но на каждом
круге она падает на 10%.
    Узнать, на каком круге нужно закончить движение,
если скорость не должна упасть ниже V2 км/ч? Вычис-
лить и вывести на экран таблицу скоростей на каждом
пройденном круге пути.
    Задание 24. Богатый дядя подарил племяннику на пя-
тилетний юбилей 1 долл. Мальчик отнес их в банк и поло-
жил на счет под 8% годовых. Каждый год на день рожде-
ния дядя дарит мальчику столько долларов, сколько лет
мальчику.
    Вычислить, сколько набежит к совершеннолетию
мальчика (18 лет). Вывести состояние счета ежегодно
с учетом последнего вклада.
    Задание 25. Богатый дядя подарил племяннику на
рождение 1 долл. Каждый день рождения сумма подарка
удваивается.
    Вычислить, сколько набежит к совершеннолетию
мальчика (18 лет). Вывести состояние счета ежегодно.
За д ач и и у п р аж н е н и я                        265


    Задание 26. Карамель стоит K руб., мармелад М руб.,
шоколад S руб. за кг.
    Вычислить и вывести на экран таблицу стоимости
каждого вида сладостей весом 100, 200 г и т. д. до 1 кг
включительно.
    Задание 27. Напечатать таблицу перевода температу-
ры из градусов по шкале Цельсия (°С) в градусы по шка-
ле Фаренгейта (F) для значений температуры от С0 до Cn
с шагом 1 градус. (Перевод осуществляется по формуле
F = 1,8 ? °С + 32.)
    Задание 28. Два пловца тренируются в бассейне, длина
дорожки которого 50 м. Первый пловец начинает трени-
ровку со скоростью V1 км/ч, второй со скоростью V2 км/ч.
Оба начинают движение одновременно с одного края бас-
сейна. Скорость первого падает на 5% за час, скорость вто-
рого — на 3%.
    Встретятся ли пловцы в точке начала движения, если
время тренировки Т? Если нет, то какое время им придет-
ся плавать, чтобы встретиться в первый раз?
    Задание 29. На прилавке в один ряд лежат N арбузов.
Известно, что каждый арбуз на 100 г легче, чем среднее
арифметическое весов его соседей.
    Найти вес второго арбуза с точностью до грамма, если
первый арбуз весит А кг, а последний — В кг.
    Задание 30. Татьяна Ларина, читая очередной фран-
цузский роман, подсчитала сумму номеров прочитанных
страниц.
    Определить номер последней прочитанной страницы.
Учесть, что юная девица может быть не в ладах с арифме-
тикой.

     Тема 6. Практическое использование 
     механизма функций
   Принципы модульного программирования требуют
использования функций для решения любой задачи, ал-
горитм которой может быть описан абстрактно.
   Функция — это абстрактный алгоритм решения не-
которой самостоятельной задачи. Фактически, функция
266                                              Гл а в а 3



является одним из конструируемых пользователем типов
данных и имеет имя, тип, может иметь параметры (аргу-
менты функции), которые обеспечивают связь функции
с внешним окружением, а также имеет тело, в котором
разработан алгоритм решаемой задачи.

                   Описание функции
    В языке С++ все функции описываются на одном уров-
не. Вложений не допускается. Структура простой функ-
ции ничем не отличается от структуры функции main и в
общем виде такова:
Заголовок функции
{
  описания локальных переменных;
  описание алгоритма;
return возвращаемое_значение;
// Отсутствует, если функция типа void
}
     Заголовок функции используется для объявления
функции в теле программы и содержит полное описание
интерфейса функции, которое позволяет правильно обра-
титься к ней.
     1. Тип функции. Это тип возвращаемого значения
или void для функций, которые не возвращают значений.
Если тип функции опустить, то по умолчанию тип будет
int. Оператор return в теле функции должен содержать
выражение, тип которого совпадает с типом функции.
Для функций void этот оператор отсутствует или пустой
(return;).
     2. Имя функции. Это имя main для главной функции
программы или любое, не совпадающее с ключевыми сло-
вами и именами других объектов программы.
     3. Формальные параметры функции. Это перечислен-
ные через запятую имена аргументов функции вместе с их
типами или void, если параметров нет.
     Формальные параметры функции — это ее внешние
данные. Это название подчеркивает, что данные описа-
ния формальны, т. е. не участвуют в реальных действиях,
а только описывают взаимосвязь данных в теле функции.
За д ач и и у п р аж н е н и я                            267


Количество формальных параметров функции и их типы
могут быть любыми.
    Тело функции содержит: 1) описание алгоритма;
2) описания локальных переменных, если они необхо-
димы (их областью действия является тело функции);
3) возврат в точку вызова (оператор return, который может
отсутствовать для функций типа void).

                            Обращение к функции
   Обращение к функции — это реальное выполнение ал-
горитма, каждый раз с различными входными данными.
Выполняется из любой другой функции программы с ис-
пользованием механизма вызова функции через опера-
цию обращения. Обращение к функции зависит от типа
функции и может иметь две формы.
   1. Оператор-выражение. Если функция возвращает
значение, то им является одно значение базового типа или
указатель. Оно может быть использовано в выражениях
или печати в виде обращения к функции, которое имеет
специальное название «оператор-выражение»:
переменная = имя(фактические параметры);
printf("форматная_строка ",
??? имя_функции (фактические_параметры));
     Например, при обращении к библиотечной функции sin:
y=sin(x)			
// значение функции вычислено и присвоено y
printf("%6.2f", sin(x)); // значение функции напечатано

sin(x); 			
// значение функции вычислено, но что
// происходит с вычисленным значением?
   2. Оператор-функция. Если функция не возвращает
значения (функция типа void), то обращение к ней выгля-
дит как обычный оператор программы и имеет специаль-
ное название «оператор-функция»:
имя_функции(фактические параметры);
    Например, при обращении к библиотечной функции
printf:
printf("%d,%d",a,b);
268                                               Гл а в а 3



   При обращении к функции ей передаются фактиче-
ские параметры. Это выражения, имеющие реальные
значения на момент обращения к функции, с которыми
функция отрабатывает очередной вызов.

      Формальные и фактические параметры функции
    Тип параметров, их количество и порядок следования
называются совместно «сигнатура параметров». В описа-
нии функции и в обращении сигнатуры параметров долж-
ны строго совпадать. Это означает, что формальные и фак-
тические параметры должны соответствовать друг другу
по количеству, типу и порядку следования. При несовпа-
дении типов формальных параметров в описании и факти-
ческих при обращении, в С++ выполняется автоматиче-
ское приведение типов к типу формальных параметров.
    Формальные параметры функции — это имена пере-
менных. Фактические параметры подставляются на ме-
сто формальных при каждом обращении к функции. Они
могут быть в общем случае выражениями, т. е. константа-
ми, переменными или выражениями.

                      Параметры
    В С++ существуют два способа передачи параметров
в функцию.
    1. По значению. При этом создается локальная копия
фактического параметра в теле функции, следовательно,
фактические значения параметров при обращении не мо-
гут быть изменены. Так можно защитить входные данные
от их нежелательного изменения функцией.
    Фактическим параметром, соответствующим фор-
мальному параметру-значению, может быть имя пере-
менной, константа, выражение.
    2. По ссылке. Изменение механизма передачи данно-
го в функцию формально выглядит добавлением знака &
к имени формального параметра:
имя_функции (тип_параметра &имя_параметра);
   При этом функция и вызывающая программа работа-
ют с адресом объекта в памяти, следовательно, функция
может изменить значение параметра.
За д ач и и у п р аж н е н и я                                   269


   Фактическим параметром, соответствующим фор-
мальному параметру-ссылке, может быть только имя пе-
ременной.
   Пример 6.1. Функция с одним параметром, возвраща-
ющая значение. Функция имеет тип, имя, один параметр.
Приведем пример описания функции, которая вычисляет
значение некоторой функции в указанной точке, напри-
мер, y=x2.
float sqr(float x)		             // имя функции sqr
{
   return x*x;		                 // одно возвращаемое значение
}
   При обращении к функции используется оператор-
выражение. Фактическим параметром может быть кон-
станта, переменная или выражение.
#include <stdio.h>
void main(void)
{
  float a, b;
  a=2.;
  b=sqr(a);      // фактический параметр – переменная
  printf("\n%f", b);
  b=sqr(3.5); // фактический параметр – константа
  printf("\n%f", b);
  b=(a+1.1);     // фактический параметр – выражение
  printf("\n%f", b);
  // запись обращения сокращается, если использовать
  // обращение в функции вывода.
  printf("\n%f", sqr(b));
  printf("\n%f", sqr(3.5));
  printf("\n%f", sqr(a+b*5.));
}
   Пример 6.2. Функция со многими параметрами, воз-
вращающая значение. Функция имеет тип, имя, несколь-
ко параметров. Приведем пример описания функции, ко-
торая находит среднее арифметическое трех чисел. Имя
функции Avg. Тип функции и ее параметров float.
float Avg(float a, float b, float c)
{
270                                                       Гл а в а 3



    float S;      // локальная переменная
    S=(a+b+c)/3.;
    return S;     // тип совпадает с типом функции
}
   Можно привести пример простой записи той же функ-
ции.
float Avg(float a, float b, float c)
{
   return (a+b+c)/3.;        // тип совпадает с типом функции
}
   При обращении к функции используется оператор-
выражение. Фактическим параметром может быть кон-
станта, переменная или выражение.
#include <stdio.h>
void main(void)
{ // фактические параметры – переменные.
?? // результат присвоен y
  float x1=2.5, x2=7., x3=3.5;
  float y=Avg(x1,x2,x3);
  printf("x1=%f, x2=%f, x3=%f, y= %f\n",x1,x2,x3,y);
  // фактические параметры – константы. Результат
                                                    присвоен y
  y=Avg(2., 4., 7.);
  printf("x1=%f, x2=%f, x3=%f y= %f\n" ,2.,4.,7.,y);
  // фактические параметры – выражения
  // результат выводится на печать
  printf("x1=%f, x2=%f, x3=%f, y= %f\n",x1,x2,x3,y);
}
   Пример 6.3. Функция, возвращающая значение. Ал-
горитм функции может быть достаточно сложный. При-
ведем пример описания функции, вычисляющей сумму n
чисел натурального ряда.
int Sum(int n)
{
int S=0;            // переменная для накопления
                    // значения суммы
int i;              // параметр цикла для суммирования
for(i=1; i<=n; i++) // цикл завершается при i>n
   S+=i;
За д ач и и у п р аж н е н и я                            271


return S;
}
   В этом примере локальная переменная S необходима,
этого требует реализация алгоритма, а переменная i мо-
жет осутствовать. Зная, что параметр, передаваемый по
значению, не изменяется функцией, его можно исполь-
зовать как рабочую переменную для управления циклом.
По завершении работы функции фактический параметр
имеет то же значение, что и до обращения.
int Sum(int n)
{
   for(int S=0; n>0; n– –) // при n=0 цикл будет завершен
?? S+=n;
   return S;
}			                       // функция не изменит значения n
   Имя любого локального данного не должно совпадать
с именем функции. Вот пример распространенной ошиб-
ки, когда имя функции совпадает с именем ее локального
данного. Результат в этом случае непредсказуем.
int Sum(int n)
{
   int Sum=0;
   int i;
   for(i=1; i<=n; i++)
?? Sum+=i;
   return Sum;
}
    Пример 6.4. Функция, не возвращающая значения
и не имеющая параметров.
    Приведем пример описания функции, которая выводит
на экран 50 символов «звездочка». Имя функции print. Спи-
сок формальных параметров пуст. Функция не возвращает
значения, поэтому не имеет в своем теле оператора return.
#include <stdio.h>
void print(void) // функция типа void, не возвращает значения
{
  int i;		        // внутренняя рабочая переменная
  for(i=1;i<=50; i++)
?? printf("%c", '*');     // вывод символа "звездочка"
272                                                      Гл а в а 3



    printf("\n");
}
   При обращении к функции используется оператор-
функция. Фактические параметры не передаются, одна-
ко скобки после имени функции опускать нельзя. Обра-
щение к функции выполняется дважды.
void main(void)
{
  print();			                 // обращение к print()
  printf("\tПример вызова функции.\n");
  print();
}
   Вывод на экран будет иметь вид:
 **************************************************
   Пример вызова функции.
 **************************************************
   Приведем пример использования функции с параме-
трами, которая не возвращает значения.
   Функция выводит на экран произвольное количество
символов «звездочка» и не возвращает значения. Количе-
ство произвольно, значит, его значение может быть опре-
делено только на момент обращения к функции, поэтому
оно является параметром функции.
#include <stdio.h>
#include <conio.h>
void print(int count)     // печать строки "*" длиной count
{
  int i;
  for(i=1; i<=count; i++)
  // count – количество символов в строке
?? printf("%c", '*');
  printf("\n");
}
   Если задуматься о том, почему же именно звездочки
нужно печатать, можно вынести в список параметров еще
и вид выводимого символа, тогда функция будет иметь
два параметра, один из которых будет обозначать коли-
чество выводимых символов, а второй — их вид. Второй
параметр функции имеет тип char.
За д ач и и у п р аж н е н и я                               273


void print(int count, char symbol)
// печать строки символов symbol длины count
{
   int i;
   for(i=1; i<=count; i++)
   // count – количество символов в строке
?? printf("%c", symbol);
   printf("\n");
}
   При обращении к функции оператор-функция может
использоваться в цикле. Фактический параметр один. На
экран будет выведено 12 строк, в первой строке один сим-
вол, в каждой последующей на один больше.
void main(void)
{
  int cou;
  clrscr();
  for(cou=1; cou<=12; cou++)
?? print(cou);
  // здесь соu – количество символов при обращении
  getch();
}
   При обращении к функции с двумя параметрами пер-
вый фактический параметр означает число выводимых
символов, второй — вид символа. Оператор-функция вы-
водит при первом обращении 80 символов тире («–»), при
втором 25 символов плюс («+»). При первом обращении
фактические параметры — константы, при втором — пе-
ременные.
void main(void)
{
  char ch;
  ch='+';
  int    cou=25;
  print(80, '–');		              // 80 символов тире ("–")
  print(cou, ch);		              // 25 символов плюс ("+")
  getch();
}
274                                                   Гл а в а 3



    Пример 6.5. Логические функции. Логические функ-
ции используются всегда, когда нужно выполнить про-
верку условия, как правило, сложного, или в алгоритмах
поиска. Функция возвращает одно значение логическо-
го (целочисленного) типа. Интерпретация соответствует
принятой идеологии: ложно то, что равно 0, истинно то,
что отлично от 0 (не обязательно 1). Это правило исполь-
зуется при вычислении значений логических выражений,
а также при проверке условий в операторе if и в операто-
рах цикла.
    Замечание. Напоминаем, что компилятор Visual
Studio 2013 в качестве логического типа позволяет ис-
пользовать тип bool.
    Примером логической функции с простым алгорит-
мом может служить функция определения четности чис-
ла. Функция должна вернуть значение логического выра-
жения «остаток от деления числа на два равен 0».
int Chet(int num)      // функция возвращает логическое
			                    // значение
{
   return num%2==0;    // остаток от деления на два
}
   Примером логической функции с довольно сложным
алгоритмом может служить алгоритм определения, явля-
ется число простым или нет. Как известно, натуральное
число является простым, если оно не имеет делителей,
кроме 1 и самого себя. Для того чтобы найти, есть дели-
тели или нет, нужно последовательно делить число на все
числа натурального ряда, которые могут быть его дели-
телями, начиная с двух до значения, равного половине
самого числа. Как только делитель найден, дальнейшие
проверки не имеют смысла, так как уже известно, что
число не является простым. Если же выполнены все воз-
можные проверки и ни один делитель не найден, то число
простое.
int Easy(int num) // функция возвращает логическое значение
{
   int mod;      // делитель числа, управляющая переменная
   // управление по возможным значениям делителей числа
За д ач и и у п р аж н е н и я                         275


  for(mod=2; mod<=num/2; mod++)
?? if(num%mod==0)
?? return 0;   // прерывание поиска, делитель найден
  return 1;    // поиск завершен по управлению
}
    При обращении к функции имеет смысл выполнить
проверку, четно число или нет, так как любое четное чис-
ло не является простым.
#include <stdio.h>
#include <conio.h>
void main(void)
{
  int Number;
  do
  {
?? printf("Введите число\n");
?? scanf("%d", &Number);
?? if(!Chet(Number)&&Easy(Number))
??? printf("Число простое\n");
?? else
??? printf("Число не простое\n");
?? printf("Продолжение – любая клавиша, выход – Esc\n");
  } while(getch()!=27)
}
   Логика оператора условия звучит как перевод с рус-
ского на С++. Однако, если эта запись вызывает трудности
в понимании, используйте явные проверки соответствия
возвращаемого значения логической константе: 1— это
«истина», 0 — это «ложь».
if(Chet(Number)!=0)      // число нечетно
{
   if(Easy(Number)==1) // число простое
?? printf("Число простое\n");
}
else
   printf("Число не простое\n");
    Пример 6.6. Несколько слов о роли оператора return и о
сложности алгоритма функции. Оператор return относит-
ся к операторам управления программой. Его назначение
276                                                           Гл а в а 3



не только определить и вернуть вычисленное функцией
значение, но и прервать работу алгоритма функции, вы-
полнив выход из нее правильным образом. Синтаксис
оператора return имеет две формы:
return Выражение;
return;
    Первая форма используется для функций, возвращаю­
щих значение, вторая для функций типа void. В любом
случае оператор return прервет выполнение алгоритма
функции и передаст управление в точку вызова.
    Рассмотрим пример функции, которая возводит ве-
щественное число в целочисленную степень. Для данной
задачи фактически возможны три алгоритма, три ветви,
выбор одной из которых зависит от входных данных.
Для положительной степени вычисляется простое про-
изведение n сомножителей, для отрицательной степени
значение равно дроби 1/(произведение n сомножителей),
а для нулевой степени значение всегда равно 1. Решение
начинается с анализа входных данных и, в зависимости
от степени сразу расходится на три независимые ветки,
каждая из которых заканчивается своим выходом со сво-
ими данными.
// в алгоритме этой функции три варианта выхода
float pow_1(float x, int n) // основание float, степень int
{
   float S;		               // локальная переменная
   if(n>0)		                // положительная степень
   {
?? for(S=1.0; n>0; n––)
??? S*=x;
?? return S;		              // решение найдено при n>0
   }
?? else
?? if(n<0)		                // отрицательная степень
??? {
???? for(S=.0; n<0; n++)
????? S*=x;
???? return 1./S;           // решение найдено при n<0
??? }
За д ач и и у п р аж н е н и я                             277


?? else
??? return 1.0;         // решение найдено при n=0
  printf("Кому нужны эти функции?");
  // оператор вне всех ветвей
  // он никогда не будет выполнен
}
    Этот алгоритм интересен еще и тем, что механизм
передачи параметров по значению защищает внешние
данные от изменения их функцией. Это позволяет не
вводить рабочую переменную для управления циклом
в теле функции, а использовать входное данное n в каче-
стве рабочей переменной. При входе в функцию ей будет
передано входное значение n. В процессе выполнения
алгоритма функция изменяет n, но не внешнее данное,
а его локальную копию. По завершении работы функции
внешняя переменная имеет то же самое значение, что
и при входе.
#include <stdio.h>
void main(void)
{
  int n;
  float x;
  printf("Введите вещественное основание и целую
         степень\n");
  scanf("%f%d", &x, &n);
  printf("\n Данные и решение: %6.2f %4d %6.2f\n", x, n,
         pow_1(x,n));
}
    Пример 6.7. Если функция возвращает через параме-
тры более одного значения, используется механизм пере-
дачи данных через параметры по ссылке. Синтаксически
в заголовке функции к имени параметра добавляется сим-
вол "&", например int &Cou. Технически радикально изме-
няется механизм передачи данных: в этом случае в тело
функции передается адрес объекта Cou, который выделен
для него в вызывающей программе. Иллюстрацией от-
личия двух механизмов передачи данных будет пример
функции, которая должна переменить значения двух пе-
ременных.
278                                             Гл а в а 3



// функция Swap1 с параметрами по значению
void Swap1(int x, int y)
{
   int tmp;
   tmp=x;
   x=y;
   y=tmp;		
// переменные переменились своими значениями
}

// функция Swap2 с параметрами по ссылке
void Swap2(int &x, int &y)
{
   int tmp;
   tmp=x;
   x=y;
   y=tmp;		
// переменные переменились своими значениями
}
   Как видим, функции одинаковы во всем, кроме меха-
низма передачи параметров. Обратимся к этим функциям
одинаковым образом, получим разный результат.
void main(void)
{
  int a=5, b=10;
  printf("Исходные значения: a=%d b=%d\n", a, b);
  Swap1(a, b);
  printf("Передача по значению: a=%d b=%d\n", a, b);
  Swap2(a, b);
  printf("Передача по ссылке: a=%d b=%d\n", a, b);
}
    Вывод на экран покажет, что функция Swap1 работа-
ет с локальными копиями данных, а Swap2 — с адресами
данных.
Исходные значения: a=2 b=10
Передача по значению: a=2 b=10
Передача по ссылке: a=10 b=2
   Пример 6.8. Еще один пример функции, возвращаю-
щей значение через параметры, покажет, что такая функ-
За д ач и и у п р аж н е н и я                                 279


ция не всегда типа void, а возвращаемое ею значение рас-
ширяет логику задачи, добавляя функции новый смысл.
    Пусть функция находит площадь и периметр треу-
гольника, заданного длинами сторон. Возвращаемых зна-
чений два: площадь и периметр, следовательно, их нужно
возвращать через параметры. Функция будет возвращать
значение типа int, смысл которого заключается в провер-
ке условия существования треугольника. Если треуголь-
ник существует, функция вернет 1, если не существует,
вернет 0.
#include <stdio.h>
#include <math.h>
int Triangle(float a,float b,float c,float &p,float &s)
{
// переменные p и s – внешние данные, могут быть
// входными и выходными
   float pp;		
   // полупериметр, локальная переменная
   if(a+b<=c || a+c<=b || b+c<=a)
?? return 0;		              // треугольник не существует
   else
   {
?? p=a+b+c;
?? pp=p/2.;
?? s=sqrt(pp*(pp–a)*(pp–b)*(pp–c));
?? return 1;		              // треугольник существует
   }
}
   При обращении к функции учтем две особенности. Во-
первых, функция приобрела статус логической функции.
Это означает, что после обращения к ней нужно проана-
лизировать возвращенный результат. Во-вторых, фак-
тическими параметрами, подставляемыми на место фор-
мальных параметров-ссылок, при обращении могут быть
только имена переменных.
void main(void)
{
float A,B,C;		                   // длины сторон фактические
float Perim, Square;             // периметр и площадь фактические
280                                                   Гл а в а 3



printf("Введите длины сторон треугольника\n");
scanf("%f%f%f", &A,&B,&C);
if(Triangle(A,B,C,Perim,Square)==1)     // проверка условия
   printf("Периметр=%6.2f, площадь=%6.2f\n", Perim, Square);
else
   printf("Треугольник не существует\n");
}
   Пример 6.9. Функция, возвращающая указатель. Та-
кие функции используются, когда тип возвращаемого
данного не является простым, например возвращается
массив, или когда в теле программы получено новое дина-
мическое значение.
   Пусть параметры функции две целочисленные пере-
менные. Если первый параметр больше второго, функция
создает новый объект со значением 1, иначе функция не
создает объект и возвращает пустой адрес (NULL). Возвра-
щаемое значение — это адрес вновь созданного объекта
или пустой указатель NULL. Тип функции — указатель на
целое. Возвращаемое значение должно быть присвоено
указателю, объявленному в вызывающей программе.
#include <stdio.h>
#include <conio.h>
#include <math.h>
int *New_obj(int a, int b) // тип функции указатель
{
   int *Obj;
   // новый объект будет создан или нет в функции
   if(a>b)
   {
?? Obj=new int;            // создается новый объект
?? *Obj=1;		               // ему присваивается значение
?? return Obj;		           // возвращается его адрес
   }
   else
?? return NULL;
}
      В вызывающей программе объявлен указатель int *ip,
которому будет присвоено возвращаемое значение.
void main(void)
За д ач и и у п р аж н е н и я                           281


{
  int p1, p2;   // переменные
  int *ip;      // указатель на новый объект
  printf("Введите две переменные\n");
  scanf("%d%d", &p1, &p2);
  // обращение к функции обычное
  ip=New_obj(p1, p2);
  if(ip!=NULL)
?? printf("Адрес нового объекта=%p, значение=%d\n", ip, *ip);
  else
?? printf("Новый объект не создан, использовать ip нельзя,
	? его значение
???????? %s\n", ip);
}
     В первом операторе вывода на экран для адреса ip ис-
пользован спецификатор формата %p, во втором для вы-
вода константы NULL использован спецификатор формата
%s, чтобы увидеть текстовое представление константы.
Если для вывода NULL использовать спецификатор %p,
адрес выводится как 0000.

                                 Варианты заданий
    Задание 1. Описать функцию F(x), вычисляющую
значение периодической функции в произвольной точке.
Период функции T = 2. На интервале [–1; 0] она совпа-
дает с функцией y = x + 1, на интервале (0; 1) совпадает
с функцией y = –x + 1. Обратиться к функции на интерва-
ле x ? [–2; +4] с не менее чем десятью точками.
    Задание 2. Описать логическую функцию Yes(x, y), ко-
торая определит, принадлежит ли точка с координатами (x,
y) единичной окружности, центр которой совпадает с нача-
лом координат. Обратиться к функции с координатами то-
чек, лежащими на параболе y = x2 для x ? [–2; +2], шаг 0.5.
    Задание 3. Описать логическую функцию Is_letter(c),
которая определит, является ли некий произвольный
символ c (параметр функции) одной из строчных или за-
главных букв русского алфавита. Обратиться к функции
в диалоге, передавая ей посимвольно текст, вводимый
с клавиатуры.
282                                                       Гл а в а 3



   Задание 4. Описать функцию S(x, ?), вычисляющую
значение суммы ряда в точке x с указанной точностью ?,
если формула суммы:
                             x x x
                     S=x?     + ? + ...
                             2 3 4
    Обратиться к функции в диалоге с координатами то-
чек x ? [–0.5; +0.5], шаг 0.1.
    Задание 5. Описать функцию Is_Tri(a, b, c), которая
по значениям длин трех отрезков a, b, c определит, можно
ли построить треугольник с такими сторонами. Обратить-
ся к функции в диалоге.
    Задание 6. Описать функцию Pi(?), вычисляющую
значение числа ? по формуле
                    ? 2?4 4?6 6?8
                     =   ?   ?     ?...
                    2 3?3 5?5 7 ?7
с произвольной точностью ?. Значение точности передать
в функцию как аргумент. Обратиться к функции в цикле,
вычисляя значение с точностью 0.01, 0.001, 0.0001.
    Задание 7. Описать функцию P(x), вычисляющую зна-
чение полинома в произвольной точке x по формуле
              P(x) = 1 + x + x2 + x3 + x4 + … x50.
    Обратиться к функции в диалоге со значениями
x ? [–0.5; +0.5] с шагом 0.1.
    Задание 8. Описать функцию Min(x, y, z), которая вер-
нет значение наименьшего из трех своих аргументов. Об-
ратиться к функции в диалоге.
    Задание 9. Описать функцию Square(a, b, c), которая
найдет площадь треугольника по значениям длин сторон
a, b, c. Если треугольник не существует, функция вернет
значение 0. Обратиться к функции в цикле со значениями
длин сторон (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6) и т. д. до
(10, 11, 12).
    Задание 10. Описать функцию Transform(n), которая
преобразует натуральное число n, «приписывая» к нему
по единичке в начале и в конце. Обратиться к функции
в диалоге со значениями 23, 234, 2345.
За д ач и и у п р аж н е н и я                      283


    Задание 11. Описать функцию R(x1, y1, x2, y2), кото-
рая вычисляет расстояние между двумя точками на ко-
ординатной плоскости. Обратиться к функции в диалоге,
чтобы определить расстояния между началом координат
и вершинами некоторого квадрата, заданного координа-
той верхнего левого угла и длиной стороны.
    Задание 12. Описать функцию Count(r), которая опре-
делит, сколько точек с целочисленными координатами
попадают в круг радиуса R с центром в начале координат.
Обратиться к функции в диалоге.
    Задание 13. Описать логическую функцию P(x), кото-
рая определит, является ли ее аргумент x простым чис-
лом. Обратиться к функции в диалоге со значениями чи-
сел натурального ряда от 7 до 99.
    Задание 14. Описать функцию R(a, b, c), определяю-
щую радиус вписанной окружности для треугольника
со сторонами a, b, c. Предусмотреть условие существо-
вания треугольника. Если он не существует, функция
должна вернуть значение 0. Обратиться к функции
с равносторонними треугольниками со сторонами 2, 3,
4, 5, 6.
    Задание 15. На плоскости даны две окружности. Опи-
сать логическую функцию Yes, которая определит, имеют
ли окружности точки пересечения. Возможны варианты:
окружности не пересекаются, окружности пересекают-
ся, окружности касаются, окружности концентрические.
Возвращать значение номера варианта или текстовую
строку, содержащую значение соответствующего текста.
Обратиться к функции в диалоге.
    Задание 16. Описать функцию S(a, b, h), которая най-
дет площадь равнобочной трапеции с заданными основа-
ниями и высотой. Обратиться к функции в диалоге.
    Задание 17. Описать функцию Square(r1, r2), которая
найдет площадь кольца с заданными радиусами. Если
первый параметр меньше второго, возвращать значение
0. Обратиться к функции в диалоге.
    Задание 18. Описать функцию S_C(r, angle), которая
найдет значение площади сектора круга с заданными зна-
чениями радиуса и угла (в градусах). Если угол отрица-
284                                              Гл а в а 3



тельный или больше 360°, возвращать значение 0. Обра-
титься к функции в диалоге.
    Задание 19. Описать функцию Sum_AP(a1, d, n), ко-
торая найдет сумму арифметической прогрессии. Преду-
смотреть проверку исходных данных, и в случае ошибки
возвращать значение 0. Обратиться к функции в диалоге.
    Задание 20. Описать функцию Is_in(x1, y1, x2, y2,
x3, y3), которая по заданным координатам вершин тре­
уголь­ника определит, находится ли начало координат
внутри этого треугольника. Возвращать значение –1, если
треугольник не существует, 0, если снаружи, и 1, если
внутри. Обратиться к функции в диалоге.
    Задание 21. Описать функцию R(long int N), которая
по заданному значению произвольного натурального чис-
ла определит его разрядность. Обратиться к функции со
значениями 3, 13, 130, 1300, 13 000.
    Задание 22. Описать логическую функцию Yes(N),
которая по заданному значению пятизначного натураль-
ного числа определит, является ли оно палиндромом.
Предусмотреть анализ входных данных. Если они заданы
некорректно, функция вернет значение –1. Обратиться
к функции в диалоге.
    Задание 23. Описать функцию Kvadr(x, y), которая
по заданным координатам точки определит номер четвер-
ти координатной плоскости, где находится точка. Если
точка на осях координат, вернуть значение 0. Обратить-
ся к функции, передавая ей поочередно значения (1, 1),
(–1, 1), (–1, –1), (1, –1), (0, 0).
    Задание 24. На плоскости даны окружность радиуса R
и отрезок координатами концов. Описать логическую функ-
цию, которая определит, находится ли отрезок полностью
внутри окружности. Обратиться к функции в диалоге.
    Задание 25. Описать функцию Sum(x, n), которая най-
дет сумму знакопеременного ряда вида
                     1 1 1                  1
             S =1?    + ? + ... + (?1)k +1 ? .
                     2 3 4                  k
   Обратиться к функции в цикле со значениями k = 50,
100, 150, 200.
За д ач и и у п р аж н е н и я                              285


   Задание 26. Описать функцию Pi(eps), которая нахо-
дит значение числа ? по формуле произведения
                           ? 2 2 4 4 6 6
                            = ? ? ? ? ? ? ...
                           2 1 3 3 5 5 7
с указанной точностью eps.
    Обратиться к функции со значениями точности 0.01,
0.001, 0.0001.
    Задание 27. Описать функцию, которая найдет объем
цилиндра, если заданы радиус основания и высота. Обра-
титься к функции, чтобы найти объемы цилиндров высо-
той Н = 12, 13, 14, 15 см и для каждой высоты с радиуса-
ми основания R = 5, 10, 15, 20 см.
    Задание 28. Описать функцию, которая находит зна-
чение многочлена вида
                   Р(х) = 1 + х + х2 + х3 + х4 + ... + хn
для заданных значений x и n. Обратиться к функции при
n = 10 со значениями х ? [–0.9; +0.9], шаг 0.1.
    Задание 29. Описать функцию, которая возводит про-
извольное число с плавающей точкой в целочисленную
положительную или отрицательную степень путем мно-
гократного умножения (в цикле). Обратиться к функции,
передавая ей поочередно значения х ? [–2; +2]. Для каж-
дого х вычислять положительную степень, отрицатель-
ную и нулевую.
    Задание 30. Два интервала числовой оси заданы коор-
динатами своих концов. Описать логическую функцию,
которая определит, имеют ли эти интервалы общие точки.
Корректность данных проверить. Если интервалы заданы
некорректно, функция вернет значение –1. Обратиться
к функции в диалоге.

     Тема 7. Работа с одномерными массивами
   Прежде чем приступить к программированию задач
этого раздела, необходимо четко знать ответы на следую-
щие вопросы.
   1. Что такое массив?
286                                                Гл а в а 3



    2. Как описать массив?
    3. Как размещаются в памяти элементы массива?
    4. Как обратиться к элементу массива?
    5. Как присвоить значения элементам массива?
    Следуя правилам модульного подхода в программиро-
вании, мы здесь и далее будем использовать функции для
решения задач обработки данных, тем более что основных
алгоритмов немного. Выделите абстрактный алгоритм,
опишите и отладьте функцию, и вы можете пользовать-
ся ею, как говорится, всю оставшуюся жизнь. Функции
программиста компонуются в библиотеки. Для библиотек
исходных текстов используются заголовочные файлы.
Тексты этих файлов инклюдируются в код программы
пользователя и компилируются вместе с ней. Исходные
тексты функций можно заранее откомпилировать и хра-
нить в виде объектного кода (файлы с расширением .obj).
Тогда в отдельный заголовочный файл, который также
инклюдируется в код программы пользователя, выносят-
ся только прототипы функций, содержащихся в объект-
ной библиотеке.
    Важной особенностью механизмов С++ является то,
что имя массива — это указатель на нулевой элемент. Ког-
да параметром функции является массив, то в функцию
передается адрес массива. Это означает, что механизм пе-
редачи осуществляется по адресу, и функция возвраща-
ет измененный массив. Поясним синтаксис и механизм
передачи в функцию массива.
    Пусть в вызывающей программе объявлен массив
int Array[10];
     Имя Array — это адрес нулевого элемента массива.
   В записи заголовка функции, которой передается це-
лочисленный массив (любой, не обязательно Array), фор-
мальный параметр должен быть указателем. Синтаксиче-
ски это можно записать двумя способами.
void Function1(int Array[], int len)
{
  for(int i=0; i<len; i++)
?? // обращение к Array[i]
}
За д ач и и у п р аж н е н и я                          287


    Пустые скобки у формального имени массива в списке
параметров подчеркивают, что передается адрес массива.
Длина массива, если ее не передавать, будет равна длине
массива в вызывающей программе (как он там объявлен,
в данном примере 10).
void Function2(int *Array, int len)
{
  for(int i=0; i<len; i++)
?? // обращение к Array[i]
}
    Признак "*" у формального имени массива в списке
параметров означает, что функция получает указатель на
массив, т. е. при обращении фактически передается адрес
массива в памяти.
   При обращении к функции фактическим параметром
должно быть имя любого целочисленного массива, кото-
рый объявлен в вызывающей программе и получил в ней
значения.
Function1(Array, 10); // передается весь массив
Function2(Array, 5); // передается весь массив, но его длина
                      // ограничена значением, равным 5
    Еще раз подчеркнем, что массив передается по адресу,
функция может изменить элементы массива, и это станет
известно вызывающей программе.
    Теперь поясним, как функция возвращает массив.
    Первый способ возвращения массива из функции,
через список параметров, был показан выше. Переда-
ча массива в функцию через формальный параметр —
это одновременно и его возвращение после вызова
функции.
    Второй способ используется, когда массив возвращает-
ся через имя функции. Тип функции должен быть указа-
телем (он будет содержать адрес массива в памяти). В теле
функции должен быть оператор return, возвращающий
адрес массива. В вызывающей программе возвращаемое
значение должно быть присвоено указателю. Указатель
должен быть объявлен в главной программе и должен
адресовать такую область памяти, которая способна вме-
стить в себя весь массив.
288                                                  Гл а в а 3



      Синтаксически это можно записать так:
int *Function3(int *Array, int len)
{
   for(int i=0; i<len; i++)
?? // обращение к Array[i]
   return Array;
}
    В том примере мало смысла, так как массив содержит-
ся в списке параметров.
    Имеет смысл использовать второй способ для динами-
ческих массивов, создаваемых в теле функции. Например,
функция создает динамический массив указанной длины. Ди-
намическая память для массива выделена в теле функции.
int *New_Arr(int len)        // тип функции указатель
{
   int *Array=new int[len];
   // выделено len*sizeof(int) байт памяти,
   // ее адрес присвоен переменной Array
   for(int i=0; i<len; i++)
?? *(Array+i)=i+1; // присвоены значения по возрастанию
return Array;          // адрес необходимо вернуть
}
   Вызывающая программа должна быть готова к полу-
чению нового данного. Для этого в ней объявлен указа-
тель. До обращения к функции он пустой и примет зна-
чение только после обращения. Возвращаемое функцией
значение присваивается указателю.
#include <stdio.h>
void main (void)
{
  int *Array;			              // пустой указатель
  int len_A;
  printf("Введите длину массива\n");
  scanf("%d", &len_A);
  Array=New_mas(len_A);       // теперь он получил адрес
  for(int i=0; i<len_A; i++)
?? printf ("%3d",Array[i]);
  printf("\n");
}
За д ач и и у п р аж н е н и я                        289


    Приведем полный текст файла, содержащего мно-
жество функций, реализующих различные алгоритмы
работы с массивами. Это отдельный файл, который хра-
нит абстрактное описание алгоритмов. Такие файлы мо-
гут быть доступны многим программам. Следует создать
заголовочный файл с расширением имени файла "имя.
hpp" или "имя.h". Далее этот файл с помощью директивы
#include легко можно подключить к любой программе,
которой требуется обработка массивов. Например, если
имя заголовочного файла "Task.h" ("Task.hpp"), то он будет
доступен любой программе, в тексте которой есть дирек-
тива
#include "Task.h"
    Физически файл может находиться в том же директо-
рии, в котором находится использующая его программа
(по умолчанию). Он может размещаться в системной ди-
ректории, путь к которой прописан в настройках инте-
грированной среды разработчика. Третий вариант — это
собственная директория include, на которую дополнитель-
но нужно настроить интегрированную среду.
    Каждый пример — это описание решения какой-
нибудь задачи для массивов в общем виде, т. е. безот-
носительно к способу создания и инициализации масси-
ва. В каждой задаче значимыми параметрами массива
являются тип элементов и количество (длина массива),
которые являются параметрами функций. В этом при-
мере используются статические массивы, в том числе
массивы переменной длины. Для сканирования элемен-
тов массивов используется либо адресация с помощью
индексов (прямая), либо адресация с использованием
указателей (косвенная). В любом случае массивы можно
считать массивами условно переменной длины, так как
функция получает длину массива в виде переменной ве-
личины.
#include <stdio.h>
#include <math.h>
   Пример 7.1. Вывод на экран целочисленного массива
в общем виде. Формальные параметры — имя массива
(указатель) и длина массива.
290                                                           Гл а в а 3



void Print_mas(int mas[], int len)   // len – длина массива
{
  int i;				                         // рабочая переменная
  printf("Массив:\n");		             // вывод заголовка
  for(i=0; i<len; i++)
?? printf("%5d",mas[i]);             // вывод элемента массива
				                                 // в строку
  printf("\n");			                   // переход на новую строку
}
    Пример 7.2. Функция ввода целочисленного массива
в общем виде. Формальные параметры — имя массива
(указатель) и длина массива. Длина массива определена
в теле функции. Чтобы функция могла вернуть это значе-
ние, формальный параметр len передается по ссылке.
void Input_mas(int *mas, int &len)
// длина массива изменяется, &len – ссылка
{
   int *ip;
// для адресации используется указатель на элемент массива
   printf("Введите количество элементов массива \n");
   scanf("%d", &len);
   printf("Введите элементы массива \n");
   for(ip=mas; ip<mas+len; ip++)
?? scanf("%5d", ip)		             // & не нужен
}
   Пример 7.3. Преобразовать целочисленный массив,
увеличив значение каждого элемента в 2 раза. Массив пе-
редается в функцию как указатель. Измененные в функ-
ции значения элементов массива доступны и вызывающей
программе.
// формальные параметры – имя массива (указатель)
// и длина массива
void Transform_mas(int *mas, int len)
// длина не изменяется, len – ее значение
{
   int i;
   for(i=0; i<len; i++)
?? mas[i]=mas[i]*2;
}
За д ач и и у п р аж н е н и я                              291


   Пример 7.4. Поиск в массиве. Для массива задан кри-
терий отбора, которому должны соответствовать элемен-
ты массива. Простейшим способом решения задачи яв-
ляется прямой поиск, блок-схема алгоритма приведена
в п. 1.6.1 (глава 1). Согласно алгоритму условие отбора
примеряется по очереди ко всем элементам, и для тех эле-
ментов, которые соответствуют условию, выполняется
определенное действие.
   Для примера найдем все числа, кратные пяти.
   1. Поиск всех вхождений значения.
void Find_all(int mas[], int len)
{
  for(int i=0; i<len; i++)
  if(mas[i]%5==0)
?? // здесь с этим элементом можно что-нибудь сделать,
?? // например, вывести
?? printf("Кратен пяти элемент с номером %d", i);
}
   Замечание. В случае, когда в массиве нет ни одного ис-
комого значения, функцией будет выполнено len сравне-
ний, но никакого сообщения пользователь не получит.
   2. Поиск первого вхождения значения. Особенностью
алгоритма является то, что при первом же удачном срав-
нении он должен закончить свою работу. Если нужного
элемента не окажется, то выход из функции произойдет
при завершении цикла, и результатом должно быть зна-
чение, отличное от любого номера элемента массива, на-
пример, –1. Блок-схема алгоритма поиска первого вхож-
дения элемента, имеющего определенное значение приве-
дена в п. 1.3.5 (глава 1).
int Find_first(int mas[], int len)
{
   // поиск первого вхождения числа, кратного пяти
   for(int i=0; i<len; i++)
?? if(mas[i]%5==0)
??? return i; // прерывание при найденном значении
		                  // функция вернет номер вхождения
   return –1;       // неудачный поиск, функция вернет –1
}
292                                                 Гл а в а 3



    При обращении к функции надо учесть, что значение
–1, которое она возвращает, означает неудачный поиск.
Num=Find_first(A, 5);
if(Num>=0)
   printf("Номер элемента, равного 5 %d\n", Num);
else
   printf("Элемент не найден");
     Пример 7.5. Найти сумму элементов одномерного мас-
сива. Блок-схема алгоритма нахождения суммы элемен-
тов одномерного массива приведена в п. 1.3.2 (глава 1).
     Функция возвращает одно значение, поэтому ее тип
int. Приведем пример использования различных спосо-
бов адресации элементов массива, прямую и косвенную.
Выбор способа адресации не зависит от способа передачи
в функцию параметра-массива.
     1. Прямая адресация. Обращение к массиву через опе-
рацию [].
int Sum1(int *mas, int len)
{
   int i;
   int Sum=0;
   for(i=0; i<len; i++)
?? Sum+=mas[i];
   return Sum;
}
   2. Косвенная адресация. Обращение к элементам мас-
сива через операцию "*", примененную к указателю на
очередной элемент массива.
int Sum2(int *mas, int len)
{
   int *ip;
   int Sum=0;
   for(ip=mas; ip<mas+len; ip++)
?? Sum+=*ip;
   return Sum;
}
   3. Косвенная адресация. Обращение к элементам мас-
сива через операцию "*" и смещение указателя относи-
тельно начала массива.
За д ач и и у п р аж н е н и я                               293


int Sum3(int *mas, int len)
{
   int i;
   int Sum;
   for(i=0, Sum=0; i<len; i++)
?? Sum+=*(mas+i);
   return Sum;
}
   Пример 7.6. Вывод на экран номеров и адресов элемен-
тов массива иллюстрирует отличие способов адресации
друг от друга. Спецификатор формата для вывода адре-
са — %р. Так вы увидите реальные адреса памяти, выде-
ленные для размещения массива.
void Out(int *mas, int len)
{
  int i;
  int *ip;
  for(ip=mas, i=0; ip<mas+len; ip++, i++)
?? printf("Номер=%d Адрес=%p\n", i++, ip);
}
   Пример 7.7. Функция поиска наибольшего (наимень-
шего) элемента массива. Блок-схема поиска наибольшего
элемента одномерного массива приведена в п. 1.3.3.
   1. Использование прямой адресации.
int Max1(int mas[], int len)
{
   int i;
   int max;         // наибольшее значение
		                  // пусть первый элемент наибольший
   max=mas[0];
   for(i=0; i<len; i++)
?? if(mas[i]>max) max=mas[i];
// запоминаем наибольшее значение
   return max;		            // возвращаем найденное значение
}
     2. Использование косвенной адресации.
int Max2(int mas[], int len)
{
   int *ip;		              // указатель на элемент массива
294                                                  Гл а в а 3



  int *imax;		          // указатель на наибольшее значение
  imax=mas;		           // запоминаем его адрес
  for(ip=mas+1; ip<mas+len; ip++)
?? if(*ip>*imax) imax=ip; // запоминаем адрес наибольшего
  return imax–mas;      // возвращаем номер наибольшего
}
    Пример 7.8. Функция удаления элемента из мас-
сива. Для определенности удалим все отрицательные
элементы массива. Удаление элемента заключается
в сдвиге части массива влево на одну позицию, начиная
с удаляемого значения. Длина массива уменьшается
на 1 при каждом сдвиге, поэтому длина массива возвра-
щается по адресу. В этом алгоритме объединены поиск
(пример 7.4) и удаление, цикл удаления внутренний,
так как для каждого найденного значения выполняет-
ся сдвиг оставшейся части массива влево на одну по-
зицию. Управление циклом выполняет оператор for, из
которого изъято приращение параметра цикла. Это не-
обходимо, так как приращение номера элемента долж-
но происходить лишь тогда, когда удаления не было.
Это позволит избежать ошибки, когда удаляемые эле-
менты идут подряд.
    Блок-схема удаления одного элемента одномерного
массива приведена в п. 1.3.4 (глава 1).
    Поиск отрицательных элементов выполняется в ци-
кле с рабочей переменной i. Если отрицательный элемент
будет найден, то его номер запомнит эта переменная.
void Del(int mas[], int &len)
{
  int i;            // рабочая переменная для поиска
  int j;            // рабочая переменная для удаления
  for(i=0; i<len; ) // приращение параметра изъято
  {
?? if(mas[i]<0) // элемент должен быть удален
?? {
??? for(j=i; j<len–1; j++)
???? mas[j]=mas[j+1];
???? len––; // уменьшение длины по завершении цикла
?? }
За д ач и и у п р аж н е н и я                             295


?? else
??? i++;                 // переход к следующему поиску,
  }                      // если не было удаления
}
    Пример 7.9. Элементы массива можно менять места-
ми. Например, переставим их по кругу, это называется
циклический сдвиг. Последний элемент не упадет за край
массива, а станет первым.
    Сдвиг массива вправо выполняется начиная с перво-
го элемента до элемента с номером len-1, где len — длина
массива.
void Cyrcle_Mas(int mas[], int len)
{
  // переменная tmp запомнит значение последнего
  // элемента
  int tmp=mas[len–1];
  // сдвиг массива вправо
  for(int i=len-1; i>0; i––)
?? mas[i]=mas[i-1];
  mas[0]=tmp;		
  // запомненный элемент записывается вперед
}
     Пример 7.10. Функция формирования нового масси-
ва. Получим массив, в котором содержатся только поло-
жительные элементы исходного массива. Блок-схема ал-
горитма формирования приведена в п. 1.3.1.
     Все данные должны быть объявлены вне тела функции
и должны быть известны вызывающей программе. Длина
нового массива и его значения получены функцией и воз-
вращаются в вызывающую программу.
     В коде программы переменная len_new индексирует
новый массив. По завершении цикла поиска положитель-
ных элементов найденный элемент записывается в новый
массив. Индексации в массивах различна и переменная
len_new определяет длину нового массива. Она может ока-
заться равной 0, поэтому значение длины нового массива
из функции New_mas возвращается. Функция имеет тип
int, что дает ей статус функции, возвращающей логиче-
ское значение.
296                                                      Гл а в а 3



int New_mas(int mas[],int len, int *mas_new, int &len_new)
{
   len_new=0;			
// в новом массиве нет значений
   // прямой поиск положительных элементов
   for(int i=0; i<len; i++)
?? if(mas[i]>0)			
// положительный элемент найден
??? mas_new[len_new++]=mas[i];
   return len_new;
}
   При обращении к этой функции можно выполнить
проверку значения, возвращаемого функцей. Если воз-
вращаемое значение равно 0, то новый массив не сформи-
рован, в противном случае новый массив можно, напри-
мер, напечатать.
if(New_mas(Array_old, 10, Array_new, len)!=0)
   print_mas(Array_new,len);
    Пример 7.11. Функция может работать с данными ба-
зовых типов, а при обращении ей передаются элементы
массива. Например, функция R находит расстояние меж-
ду двумя точками на плоскости.
float R(float x1, float y1, float x2,float y2)
{
   return sqrt(pow(x1–x2, 2.)+pow(y1–y2, 2.));
}
    Прежде чем привести текст файла, обращающегося
к функциям, описанным в заголовочном файле, обсудим
способы работы с данными, передаваемыми в функции.
Функции все равно, как объявлен и проинициализиро-
ван массив, с которым она работает, важно только, что-
бы любой массив был объявлен и проинициализирован до
момента, когда он будет передан в функцию (до момента
обращения). Способов объявления массива два: статиче-
ский массив или динамический. Способов присваивания
значений элементам массива много — это инициализация
при объявлении, ввод, случайное заполнение, вычисле-
ние по формуле и прочие. Функции для решения многих
из этих задач описаны выше.
За д ач и и у п р аж н е н и я                             297


   В тексте примера будут только объявления перемен-
ных, их инициализация и обращения к функциям.
#include <stdio.h>
#include "Task.hpp"		            // включен текст
заголовочного файла
#define N 10			                  // объявление длины
массива
void main(void)
{
  // объявление и инициализация массива а
  int a[]={1, –2, 3, –4, 5, –6};
  int na=sizeof(a)/sizeof(int);  // длина массива
  Print_mas(a, na); 		           // вывод массива на печать


   // изменим значения элементов массива
   Transform_mas(a, na);

   // покажем, что они изменились
   Print_mas(a, na); // массив условно переменной длины
   int b[N];         // выделена память для N элементов
                     массива b.
   int nb=0;         // реальная длина массива b<N
   printf("Длина массива должна быть < %d", N);

   // ввод значений массива b
   Input_mas(b, nb); // длина будет определена при вводе
   Вычислим сумму элементов массива с помощью трех
функций, использующих различные способы адресации.
   printf("Прямая адресация:    Sum1=%d\n", Sum1(b, nb));
   printf("Косвенная адресация: Sum2=%d\n", Sum2(b, nb));
   printf("Косвенная адресация: Sum3=%d\n", Sum3(b, nb));

   // покажем сходство и различие механизмов адресации:
   Out(b, nb);

  // найдем наибольший элемент массива b:
  printf("Номер=%d, Значение=%d\n", Max1(b, nb),
                                         b[Max1 (b,nb)]);
298                                                      Гл а в а 3



  // удалим из массива а отрицательные элементы
  Del(a, na);
  // покажем, что осталось.
  printf("Массив после удаления:\n");
  Print_mas(a, na);

  // выполним циклический сдвиг в массиве b:
  Cyrcle_Mas(b, nb);
  printf("Массив после сдвига:\n");
  Print_mas(b, nb);

  //Многократное выполнение циклического сдвига
  for(int C=1; C<=3; C++) // C – обычный счетчик
?? Circle_Mas(b, nb);
  printf("Массив после сдвига:\n");
  Print_mas(b, nb);

   // объявим новый массив и проинициализируем его
   int d[5]={–1, 1, –2, 2, –3};
   // объявим новый массив, длина которого не более 5
   int c[5];
   int nc;                    // реальная длина нового массива
   // получим новый массив
­? // из положительных элементов массива d
   // функция дважды возвращает длину массива
   nc=New_mas(d, 5, c, nc);
   if(nc!=0)                  // длина нового массива больше 0,
                              // массив получен
   {
?? printf("Новый массив:\n");
?? print_mas(c, nc);
   }
   else
?? printf ("Массива нет\n");

  // обращение к функции с элементами массива
  // массивы определяют значения координат точек
  //на плоскости
  float x[3]={1., 2., 3.};
За д ач и и у п р аж н е н и я                               299


   float y[3]={3., 2., 1.};
   printf("Вызываем функцию для нахождения расстояния
          от точек \n до начала координат\n");
   for(int i=0; i<3; i++)
   {
?? //При обращении к функции ей передается только одна
?? //точка
?? printf("%6.2f %6.2f, R=%6.2f\n", x[i],y[i],R(0,0,x[i],y[i]));
   }
}
// End of main
    Предлагаемые задания имеют основную тему «обработка
массивов». Не менее важной является тема «использование
механизма функций», рассмотренная ранее. Функции обра-
ботки массивов имеют особенности, связанные с передачей
данных в функцию и возвращением их из нее. Не следует
писать просто программу обработки массива, а затем «пере-
писывать ее на функцию», это порочный путь. Следует вос-
питывать в себе алгоритмическое мышление, учась видеть
абстрактный алгоритм в конкретной задаче, выделять глав-
ное и отсекать детали, а также совершенствуя свой навык
многократным использованием одних и тех же механизмов.
    В каждом задании предлагается три задачи. В любой
из них предполагается, что функция обрабатывает аб-
страктный массив, для которого известны лишь тип эле-
ментов и их количество (длина массива).
    В первой задаче нужно объявить массив и проинициа-
лизировать его в главной программе. Алгоритмом обра-
ботки массива является простой алгоритм сканирования
его элементов или проход по массиву от начала до конца.
Входным данным для функции обработки массива явля-
ется имя массива и его длина. Результатом обработки яв-
ляется одно значение, которое и возвращает функция.
    Во второй задаче нужно объявить массив в главной
программе. Главная программа будет управлять процес-
сом обработки массива путем определения последователь-
ности вызова функций. Для увеличения функционально-
сти массива предлагается написать и использовать функ-
ции ввода и вывода на экран элементов массива, а также
300                                             Гл а в а 3



функцию его обработки, особенностью которой во многих
задачах будет изменение длины массива, выполняемое
функцией. Поскольку длина массива всегда передается
в функцию как параметр, следует всего лишь не забыть
передать ее по адресу, а не по значению.
   В третьей задаче функциональность массива увеличи-
вается добавлением функции случайной генерации эле-
ментов массива. Задачей функции обработки является
получение нового массива. При решении этой задачи все
реальные массивы объявляет главная программа, и она
же управляет процессом получения, обработки и вывода
данных. Функция должна получить в качестве параме-
тров все входные данные и указатели на переменные, ко-
торые будут результатом обработки.

                  Варианты заданий
    Задание 1.
    1. Проинициализировать массив. Описать функцию,
которая найдет количество отрицательных элементов
массива. Описать функцию, которая найдет значение
наибольшего из отрицательных элементов.
    2. Описать функции ввода и вывода элементов мас-
сива. Описать функцию, которая удалит из массива наи-
больший из отрицательных элементов.
    3. Описать функцию случайной генерации элемен-
тов массива. Описать функцию для нахождения среднего
арифметического элементов массива. Описать функцию,
которая получит в новом массиве все значения, меньшие,
чем среднее арифметическое своих соседей. Использовать
механизм указателей.
    Задание 2.
    1. Проинициализировать массив. Описать функцию,
которая найдет количество элементов массива, имеющих
четные порядковые номера, но являющихся нечетными
числами. Описать функцию, которая найдет наибольшее
четное значение.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая удалит повторяющиеся
элементы массива.
За д ач и и у п р аж н е н и я                     301


    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая получит в новом мас-
сиве только те элементы исходного, которые имеют чет-
ные порядковые номера, но являются нечетными числа-
ми. Использовать механизм указателей.
    Задание 3.
    1. Проинициализировать два массива произвольной
длины, в каждом из которых нет повторяющихся значе-
ний. Описать логическую функцию, которая проверит,
нет ли в массиве повторяющихся элементов. Описать
функцию, которая найдет количество элементов, которые
одинаковы в двух массивах.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая определит, является ли
массив упорядоченным по возрастанию. Описать логи-
ческую функцию, которая для массива и некоторого за-
данного N определит, сохранится ли упорядоченность,
если N «приписать» в конец массива. Если это возможно,
функция действительно добавит число в конец массива,
и увеличит его длину.
    3. Описать функцию случайной генерации элементов
массива Y, в котором могут быть как положительные, так
и отрицательные значения. Описать функцию получения
нового массива Z по следующему закону: Zi = Yi, если Yi
по модулю больше 1, и Zi = 1 в противном случае. Найти
и вернуть число единичек в новом массиве. Использовать
механизм указателей.
    Задание 4.
    1. Проинициализировать массив. Описать функцию,
которая найдет количество элементов массива, принадле-
жащих интервалам [–2; –5] или [2; 5]. Описать функцию,
которая найдет сумму элементов, не входящих в указан-
ные интервалы.
    2. Описать функции ввода и вывода элементов мас-
сива. Описать функцию, которая проверит, является ли
массив упорядоченным по возрастанию. Описать функ-
цию, которая выполнит вставку в упорядоченный массив
некоторого произвольного значения таким образом, что-
бы упорядоченность не была нарушена.
302                                               Гл а в а 3



    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая сохранит в новом
массиве только те элементы исходного, которые принад-
лежат интервалам [–2; –5] или [2; 5]. Использовать меха-
низм указателей.
    Задание 5.
    1. Проинициализировать массив. Описать две функ-
ции для нахождения номеров наибольшего и наименьше-
го элементов массива.
    2. Описать функции ввода и вывода элементов мас-
сива. Описать функцию, которая удалит из массива наи-
больший и наименьший элементы.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая выполнит разделе-
ние массива на два — массив положительных значений
и массив отрицательных значений. Использовать меха-
низм указателей.
    Задание 6.
    1. Проинициализировать два массива, которые задают
n точек координатами (X, Y) в двумерном пространстве.
Описать функцию, которая находит расстояние между
двумя произвольными точками. Описать функцию, кото-
рая найдет расстояние между всеми точками и выведет их
на экран в виде таблицы. Описать функцию, которая най-
дет наибольшее расстояние.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая выполнит сжатие массива
(удаление всех чисел меньше 0).
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая в новом массиве по-
лучит только положительные значения элементов исхо-
дного массива. Использовать механизм указателей.
    Задание 7.
    1. Проинициализировать два массива, которые зада-
ют n точек координатами (X, Y) в декартовой системе ко-
ординат. Описать функцию перевода декартовых коорди-
нат точки в полярные (углы в градусной мере вычислять
с точностью до градусов). Для всех точек перевести де-
картовы координаты в полярные, результаты сохранить
За д ач и и у п р аж н е н и я                    303


в массивах. Описать функцию поиска наибольшего значе-
ния. Найти номер точки, имеющей наибольший радиус-
вектор, и номер точки, имеющей наибольший угол. Вы-
вести значение декартовых и полярных координат этих
точек.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функции поиска и удаления из массива про-
извольных цепочек чисел (М1, М2, М3).
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая находит в массиве
все элементы, значения которых принадлежат некоторо-
му указанному диапазону [M1; M2], и формирует из них
новый массив. Использовать механизм указателей.
    Задание 8.
    1. Проинициализировать массив. Описать функцию,
которая найдет среднее арифметическое элементов мас-
сива. Описать функцию, которая найдет номер элемента
массива, ближайшего к среднему арифметическому эле-
ментов массива.
    2. Даны координаты и массы N материальных то-
чек, расположенных на прямой. Описать функции ввода
и вывода массивов. Использовать их для ввода данных,
определяющих точки. Описать функцию, которая найдет
координату центра тяжести системы. Описать функцию,
которая найдет номер точки, наиболее близко располо-
женной к центру тяжести. Описать функцию, которая
удалит точку, наиболее близко расположенную к центру
тяжести.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, один из параметров которой
символьная переменная «знак», принимающая значения
«>» или «<». Функция перепишет в новый массив только
те элементы исходного, которые больше среднего ариф-
метического, если знак «>», и те, которые меньше, если
знак «<». Использовать механизм указателей.
    Задание 9.
    1. Проинициализировать массив. Описать две функ-
ции, которые определят, являются ли элементы массива
упорядоченными по возрастанию и являются ли элемен-
304                                              Гл а в а 3



ты массива упорядоченными по убыванию. Описать функ-
цию, которая одна выполняет полную проверку. Если по-
рядок возрастания, функция вернет 1, если убывания, –1,
если нет порядка, 0.
    2. Даны координаты материальных точек, располо-
женных на прямой. Описать функции ввода и вывода
массивов. Ввести координаты точек. Описать функцию,
которая найдет координату центра тяжести системы.
Описать функцию, которая найдет номер точки, наиболее
удаленной от центра тяжести. Описать функцию, которая
удалит эту точку.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию с параметром «знак», форми-
рующую новый массив. Если знак положителен, то функ-
ция формирует новый массив, в котором записаны только
положительные элементы исходного массива, если отри-
цателен, то функция формирует новый массив, в котором
записаны только отрицательные элементы исходного мас-
сива. Использовать механизм указателей.
    Задание 10.
    1. Проинициализировать массив. Описать функции,
которые найдут число положительных и отрицательных
элементов массива. Описать функцию преобразования
массива, которая возводит в квадрат все отрицательные
элементы массива, а из положительных элементов извле-
кает квадратный корень.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая удалит из массива все эле-
менты, значения которых по модулю больше некоторого
заданного N.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая выполнит разделе-
ние массива на два — массив четных чисел и массив не-
четных чисел. Использовать механизм указателей.
    Задание 11.
    1. Проинициализировать массив, в котором могут
быть как положительные, так и отрицательные числа.
Описать функцию, которая найдет количество элементов
массива до первого отрицательного, и функцию, которая
За д ач и и у п р аж н е н и я                      305


найдет сумму элементов после первого отрицательного.
Описать функцию, которая решит обе эти задачи.
   2. Даны координаты n точек на координатной плоско-
сти массивами координат. Описать функции ввода и вы-
вода массивов, определяющих точки. Описать функцию,
которая оставит в массивах только те точки, которые при-
надлежат полосе, заданной системой неравенств
                                 ?y >= ?1;
                                 ?
                                 ?y <= +1,

а остальные удалит.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая в новом массиве по-
лучит все значения исходного массива, которые находят-
ся после первого отрицательного элемента. Использовать
механизм указателей.
    Задание 12.
    1. Проинициализировать массив, в котором могут быть
как положительные, так и отрицательные числа. Описать
функцию, которая проверит, являются ли элементы мас-
сива упорядоченными по возрастанию. Описать функцию
сортировки массива по возрастанию методом пузырька.
Алгоритм заключается в следующем: массив просма-
тривается по перекрещивающимся парам чисел (аi, ai+1).
Если аi > ai+1, они меняются местами. Перестановки под-
считываются. Алгоритм завершает работу, если при про-
смотре массива нет ни одной перестановки. Сортировка
выполняется в том же массиве.
    2. Даны координаты n точек на координатной пло-
скости массивами координат (X, Y). Описать функции
ввода и вывода массивов, определяющих точки. Опи-
сать функцию, которая найдет координаты центра си-
стемы и добавит найденные значения в конец массивов
координат.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая сформирует новый
массив, в котором только положительные элементы ис-
ходного массива. Описать функцию, которая сформирует
306                                             Гл а в а 3



новый массив, в котором только отрицательные элементы
исходного массива. Использовать механизм указателей.
    Задание 13.
    1. Дан массив произвольной длины, определяющий
коэффициенты многочлена степени N. Проинициали-
зировать исходный массив. Описать функцию, которая
определит, не имеет ли нулевое значение коэффициент
при наивысшей степени. Описать функцию, которая най-
дет значение наибольшего элемента массива. Определить,
при какой степени коэффициент наибольший. Описать
функцию, которая найдет значение многочлена в произ-
вольной точке х.
    2. Описать функции ввода и вывода массива. Описать
функцию выравнивания элементов массива, которое за-
ключается в удалении из массива всех элементов, по мо-
дулю больших некоторого М.
    3. Описать функцию случайной генерации элементов
массива. Задать массив произвольной длины, опреде-
ляющий коэффициенты многочлена степени N. Описать
функцию, которая вычислит и сохранит в новом массиве
коэффициенты многочлена, являющегося его произво-
дной первой степени. Использовать механизм указате-
лей.
    Задание 14.
    1. Проинициализировать массив. Описать функции
поиска наименьшего, наибольшего элементов массива
и функцию выравнивания массива (замена нулем мини-
мального и максимального его элементов).
    2. Описать функции ввода и вывода массива. Описать
функцию, которая проверит, является ли массив упо-
рядоченным по убыванию. Описать функцию, которая
в упорядоченный по убыванию массив включит некото-
рый элемент b, с сохранением упорядоченности.
    3. Описать функцию случайной генерации элемен-
тов массива. Локальным минимумом называется любой
элемент, который меньше своих соседей. Описать функ-
цию, которая найдет все локальные минимумы, с запи-
сью их в новый массив. Использовать механизм указа-
телей.
За д ач и и у п р аж н е н и я                    307


    Задание 15.
    1. Проинициализировать массив. Описать функцию,
которая получит сумму нечетных чисел данного массива.
Описать функцию, которая получит сумму отрицатель-
ных чисел данного массива. Описать функцию, которая
получит сумму тех чисел данного массива, которые не-
четны и отрицательны.
    2. Описать функции ввода и вывода массива. Описать
функцию, которая определит, является ли некоторое чис-
ло простым. Описать функцию, которая удалит из масси-
ва все простые числа.
    3. Описать функцию случайной генерации элементов
массива. Получить два массива одинаковой длины. Опи-
сать функцию, которая сложит или вычтет массивы поэ-
лементно с записью в новый массив. Операция (знак «+»
или «–») передается в функцию как параметр. Использо-
вать механизм указателей.
    Задание 16.
    1. Проинициализировать массив. Описать функцию,
которая определит, являются ли палиндромом элементы
массива. Описать функцию, которая расположит его эле-
менты в обратном порядке, не используя вспомогатель-
ный массив.
    2. Описать функции ввода и вывода массива. Описать
функцию нахождения среднего арифметического элемен-
тов массива. Описать функцию, которая добавит найден-
ное среднее значение в конец массива.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию копирования массива. Ис-
пользовать механизм указателей.
    Задание 17.
    1. Проинициализировать массив. Описать функцию,
которая найдет наибольшее из нечетных по значению чи-
сел. Описать функцию, которая найдет наименьшее из
четных чисел. Описать функцию, которая одновременно
решит обе эти задачи.
    2. Описать функции ввода и вывода массива. Описать
функцию, которая определит, является ли массив упоря-
доченным, например, по возрастанию. Описать функцию,
308                                                  Гл а в а 3



которая выполнит вставку в упорядоченный массив не-
которого произвольного значения таким образом, чтобы
упорядоченность не была нарушена.
    3. Описать функцию случайной генерации элементов
массива. Получить массив В. Описать функцию, которая
сольет некоторый упорядоченный массив А со случайным
массивом В, многократно выполняя вставки элементов из
массива В в массив А. Использовать механизм указателей.
    Задание 18.
    1. Проинициализировать массив. Описать функцию
поиска наибольшего значения. Описать функцию сорти-
ровки массива по возрастанию на основе алгоритма об-
мена. Путем просмотра отыскивается максимальное зна-
чение и меняется местами с последним элементом, затем
этой же операции подвергается оставшаяся часть массива
кроме последнего элемента, затем кроме двух последних
и т. д. всего (n – 1) раз, где n — число элементов массива.
Исходные данные не сохранять, т. е. выполнить сортиров-
ку в том же массиве.
    2. Описать функции ввода и вывода массива. Описать
функцию преобразования массива, которая удаляет из
него все отрицательные и равные нулю значения.
    3. Описать функцию случайной генерации элементов
массива. Пусть два массива произвольной длины хранят
коэффициенты двух многочленов степеней N и M. Описать
функцию сложения (вычитания) многочленов, которая по-
лучит значения коэффициентов нового многочлена в новом
массиве. Характер операции (знак «+» или «–») задать как
параметр функции. Использовать механизм указателей.
    Задание 19.
    1. Проинициализировать массив. Описать функцию,
которая определит, образуют ли элементы массива арифме-
тическую прогрессию. Если да, вернуть знаменатель про-
грессии, иначе 0. Описать функцию, которая определит,
образуют ли элементы массива геометрическую прогрес-
сию. Если да, вернуть знаменатель прогрессии, иначе 1.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая удалит из массива первый
и последний элементы.
За д ач и и у п р аж н е н и я                     309


    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая получит в новом мас-
сиве упорядоченный по возрастанию исходный массив.
Алгоритм сортировки произвольный. Использовать ме-
ханизм указателей.
    Задание 20.
    1. Проинициализировать массив. Описать функцию,
которая найдет количество четных элементов массива.
Описать функцию, которая найдет количество нечетных
элементов массива. Описать функцию, которая одновре-
менно решит обе задачи.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая удалит из массива те зна-
чения, которые не повторяются.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию нахождения среднего ариф-
метического элементов массива. Описать функцию, кото-
рая получит в новом массиве те значения исходного, ко-
торые отличаются от среднего арифметического элемен-
тов массива не более чем на 1. Использовать механизм
указателей.
    Задание 21.
    1. Проинициализировать массив. Описать функцию,
которая определит, является ли массив знакоперемен-
ным. Описать функцию, которая найдет число смен знака
в массиве.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая определит, является ли
массив упорядоченным по возрастанию. Описать функ-
цию, которая объединит два упорядоченных массива
в третий, тоже упорядоченный, используя механизм вста-
вок очередного элемента второго массива в подходящее
место первого.
    3. Описать функцию случайной генерации элементов
массива. Использовать ее, чтобы задать в виде двух мас-
сивов произвольной длины координаты n точек на пло-
скости. Описать функцию вычисления расстояния между
двумя точками. Использовать ее, чтобы получить в новом
массиве номера всех точек, принадлежащих кругу радиу-
310                                                 Гл а в а 3



са R с центром в начале координат. Использовать меха-
низм указателей.
     Задание 22.
     1. Проинициализировать в виде двух массивов произ-
вольной длины координаты n точек на плоскости (X, Y).
Описать функцию вычисления расстояния между двумя
точками. Описать функцию, которая найдет суммарное
расстояние в порядке обхода от первой точки до послед-
ней.
     2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая проверит, находится ли
точка с координатами (x, y) в диапазоне значений |x| < R и
|y| < R. Описать функцию, которая выполнит для n точек
на плоскости удаление из массивов координат тех точек,
что не принадлежат области.
     3. Описать функцию случайной генерации элементов
массива. Задать случайно координаты n точек на плоско-
сти. Описать функцию, которая для n точек сформирует
массив номеров тех точек, радиус-вектор которых мень-
ше некоторого заданного R. Использовать механизм ука-
зателей.
     Задание 23.
     1. Проинициализировать массив. Описать функцию
для нахождения первого положительного элемента мас-
сива и функцию для нахождения первого отрицательного
элемента массива.
     2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая удалит из массива первый
положительный и первый отрицательный элементы.
     3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая выполнит слияние
двух массивов одинаковой длины в третьем (элементы
первого и второго массивов в нем чередуются). Использо-
вать механизм указателей.
     Задание 24.
     1. Проинициализировать массив. Описать логиче-
скую функцию, которая найдет, есть ли в массиве хотя бы
одно нулевое значение. Описать функцию, которая най-
дет общее число элементов до первого нулевого и после по-
За д ач и и у п р аж н е н и я                      311


следнего нулевого. Если ни одного нулевого элемента нет,
функция вернет –1. Если нулевыми являются первый
элемент и последний, функция возвращает 0, иначе —
значение, отличное от 0.
    2. Описать функции ввода и вывода элементов мас-
сива. Описать функцию, которая удалит из массива все
значения до первого нулевого и после последнего нуле-
вого.
    3. Описать функцию случайной генерации элементов
массива. Описать логическую функцию, которая в новом
массиве получит все значения исходного, которые нахо-
дятся от первого нулевого значения до последнего нулево-
го значения. Использовать механизм указателей.
    Задание 25.
    1. Проинициализировать два массива, которые задают
n точек координатами (X, Y) в декартовой системе коор-
динат. Описать логическую функцию, которая проверит,
принадлежит ли точка с координатами (х, у) кругу радиу-
са R с центром в начале координат. Описать функцию, ко-
торая для n точек определит, какая из них принадлежит
указанной области и выведет в таблицу.
    2. Описать функции ввода и вывода элементов масси-
вов как координат точек. Описать функцию, которая уда-
лит из массивов все точки, не принадлежащие указанной
области.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая находит в массиве
все элементы, значения которых не принадлежат неко-
торому указанному диапазону [А; В], и формирует из них
новый массив. Использовать механизм указателей.
    Задание 26.
    1. Проинициализировать массив. Описать функцию,
которая найдет наименьший элемент массива. Описать
функцию, которая найдет наибольший элемент масси-
ва. Описать функцию, которая переменит местами наи-
меньшее и наибольшее значения соответственно с первым
и последним элементами массива.
    2. Описать функции ввода и вывода массивов. Описать
функцию, которая определит, является ли число четным.
312                                               Гл а в а 3



Описать функцию, которая удалит из массива все четные
числа.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая определит, является
ли число простым. Описать функцию, которая перепишет
в новый массив только те элементы исходного, которые
являются простыми числами. Использовать механизм
указателей.
    Задание 27.
    1. Проинициализировать массив. Описать функцию, ко-
торая определит, являются ли элементы массива арифмети-
ческой прогрессией. Если прогрессия возрастающая, функ-
ция вернет 1, если убывающая, –1, если не прогрессия, 0.
    2. Описать функции ввода и вывода элементов мас-
сива. Описать функцию, которая удаляет из массива все
нулевые значения. Описать функцию, которая меняет
местами элементы массива, передвигая в начало все по-
ложительные элементы, а в конец все отрицательные, вы-
полняя перестановки в том же массиве.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая по заданным значе-
ниям первого элемента и знаменателя, генерирует ариф-
метическую прогрессию длиной n. Использовать меха-
низм указателей.
    Задание 28.
    1. Проинициализировать массив. Описать функции
поиска наибольшего и наименьшего элементов массива
(возвращать номера). Описать функцию, которая найдет,
сколько элементов массива находятся в промежутке меж-
ду номером наибольшего и номером наименьшего элемен-
тов массива.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая удалит из массива все эле-
менты до первого экстремума и после последнего.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая получит в новом мас-
сиве все элементы исходного, которые находятся в проме-
жутке между двумя экстремумами. Использовать меха-
низм указателей.
За д ач и и у п р аж н е н и я                     313


    Задание 29.
    1. Проинициализировать массив, в котором могут быть
как положительные, так и отрицательные числа. Описать
логическую функцию, которая найдет, есть ли в массиве
хотя бы один отрицательный элемент. Описать функцию,
которая найдет количество элементов массива до первого
отрицательного. Описать функцию, которая найдет сум-
му элементов массива до первого отрицательного.
    2. Описать функции ввода и вывода элементов масси-
ва. Описать функцию, которая удалит из массива все эле-
менты до первого отрицательного.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая в новом массиве по-
лучит все значения исходного массива, которые находят-
ся после первого отрицательного элемента. Использовать
механизм указателей.
    Задание 30.
    1. Проинициализировать массив. Описать функцию,
которая выполнит сглаживание элементов массива (сгла-
живание — это замена каждого числа значением среднего
арифметического трех стоящих рядом элементов). Опи-
сать функцию, которая найдет среднее арифметическое
элементов массива.
    2. Описать функции ввода и вывода массива. Описать
функцию, которая заменит нулями наименьшее и наи-
большее значения элементов массива. Дописать в конец
массива значение среднего арифметического.
    3. Описать функцию случайной генерации элементов
массива. Описать функцию, которая формирует массив
отклонений для каждого элемента исходного массива от
среднего арифметического. Использовать механизм ука-
зателей.

    Тема 8. Использование одномерных
    массивов в содержательных задачах
    В задачах этого раздела основная трудность заключа-
ется в том, что задания не формализованы. Следователь-
но, предваряет кодирование процесс формализации, в ко-
торый должны входить:
314                                                Гл а в а 3



   1. Выбор математической модели.
   2. Выбор способа представления данных.
   3. Функциональная декомпозиция.
   4. Кодирование и отладка алгоритмов обработки дан-
ных.
   В качестве рекомендации напомним тему раздела:
использование массивов, значит, способ представления
данных — это массив (массивы). Алгоритмов обработки
массивов не так много, большинство из них рассмотрены
в примерах предыдущего раздела, следовательно, нужно
лишь выбрать подходящий алгоритм и, возможно, моди-
фицировать его для конкретной задачи. Следует активно
пользоваться подходящими функциями, написанными
ранее, такими как ввод и вывод элементов массива.

                   Варианты заданий
    Задание 1. Сорок разбойников сдали экзамен по охране
окружающей среды. Использовать функции обработки мас-
сивов, чтобы найти, сколько разбойников будут охранять
среду отлично, сколько хорошо, а сколько — посредственно.
    Задание 2. Для каждой детали цилиндрической фор-
мы проводят три измерения: диаметр нижнего основа-
ния, диаметр центра и диаметр верхнего основания с точ-
ностью 3 знака. Данные сохранены в массивах. Брако-
ванными считаются детали, у которых конусность или
бочковатость более 3%. Пометить бракованные детали.
Определить процент бракованных деталей в партии.
    Задание 3. Дети встают по кругу и начинают считал-
ку, в которой выбывает n-й ребенок, после чего круг смы-
кается. Считалка повторяется, пока не останется один ре-
бенок. Использовать функции обработки массивов, чтобы
узнать, кто останется.
    Задание 4. Дневная и ночная температура воздуха из-
меряются ежедневно и записываются в таблицу. Когда
среднесуточная температура в течение трех дней подряд
ниже 8°C, начинается отопительный сезон. Использовать
функции обработки массивов, чтобы определить, какого
числа сезон был начат в этом году, если известно, что это
произошло в текущем месяце.
За д ач и и у п р аж н е н и я                       315


    Задание 5. В таблице хранятся данные о расходе элек-
троэнергии в школе помесячно в течение года. Использо-
вать функции обработки массивов, чтобы узнать средний
расход электроэнергии, минимальный и максимальный
расходы, а также узнать, на сколько процентов отлича-
ются минимальный и максимальный расходы от средне-
месячного.
    Задание 6. На метеостанции в компьютер введены све-
дения о среднесуточной температуре за март. Использо-
вать функции обработки массивов, чтобы найти: 1) сред-
нюю температуру месяца; 2) день, когда температура бли-
же всего подходила к среднемесячной.
    Задание 7. Банк провел мониторинг с целью улуч-
шения обслуживания клиентов. Собранная информация
хранит номер менеджера, время регистрации клиента,
время начала обслуживания и время завершения. При
обработке информации требуется найти наибольшее, наи-
меньшее и среднее время ожидания, а также наибольшее,
наименьшее и среднее время обслуживания. Использо-
вать функции обработки массивов.
    Задание 8. В течение суток через каждый час произве-
дены замеры напряжения в сети. Использовать функции
обработки массивов, чтобы определить максимальный
скачок напряжения и наибольшее его падение, а также
узнать, в какое время суток это произошло.
    Задание 9. Кот Матроскин завел 10 коров. Каждый ве-
чер он записывает, сколько молока дала каждая корова
за день. Потом ему нужно узнать, сколько всего молока
получено за день, а также какая из коров сегодня отли-
чилась, а какая дала молока меньше всех. Использовать
функции обработки массивов.
    Задание 10. Каждому ученику 1 класса полагается
стакан молока, если его вес меньше 30 кг. Количество
учеников и вес каждого известны. Выяснить, сколько ли-
тров молока необходимо для класса (1 стакан равен 0,2 л).
Использовать функции обработки массивов.
    Задание 11. Безумное чаепитие. За круглым столом
сидят толстяки. Вес каждого известен. Каждый час они
пересаживаются по кругу вправо на один стул. Известно,
316                                               Гл а в а 3



что один из стульев (он помечен) не выдержит максималь-
ного веса толстяка. Используя функцию обработки масси-
вов, определить, в котором часу все повеселятся.
    Задание 12. Для того чтобы выявить наиболее попу-
лярного политического деятеля из 10 участников, про-
веден экспертный опрос. Три эксперта каждому деятелю
проставляют баллы от 1 до 10. Использовать функции об-
работки массивов, чтобы найти самого популярного дея-
теля по сумме баллов.
    Задание 13. Кот Матроскин и Шарик загадывали чис-
ла в произвольном порядке и записывали их на печке,
пока не кончилось место. Использовать функции обработ-
ки массивов, чтобы определить, каких чисел, четных или
нечетных, загадано больше.
    Задание 14. Информация о валеологическом обследо-
вании призывников известна. Для каждого хранится вес,
рост, объем груди на вдохе. Известны предельные параме-
тры, которым должен удовлетворять призывник. Исполь-
зовать функции обработки массивов, чтобы найти, какие
призывники годны к несению службы.
    Задание 15. Филя, Каркуша и Степашка проводят
кастинг ведущих передачи «Спокойной ночи, малыши».
Каждый кандидат оценивается по трем параметрам: ар-
тистичность, фотогеничность, эрудированность. Каждый
эксперт выставляет оценку от 0 до 10 баллов. Критерий
выбора кандидата эксперты не смогли сформулировать,
но они хотят выбрать лучшего. Также они хотят узнать
лучшего в каждой отдельной номинации. Использовать
функции обработки массивов.
    Задание 16. Овцы пасутся примерно вместе. Отбив-
шейся от стада считается овца, которая удалилась на мак-
симальное расстояние от условного «центра стада». Если
известны координаты всех овец (как точек на плоскости),
проверить, есть ли овца, отбившаяся от стада. Она доста-
нется волку, который с ноутбуком сидит под ближайшим
к стаду кустом. Использовать функции обработки масси-
вов.
    Задание 17. Коротышки собирали огурцы. Число огур-
цов, собранных каждым коротышкой, записано. В оплату
За д ач и и у п р аж н е н и я                     317


каждому коротышке выдается 2 огурца, а тому, кто собрал
больше всех, 3 огурца. Найти, кому достанется 3 огурца.
Найти, сколько всего огурцов собрали коротышки. Най-
ти, сколько огурцов осталось для засолки. Использовать
функции обработки массивов.
    Задание 18. Роща ценных деревьев расположена в жи-
вописном уголке. Известны координаты каждого дерева.
Требуется огородить рощу от зайцев и оленей забором
прямоугольной формы, причем потратить на это как мож-
но меньше денег. Найти периметр охватывающего прямо­
угольника, используя функцию обработки массивов.
    Задание 19. Улитка упорно ползет по склону вверх.
В солнечный день она проползает S1 м, в пасмурный —
S2 м. Сведения о погоде за месяц известны. Использовать
функции обработки массивов, чтобы узнать: 1) сколько
проползала улитка за каждую неделю; 2) сколько про-
ползла за месяц; 3) какова средняя скорость перемеще-
ния.
    Задание 20. На метеостанции в компьютер введены
сведения о среднесуточной температуре за март. Исполь-
зовать функции обработки массивов, чтобы найти: 1) ко-
личество дней, когда температура ниже 0°C; 2) количе-
ство дней, когда температура выше 0°C.
    Задание 21. Спортсмен бежит по кругу. На каждом
круге тренер определяет время прохождения дистанции
и записывает его. Определить, сколько метров пробежал
спортсмен. Определить, какова средняя скорость бега.
Определить, на каком круге скорость была наибольшая,
на каком круге наименьшая. Использовать функции об-
работки массивов.
    Задание 22. Роща ценных деревьев расположена в жи-
вописном уголке. Известны координаты каждого дерева.
Требуется огородить рощу от нашествия мартышек забо-
ром круглой формы высотой 5 м. Найти наименьший ра-
диус окружности, охватывающей все деревья, найти пло-
щадь сетки, которая будет потрачена на забор. Использо-
вать функции обработки массивов.
    Задание 23. Популяция кроликов изменяется по
следующему закону: в «хороший» год она удваивает-
318                                                 Гл а в а 3



ся, в «обычный» увеличивается в 1,25 раза, в «плохой»
уменьшается на 0,25%. Характеристики хранятся N лет,
начиная с 1990 г. В этом (нулевом) году популяция со-
ставляла М особей. Использовать функции обработки
массивов, чтобы узнать численность популяции к концу
N-го года, вывести на экран данные о ежегодном измене-
нии популяции.
    Задание 24. Пес Шарик каждый день фотографирует
дачников и обитателей ближайшего леса. Себестоимость
одной фотографии K руб. Шарик записывает в журнал,
кого он сфотографировал. Дачникам фотографии стоят
денег, причем Шарик берет 2K руб. за фотографию. Оби-
тателям леса фотографии раздаются бесплатно, по 1 шт.
на морду. Каждый день Шарик хочет знать, каков размер
его прибылей (а может, убытков). Использовать функции
обработки массивов.
    Задание 25. Царевна Несмеяна каждому из претен-
дентов на ее руку и сердце задает М вопросов. За очень по-
нравившийся ответ она присуждает 2 балла, за не очень
понравившийся — 6 баллов, за очень не понравивший-
ся — 8. Определить самого понравившегося претендента.
Использовать функции обработки массивов
    Задание 26. В течение суток через каждый час про-
изведены замеры температуры и влажности воздуха. Ис-
пользовать функции обработки массивов, чтобы опреде-
лить максимальное значение температуры и влажности,
а также узнать, в какое время суток это произошло.
    Задание 27. Безумное чаепитие. За круглым столом
сидят толстяки. Вес каждого известен. Каждый час они
пересаживаются по кругу вправо на один стул. Использо-
вать функции обработки массивов, чтобы определить рас-
кладку весов по стульям через K ч.
    Задание 28. Сведения о росте учеников одного класса
хранятся в алфавитном порядке фамилий учеников. Ис-
пользовать функции обработки массивов, чтобы найти:
1) самого высокого ученика; 2) самого маленького уче-
ника.
    Задание 29. Сведения о росте и весе учеников одного
класса хранятся в алфавитном порядке фамилий учени-
За д ач и и у п р аж н е н и я                                 319


ков. Параллельно хранится пол ребенка (мальчик, девоч-
ка). Известен средний вес ребенка в этом возрасте (для
мальчиков и для девочек). Использовать функции об-
работки массивов, чтобы найти: 1) детей, которые выше
средней упитанности; 2) детей, которые ниже средней
упитанности.
    Задание 30. Есть список школьников одного класса.
Для каждого из них известны вес и рост. Использовать
функции обработки массивов, чтобы найти самого высо-
кого и самого толстенького школьника.

     Тема 9. Работа с двумерными массивами.
     Использование функций
   Синтаксис С++ разрешает использовать только одно-
мерные массивы. Массивы большей размерности тракту-
ются как массивы массивов. Использование статических
многомерных массивов имеет некоторые особенности, ко-
торые можно рассмотреть на примере двумерных масси-
вов (матриц).
   Объявление двумерного массива требует, чтобы были
указаны два размера: число строк и число столбцов ма-
трицы, например:
int a[8][10];          // массив из 8 одномерных массивов,
		                     // в каждом из которых 10 элементов.
float b[5][5][5];      // массив из 5 матриц, каждая
		                     // из которых имеет 5 строк по 5 элементов.
   При объявлении массива таким образом в памяти вы-
деляется место под размещение его элементов. Элементы
двумерного массива размещаются линейно по возраста-
нию индексов (построчно). Индексы нумеруются с нуля.
   Инициализация двумерных массивов синтаксически
выглядит как инициализация нескольких одномерных
массивов, например:
int a[3][4]={
?????? {1, 2, 3, 4},             // значения элементов
			                              // нулевой строки
?????? {2, 4, 6, 8},             // значения элементов
			                              // первой строки
320                                                 Гл а в а 3



?????? {9, 8, 7, 6} // значения элементов
			                 // второй строки
};
   Как и одномерные массивы, матрицы могут быть
условно переменной длины. При описании матрицы
число строк и столбцов задает константное выражение.
Это целочисленные значения, которые определяют ме-
ханизм выделения памяти для матрицы. Реально из вы-
деленного пространства можно использовать меньшее
число данных. При этом следует ввести переменные,
обозначающие реальное число строк, столбцов (мень-
шее или равное указанному в описании), которые будут
управлять процессом сканирования элементов матри-
цы.
   Пусть матрица имеет размер, определенный в описа-
нии. Пусть реальный размер обозначен переменными n,
m (матрица имеет n строк и m столбцов, при этом нуме-
рация начинается с нулевого значения). Пусть i — номер
строки, j — номер элемента в столбце (текущие значения).
Обращение к элементу массива aij можно выполнить по
индексу (прямая адресация) или указателю (косвенная
адресация):
a[i][j]    // адресуется элемент массива, стоящий на
           // пересечении i-го столбца и j-й строки.
*(a+i*m+j) // адресуется элемент массива, отстоящий от его
           // адреса на i*m+j значений.
    При косвенной адресации важно, что константа M (ко-
личество элементов в строке) определяет разбиение адрес-
ного пространства, выделенного для матрицы, на строки
определенной длины.
    Способы адресации элементов матрицы рассмотрим на
примере. При решении любой задачи, в которой требует-
ся обращение ко всем элементам матрицы, алгоритм про-
смотра содержит вложенный цикл, у которого во внешнем
цикле управляющей переменной является номер строки
матрицы, а во внутреннем — номер столбца. Тогда про-
смотр элементов происходит построчно.
    Пусть есть описание матрицы:
#define N 5
За д ач и и у п р аж н е н и я                         321


#define M 7
int a[N][M];
   Здесь размер матрицы определяют define-константы.
Для матрицы условно переменной длины следует описать
размер по максимуму и ввести переменные, реально опре-
деляющие размер матрицы.
int a[N][M];    // максимальное число строк, столбцов
int n, m;		     // реальное число строк, столбцов
printf("Введите размер матрицы (строк, столбцов <25)\n");
scanf("%d%d", &n, &m); // теперь это наибольшие значения
			                     // параметров цикла
   Для обращения к элементам матрицы по строкам цикл
записывается так:
for(i=0; i<n; i++)
  for(j=0; j<m; j++)
?? {
??? // в теле цикла обращение к переменной a[i][j]
?? }
   Если переменить эти циклы местами, просмотр будет
происходить по столбцам:
for(j=0; j<m; j++)
  for(i=0; i<n; i++)
?? {
??? // в теле цикла обращение к переменной a[i][j]
?? }
   Зная, что матрица хранится как одномерный массив,
можно ее описать как одномерный массив, а элементы
адресовать как элементы матрицы, например:
int a[25];             // матрица размером 5?5
int n, m;
n=5;
m=5;
    Независимо от способа описания двумерного массива,
обращение к его элементам с использованием указателя,
выполнит те же действия, что и обращение по индексам,
а синтаксически оно должно быть записано так:
for(i=0; i<n; i++)
  for(j=0; j<m; j++)
?? {
322                                              Гл а в а 3



??? //В теле цикла обращение к переменной *(a+i*m+j)
?? }
   Как видим, запись сложного цикла нисколько не из-
менилась, а изменился только синтаксис обращения к пе-
ременной.
   Использование функций при обработке матриц пред-
полагает два кардинально различных подхода. В первом
случае матрица существует или рассматривается как са-
мостоятельная структура данных, к которой необходимо
применить какой-либо алгоритм обработки. В качестве
параметра такой функции будет использована вся ма-
трица целиком. Чтобы задача обработки решалась в об-
щем виде, в функцию следует передать имя матрицы и ее
размеры (как параметры функции), при этом функция
получает матрицу как двумерный массив. С++ должен
знать, каков способ разбиения этой структуры на стро-
ки, поэтому число строк данных как константное выра-
жение можно опустить, а число данных в каждой строке
опускать нельзя. Оно должно быть указано обязательно
как константное выражение в квадратных скобках при
передаче матрицы. Так, прототип функции, получаю-
щей матрицу в качестве входного данного, может выгля-
деть так:
int function(int a[][m], int n, int m);
// здесь m – константное выражение
   Пример 9.1. В качестве простого примера рассмотрим
функции для ввода и вывода матрицы на экран. Пред-
полагается, что матрица условно переменного размера,
поэтому число строк и столбцов матрицы по описанию
определено define-константами N = 10 и M = 10. Реальный
размер матрицы определяют переменные n, m, значения
которых вводятся.
#include <stdio.h>
#define N 10
#define M 10
void input_matr(int a[][M], int &n, int &m);
// важно, что длина строки – это константа

void print_matr(int a[][M], int n, int m);
За д ач и и у п р аж н е н и я                            323


// число строк можно не передавать


// главная программа описывает входные данные
void main(void)
{
   int n, m;               // реальные размеры матрицы
   int matr[N][M];         // описан двумерный массив
   input_matr(matr, n, m); // передан в функцию ввода
   print_matr(matr, n, m); // предан в функцию вывода
}

// описание функции ввода
// параметры функции – имя и размеры массива
void input_matr(int a[][M], int &n, int &m)
// n, m возвращаются по ссылке
{
   int i, j;
   printf("Введите размер матрицы не более %d на %d\n",
             N, M);
   scanf("%d%d", &n, &m);
   printf("Введите матрицу.\n");
   for(i=0; i<n; i++)
   for(j=0; j<m; j++)
?? scanf("%d", &matr[i][j]);
}

// описание функции вывода
// параметры функции – имя и размеры массива
void print_matr(int a[][M], int n, int m)
{
   int i, j;
   for(i=0; i<n; i++)
   {
?? for(j=0; j<m; j++)
??? printf("%5d", mas[i][j]);
?? printf("\n"); // разбиение вывода на строки
   }
}
324                                              Гл а в а 3



    Во втором случае, если матрица — это массив из од-
номерных массивов, то для обработки отдельных строк
матрицы можно использовать функции обработки одно-
мерных массивов. Зная, что элементы матрицы — это
одномерные массивы, каждый из них можно по очереди
передавать в функцию, которая умеет работать с одномер-
ным массивом. При этом для решения задач этого раздела
можно и нужно использовать объявления функций, отла-
женных для решения предыдущих задач раздела 7.
    Пример 9.2. При решении задач на обработку одно-
мерных массивов нами были отлажены функции обработ-
ки одномерных массивов. Их смело можно применить для
решения задач обработки многомерных массивов. Пусть
есть функции вывода одномерного массива и функция
преобразования, которая находит наименьшее значение
и переставляет его на первое место. Для ввода матрицы
используем функцию ввода из примера 9.1.
#include <stdio.h>
#define N 5
#define M 5

// функция вывода одномерного массива
void print_mas(int mas[], int len)
{
   for(int i=0; i<len; i++)
?? printf("%5d", mas[i]);
   printf("\n");
}

// функция вывода матрицы как совокупности
// одномерных массивов
void print_matr(int mas[][M], int n, int m)
{
   printf("Матрица:\n");
   for(int i=0; i<n; i++)
?? print_mas(mas[i],m);
}

// функция преобразования одномерного массива
За д ач и и у п р аж н е н и я                          325


// по заданному условию
void Change(int mas[], int len)
{
   // найдем наименьший элемент
   int *ip;
   int *min=mas;
   for(ip=mas; ip<mas+len; ip++)
   if(*ip<*min)
?? min=ip;
   // перестановка при завершении поиска
   *ip=*min;
   *min=*mas;
   *mas=*ip;
}

// main объявляет матрицу и управляет вызовами функций
void main(void)
{
   int n, m;
   int matr[N][M]; // матрица объявлена размером 10?10
   int i;
   input_matr(matr, n, m); // ввод матрицы
   // вызов функции преобразования
   // для каждой строки матрицы
   for(i=0;i<n;i++)
?? Change(matr[i], m); // matr[i], это i-я строка матрицы
   print_matr(matr, n, m); // вывод результирующей матрицы
}
   Пример 9.3. Просмотр матрицы по столбцам вызовет
существенные изменения в основной программе, пото-
му что столбец нельзя передать как одномерный массив
простой записью matr[j] в силу того, что двумерный мас-
сив — это массив массивов (строк для матрицы). Однако
функции обработки одномерных массивов можно приме-
нить для решения задач обработки столбцов, если пред-
варительно столбец копировать в некую промежуточную
структуру, а после преобразования возвращать изме-
ненное значение столбцу матрицы. Так, основной цикл
главной программы примера 9.2 будет выглядеть так:
326                                                    Гл а в а 3



int Tmp[M];            // временный массив, длина равна
                       // длине столбца
for(j=0; j<m; j++)     // цикл по номерам столбцов
{
   //Копирование перед каждым обращением.
   for(i=0; i<n; i++)  // цикл по номеру элемента в строке
?? Tmp[i]=matr[i][j]; // Tmp получил копию j-го столбца
   Change(Tmp,m); // изменение в Tmp
   // копирование после каждого обращения
   for(i=0; i<n; i++)
?? matr[i][j]=Tmp[i];
   //Возвращаем значение j-му столбцу
}
// вывод обычный.
print_matr(matr, n, m);
    Пример 9.4. Чтобы убедиться в преимуществах кос-
венной адресации, покажем, как можно работать с одно-
мерным массивом как с матрицей. Найдем сумму элемен-
тов матрицы.
    В этой задаче функция ввода матрицы получает одно-
мерный массив, который разбит на n строк по m элементов
в каждой. Косвенная адресация позволяет рассматривать
двумерный массив как линейный.

#include <stdio.h>

// функция ввода матрицы
void input_matr(int mas[], int &n, int &m)
{
   int i, j;
   printf("Введи размер матрицы\n");
   scanf("%d%d", &n, &m);
   printf("Введи матрицу\n");
   for(i=0; i<n; i++)
?? for(j=0; j<m; j++)
??? scanf("%d", mas+i*m+j);
}
// функция вывода матрицы
void print_matr(int mas[], int n, int m)
За д ач и и у п р аж н е н и я                              327


{
  int i, j;
  for(i=0; i<n; i++)
  {
?? for(j=0; j<m; j++)
??? printf("%5d", *(mas+i*m+j));
?? printf("\n");
  }
}

// функция нахождения суммы элементов матрицы
int Sum(int mas[], int n, int m)
{
   int i, j;
   int S=0;
   for(i=0; i<n; i++)
?? for(j=0; j<m; j++)
??? S+=*(mas+i*m+j);
?? return S;
}

// в главной программе объявлен одномерный массив
// он передается во все функции
void main(void)
{
   int matr[25];
   int n, m;
   input_matr(matr, n, m);
   printf("Сумма элементов равна %d\n", Sum(matr, n, m));
   print_matr(matr, n, m);
}

                                 Варианты заданий
   Задание 1. Дана матрица размером n?m. Найти суммы
элементов в каждой строке матрицы, для чего использо-
вать функцию, находящую сумму элементов одномерного
массива. Дополнить матрицу найденными значениями,
поместив их в конце каждой строки.
328                                                 Гл а в а 3



    Задание 2. Дана матрица размером n?m. Упорядо-
чить матрицу по возрастанию элементов первого столбца.
Использовать метод пузырька. Алгоритм заключается
в следующем: матрица просматривается по перекрещи-
вающимся парам чисел (а[i][0], a[i + 1][0]). Если нулевой
элемент i-й строки больше, чем нулевой элемент i + 1-й
строки, то строки меняются местами. Поскольку строки
матрицы — это одномерные массивы, имеет смысл напи-
сать функцию перемены указателей, адресующих строки
а[i] и а[i + 1]. Перестановки подсчитываются. Алгоритм
завершает работу, если при просмотре матрицы нет ни
одной перестановки.
    Задание 3. Дана матрица размером n?m. Найти и за-
менить нулем максимальное и минимальное значения
в каждой строке матрицы. Использовать функцию, нахо-
дящую минимум, и функцию, находящую максимум из
элементов одномерного массива. Передавать им по очере-
ди строки матрицы.
    Задание 4. Дана матрица размером n?m. Определить,
является ли она симметричной относительно главной ди-
агонали. Использовать логическую функцию.
    Задание 5. Дана матрица размером n?3. Она содержит
результаты измерений прямых круговых конусов: ради-
ус основания, высота, длина образующей. Найти и со-
хранить в этой же матрице значения объема и площади
поверхности каждого конуса. Использовать функции.
Найти конус наибольшей площади и наибольшего объе-
ма, для чего использовать функцию поиска максимума
в одномерном массиве.
    Задание 6. Дана матрица размером n?m. Выполнить
сглаживание в строках матрицы, которое заключается
в замене каждого элемента значением среднего арифме-
тического трех стоящих рядом значений. Использовать
функцию, выполняющую сглаживание в одномерном
массиве. Передавать ей по очереди строки матрицы.
    Задание 7. Дана матрица размером n?m. Преобразо-
вать матрицу, удалив из нее i-ю строку и (или) j-й столбец
(по желанию пользователя). Использовать функцию пре-
образования матрицы.
За д ач и и у п р аж н е н и я                       329


    Задание 8. На плоскости заданы n точек своими коор-
динатами. Построить матрицу расстояний между всеми
точками. Найти наибольшее расстояние. Найти, между
какими точками расстояние наибольшее. Использовать
функции для вычисления расстояния между двумя точ-
ками и для поиска наибольшего значения.
    Задание 9. Дана матрица размером n?m. Определить,
являются ли упорядоченными по возрастанию данные
в каждой строке матрицы. Напечатать исходную матрицу
по строкам, в конце каждой строки напечатать сообщение
о том, упорядочена строка или нет. Использовать функ-
цию, выполняющую проверку в одномерном массиве.
Передавать ей по очереди строки матрицы. Использовать
функцию печати строки сообщения.
    Задание 10. Заданы несколько матриц произвольного
размера. Описать функцию сложения (вычитания) ма-
триц. Передавать как один из параметров функции знак
действия («+» или «–»). Чтобы контролировать входные
данные, функция должна быть логической.
    Задание 11. Дана матрица размером n?m. Преобразо-
вать матрицу следующим образом: найти в каждой стро-
ке минимальный и максимальный элементы и поменять
их местами с первым и последним элементами строки.
Использовать функции, выполняющие поиск минимума
и максимума в одномерном массиве. Использовать функ-
цию для выполнения перестановки. Передавать им по
очереди строки матрицы.
    Задание 12. Получить трехдиагональную матрицу
размером n?n, у которой на главной диагонали и двух, ле-
жащих выше и ниже ее, расположены единицы, а осталь-
ные элементы равны нулю.
    Задание 13. Дана матрица размером n?m. Заменить
нулями элементы i-й строки и (или) j-го столбца (по жела-
нию пользователя). Использовать функцию преобразова-
ния матрицы.
    Задание 14. Дана матрица размером n?m. Определить,
являются ли упорядоченными по возрастанию данные
в каждом столбце. Напечатать исходную матрицу по стро-
кам, внизу каждого столбца напечатать сообщение о том,
330                                                Гл а в а 3



упорядочен столбец или нет. Использовать функцию, ко-
торая решает задачу для элементов одномерного массива.
Передавать ей по очереди столбцы матрицы.
    Задание 15. Даны два массива коэффициентов: A и B.
Вычислить матрицу решений всех линейных уравнений
вида Ai ?x + Bj = 0. Описать и использовать функцию, воз-
вращающую матрицу.
    Задание 16. Дана матрица размером n?m. Выполнить
выравнивание в матрице, заменяя те значения, которые
по абсолютной величине больше некоторого M (введенно-
го в диалоге), значением M с учетом знака. Использовать
функцию преобразования одномерного массива или ма-
трицы.
    Задание 17. Дана матрица размером n?m. Найти и за-
менить нулем максимальное и минимальное значения
в каждом столбце матрицы. Использовать функции, вы-
полняющие поиск минимума и максимума в одномерном
массиве. Передавать им по очереди столбцы матрицы.
    Задание 18. Дана матрица размером n?m. Найти нор-
му матрицы: максимальное значение из сумм элементов
в каждой строке. Использовать функцию суммирования
с сохранением всех найденных сумм. Использовать функ-
цию поиска максимума в одномерном массиве.
    Задание 19. Дана матрица размером n?m. Найти сум-
мы элементов в каждом столбце матрицы и дополнить
матрицу найденными значениями, поместив их в конце
каждого столбца. Использовать функцию, находящую
сумму элементов одномерного массива. Передавать ей по
очереди столбцы матрицы.
    Задание 20. На плоскости заданы n точек своими ко-
ординатами. Построить матрицу расстояний между всеми
точками. Найти равноудаленные точки, если такие есть,
и сохранить в отдельном массиве их номера. Использо-
вать функции построения и поиска.
    Задание 21. Дана матрица размером n?m. Упорядо-
чить каждую строку матрицы по возрастанию элемен-
тов. Использовать метод простого обмена, описанный
в п. 1.5.3 (глава 1). Передавать в эту функцию поочеред-
но строки матрицы.
За д ач и и у п р аж н е н и я                     331


    Задание 22. Дана матрица размером n?m. Найти сед-
ловую точку матрицы и напечатать ее индексы. Седловой
точкой называется элемент, имеющий наименьшее значе-
ние в строке и наибольшее в столбце. Использовать функ-
цию обработки матрицы.
    Задание 23. Дана треугольная матрица размером n?n.
Описать функцию ввода матрицы, пустую половину при
вводе заполнить нулями. Использовать функцию обра-
ботки матрицы, чтобы найти значения и индексы наи-
большего и наименьшего элементов матрицы. Описать
функцию вывода матрицы на экран, выделить цветом
найденные значения.
    Задание 24. Дана матрица размером n?m. Найти сум-
му элементов каждой строки матрицы. Найти наиболь-
шее и наименьшее значения суммы, а также определить,
в какой строке матрицы это значение найдено. Использо-
вать функции для суммирования элементов одномерного
массива, для поиска минимума и максимума.
    Задание 25. Дана матрица размером n?m. Определить
и напечатать, в каких строках матрицы ее элементы обра-
зуют монотонную последовательность и какого характера
(возрастающую или убывающую). Использовать функ-
цию, выполняющую проверку в одномерном массиве. Пе-
редавать ей по очереди строки матрицы.
    Задание 26. Дана матрица размером n?m. Получить
новую матрицу, каждый столбец которой отсортирован
по убыванию элементов столбца исходной матрицы.
Использовать функцию сортировки одномерного мас-
сива, где алгоритм сортировки произвольный. Пере-
давать в эту функцию поочередно столбцы исходной
матрицы.
    Задание 27. Дана матрица размером n?m. Найти
среднее арифметическое значений ее столбцов и дописать
в последнюю строку матрицы. Найти строку, в которой
значения элементов наиболее близки к среднему ариф-
метическому. Использовать функцию поиска среднего
в одномерном массиве, передавая ей поочередно столбцы
матрицы. Использовать функцию поиска «самой средней
строки».
332                                                       Гл а в а 3



   Задание 28. Дана матрица размером n?m. Описать
функцию, чтобы найти сумму ее элементов. Получить на
основе исходной новую целочисленную матрицу такого
же размера, у которой на месте нулевых элементов за-
писаны нули, а на месте значений, отличных от нуля, за-
писаны единицы. Этот алгоритм реализовать функцией,
возвращающей число ненулевых элементов.
   Задание 29. Дана матрица размером n?m. Расстояние
между k-й и l-й строками матрицы вычисляется по фор-
муле
                               m ?1
                       Rkl =   ? akj ? alj .
                               j =0

    Определить, между какими строками матрицы рас-
стояние минимально. Использовать функцию для вычис-
ления расстояний и для поиска максимума.
    Задание 30. Дана матрица размером n?m. В каждой
строке матрицы найти первое вхождение значения 10.
Это и все последующие значения 10 заменить нулем. Если
числа 10 нет в строке, оставить ее без изменения. Исполь-
зовать функцию поиска и замены для одномерного масси-
ва. Передавать ей по очереди строки матрицы.

      Тема 10. Работа со строками символов
    Строка представляет собой массив символов, одно-
байтовых данных целого типа, объявленных как char или
unsigned char. Внутреннее представление символа — это его
код (ASCII кодом является число в пределах от 0 до 255 со-
гласно кодовой таблице), где первые 32 символа — управ-
ляющие. Синтаксически признаком символьной констан-
ты являются кавычки, например: '*' , '?' , 'f' , 'Я' , '#' , '1'.
    Строковая константа — это последовательность сим-
волов, заключенная в двойные кавычки " ", например:
«строка символов».
    При представления строки в памяти она рассматрива-
ется как массив символов, каждый символ хранится в от-
дельном байте, включая специальные символы. В конце
строки должен быть нулевой байт '\0' как признак конца
За д ач и и у п р аж н е н и я                          333


строки. Он добавляется автоматически при инициализа-
ции строки и при вводе строки с помощью специальной
функции gets. При формировании строки вручную необ-
ходимо заботиться о том, чтобы этот символ был добавлен.
Поэтому число символов в строке (длина строки) всегда
больше на 1 (для нулевого символа).
   Объявление строковых переменных можно выполнять
двумя способами.
   1. Как массив: char Str[80];
   Это плохой стиль объявления, так как длина строки
может изменяться ограниченно.
   2. Как указатель: char *Str;
   Это хороший стиль, но в этом случае строка является
динамической, и для указателя необходимо выделение
памяти Str=new char[80];
   При инициализации строковых переменных проис-
ходит автоматическое выделение памяти под запись зна-
чения строки.
char *Str1="строка 1 "; // длина 11 байт, включая пробелы
char Str2[9]="строка 2"; // длина 9 байт
char Str1[]="строка 3"; // специальный инициализатор
char Err[4]="ошибка";
// число символов больше, чем объявлено
char Err[10]="не ошибка";
   Пример 10.1. Символьные константы в строках.
   Управляющие символы (Esc-последовательности)
в тексте строки предваряются знаком слэш "\". Такой
символ, встреченный в строке, приводит к выполнению
управляющего воздействия, например, "\n" вызовет пере-
вод строки. Чтобы особые символы были видны как сим-
волы, они удваиваются в записи строки.
#include <stdio.h>
void main(void)
{
  // выведем на экран несколько строк
  printf("%s\n","Строка символов");    // без особенностей
  printf("%s\n","Слэш \ запишем как \\ \n");
  // символ слэш удваивается
334                                                   Гл а в а 3



  printf("%s\n","Символ ""апостроф"" удваивается");
  // апостроф удваивается

  // здесь слэш не только не влияет на управление строкой,
  // но и не виден при выводе
  printf("%s\n","длинные строки могут быть /
  разбиты на части произвольно, /
  на самом деле это одна строка");

  // здесь сочетание \n управляет выводом строки,
  // разбивая ее на части
  printf("%s\n","длинные строки могут\n быть разбиты на
части\n
  произвольно, на самом\n деле это несколько строк.\n");
}
   Для ввода и вывода текстовых строк используются
специальные функции gets() и puts(), аргументом кото-
рых является строка.
   Пример 10.2. Инициализация строк. Ввод и вывод
текстовых строк.
   Для ввода и вывода строк можно использовать функ-
ции printf, scanf с управляющим признаком формата "%s".
При вводе строки ее текст будет введен только до первого
пробела.
   Объявление и инициализации строк
char Str_1[10]; // выделено 10 байт, значения не присвоены
char Str_2[]={'с','и','м','в','о','л','\0'};

// выделено 7 байт, инициализация как массив символов
char Str_3[]="primer & primer";

// выделено 16 байт, инициализация как текстовой строки
char *Str_4="primer string";

// выделено 14 байт, инициализация как указателя
char *Str_5;   // указатель, память не выделена
      Варианты вывода строк.
      1. Как строка по формату %s
printf("%s\n", Str_2);
За д ач и и у п р аж н е н и я                           335


     2. Как последовательность символов по формату %c
int i=0;
while(Str_2[i]) // пока не встречен последний символ '\0'
printf("%c", Str_2[i++]);
printf("\n");
     3. Как строка без формата
puts(Str_3);
     Ввод строк.
Для Str_1 можно вводить не более 9 символов.
scanf("%s",Str_1);    // текст будет введен до пробела
printf("%s",Str_1);
gets(Str_4);		        // текст будет введен до нажатия
			                   // клавиши [Enter]
puts(Str_4);
    Пример 10.3. Строки и указатели.
    Строку нельзя считать обычным массивом как раз бла-
годаря наличию нулевого байта '\0' в конце строки. Сим-
вольная строка, встреченная в выражении, — это адрес
массива символов. Может использоваться везде, где можно
использовать указатель, но не в левой части операции при-
сваивания. Удобно использовать косвенную адресацию,
при этом текущий указатель будет адресовать один сим-
вол строки, но в отладчике будет видна оставшаяся часть
строки до нулевого байта '\0'. Возможные ошибки связа-
ны с механизмами выделения памяти для динамических
строк. Если при объявлении указателя текстовая строка
проинициализирована, то выделена память, равная длине
этой строки. Нельзя даже пытаться записать в эту строку
больше символов, чем выделено. Если же при объявлении
указателя текстовая строка не проинициализирована, то
память под запись строки не выделена, и этот указатель
можно использовать только как рабочую переменную для
косвенной адресации при работе с какой-либо строкой.
    Объявлена и проинициализирована строка длиной
57 байт.
char *Str="Пример строки текста. Память выделена
         при инициализации.";
char *pts;		           // указатель на строку
int i=0;
336                                                     Гл а в а 3



    Для ввода-вывода строк используются функции gets(),
puts().
gets(Str); // нельзя вводить больше, чем 57символов
puts(Str);
    Так как память под указатель pts не выделена, нельзя
записать
gets(pts);
      Указателю можно присвоить значение
pts=Str ; // pts показывает на начало строки
pts+=14; // pts показывает на 14-й символ строки Str
// присваивание значения pts вносит изменения в строку
*pts=0;   // теперь здесь будет конец строки (15-й символ)
pts=Str;  // pts снова показывает на начало строки
   Обычным механизмом перемещения по строке явля-
ется смещение указателя
pts++;
    Однако этим механизмом надо пользоваться осторож-
но, так как при таком перемещении возможно появление
ошибки — выход за пределы строки.
    Для полного просмотра строки используется цикличе-
ский алгоритм, в котором управляющей переменной яв-
ляется указатель на очередной элемент (символ) строки,
который изменяется от адреса начала строки до достиже-
ния нулевого байта в конце строки.
pts=Str;		       // pts указывает на начало строки
while(*pts)      // пока его значение отлично от '\0'
{
// вывод очередного символа и смещение указателя
   printf("%c",*pts++);
}
printf("\n");
   Такой же циклический алгоритм используется и для
изменения содержимого строки. Управление циклом не
изменяется, а изменение символов строки достигается из-
менением значения указателя на очередной элемент (сим-
вол) строки.
pts=Str;		      // pts указывает на начало строки
while(*pts++)
{
За д ач и и у п р аж н е н и я                                  337


  *pts++='@';          // Каждый второй символ заменен на '@'
}
puts(Str);
    Пример 10.4. Внутренние коды символов.
    Данные символьного типа при хранении имеют вну-
тренние коды. ASCII кодом является число в пределах от
0 до 255. Внутри кодовой таблицы символы расположены
в определенном порядке. Значения символов по их кодам
можно увидеть, выполнив следующий пример. Здесь пе-
ременные i, j пробегают значения так, чтобы все значения
выражения (16*i+j), которые изменяются в пределах от 0
до 255, могли быть выведены в виде матрицы. Символы
с кодами 7–14 при выводе пропущены.
#include <stdio.h>
#include <conio.h>
void main(void)
{
  int i, j;
  clrscr();
  for(i=0; i<6; i++)
  {
?? for(j=0; j<16; j++)
?? {
??? if(16*i+j>7&&16*i+j<14) continue;
??? // управляющие символы
??? // символьное представление кода символа
??? printf("%c", 16*i+j);
?? }
?? printf("\n");
  }
}
   Использовать внутренний порядок следования кодов
символов можно при сравнении символов и при выполне-
нии арифметических операций над символами. Эти опе-
рации на самом деле выполняются над значениями вну-
тренних кодов символов.
char c1, c2;
// пусть эти символы имеют значения
// как сравнить два символа?
338                                                     Гл а в а 3



int k;
k=c1==c2; 		            // или c1>c2 и прочие условия
if(c1>='0' && c1<=9')
printf("Этот символ цифра\n",); // символ с1 – цифра
// для перебора в алфавитном порядке управляющая
// переменная цикла может быть символьной
char c;
for(c='a'; c<='z'; c++)
{
...
}
    Пример 10.5. Адресация в строках.
    К способам адресации в строках еще раз вернемся
на примере решения задачи копирования одной строки
в другую. Адресация для строк, как и для обычных масси-
вов, может быть прямой и косвенной.
    Зададим исходную строку длиной 15 байт и рабочую
переменную для косвенной адресации.
char *Str1="Первая строка.";
char *pts;		           // рабочая переменная
char *Str2;		          // новая строка – динамическая
puts(Str1);		          // вывод исходной строки
    Определение длины строки len выполняется в цикле.
Управляет циклом переменная pts. Ее начальное значе-
ние равно адресу строки.
    Пусть *pts — это значение очередного символа строки,
а *(pts++) — значение символа, следующего за ним. Выход
из цикла происходит, когда найден признак конца стро-
ки.
int len=0;
pts=Str1; // рабочая переменная указывает на начало строки
do
   len++;
while(*(pts++)!='\0');
// поиск нулевого байта и смещение указателя
printf("Длина строки %d\n", len);
     Выделим память для строки Str2 динамически столь-
ко же, сколько выделено для строки Str1.
Str2=new char[len];
За д ач и и у п р аж н е н и я                                 339


    Посимвольное копирование из строки Str1 в строку
Str2 с использованием прямой адресации начинается с ну-
левого символа строки и заканчивается, когда встречен
нулевой байт в конце исходной строки.
int i=0;             // начиная с нулевого символа строки
while(Str1[i]!='\0') // пока не встречен нулевой байт
{
   Str2[i]=Str1[i];  // посимвольное присваивание
   i++;              // и переход к следующему символу
}
     Цикл while заканчивается до переноса нулевого байта
в новую строку, поэтому по завершении цикла нужно его
дописывать программно.
Str2[i]='\0';		                  // формируется конец строки
puts(Str2);
   В следующем примере прямой адресации тоже посим-
вольно копируется строка, но запись цикла короче. Ис-
пользование оператора do удобнее тем, что нулевой байт
переносится в новую строку, поэтому его не нужно при-
писывать.
*Str2='\0';		           // очистка строки от содержимого
i=0;
do
   Str2[i]=Str1[i];     // посимвольное присваивание
while(Str1[i++]!='\0'); // проверка достижения конца строки
// нулевой символ переносится в новую строку
puts(Str2);
    Косвенная адресация при посимвольном копировании
требует использования указателя на char в качестве рабо-
чей переменной.
    В первом случае используем только один указатель на
строку, которая будет копией. Меняя адрес первой стро-
ки, покажем, как легко можно изменить значение адреса,
которое приведет к потере данных.
// очистка строки
*Str2='\0';
// управляет циклом переменная Str1, адресующая
// исходную строку
pts=Str2;		           // pts – указатель на новую строку
340                                                  Гл а в а 3



while(*Str1!='\0')
 *pts++=*Str1++;         // Str1 изменяется
   Адрес, выделенный ранее для переменной *pts, из-
менен операцией ++, поэтому строка потеряна. Признак
конца строки нужно перенести в строку-копию.
*pts='\0';		             // получена вторая строка
puts(Str2);
   Вернуться к первоначальному значению адреса пер-
вой строки можно, но мы введем новую переменную,
чтобы показать в следующем цикле, что нужно сделать,
чтобы косвенная адресация не изменяла адреса исхо-
дных строк. Для этого требуется две рабочие перемен-
ные, два указателя на обе строки, играющие роль сино-
нимов строк.
char *Str3="Новая строка"; // ее длина не больше,
                           // чем у копии
char *pts_2;               // для работы со второй строкой
char *pts_3;               // для работы с третьей строкой
pts_2=Str2;                // знает адрес строки
pts_3=Str3;                // знает адрес строки
*Str2='\0';                // очистка строки
    Управляет циклом переменная pts_3, адресующая ис-
ходную строку.
do
  *pts_2++=*pts_3;       // оба указателя смещаются
                                                одинаково
while(*pts_3++!='\0');
puts(Str2);
   Пример короткой записи цикла управления показы-
вает, как синтаксис С++ позволяет сократить текст про-
граммы. Тонкости алгоритма в этом случае не видны.
Выполняются все те же действия, что и в предыдущем
примере.
*Str2='\0';
pts_2=Str2;
pts_3=Str3;
while((*pts_2++=*pts_3++)!='\0');
puts(Str2);
За д ач и и у п р аж н е н и я                          341


    Пример 10.6. Функции и строки.
    При передаче строк в функции особенностей нет. Пере-
дача выполняется так же, как и для массивов. Строка долж-
на быть параметром функции. Отдельно передавать длину
строки нет необходимости, так как, во-первых, строка име-
ет признак конца, а во-вторых, ее длину всегда можно опре-
делить, используя функцию strlen библиотеки <string.h>,
подробнее о которой далее по тексту. Рассмотрим пример
функции преобразования строки, которая удалит из строки
«лишние» пробелы, т. е. те, что встречаются подряд друг за
другом. Эта операция может быть названа сжатием строки.
Сжать строку означает удалить из нее лишние пробелы.
    Приведем пример двух функций, первая из которых
использует прямую адресацию, вторая — косвенную.
#include <stdio.h>
#include <conio.h>
#include <string.h>

// прототип функции с прямой адресацией
void compress_1(char[]);

// прототип функции с косвенной адресацией
void compress_2(char*);

void main(void)
{
  char *str=new char[80];
  // указатель на строку и выделение памяти
  printf("\nВведите строку символов с пробелами.\n");
  gets(Str);
  printf("Наша строка: \n");
  puts(Str);
  compress_1(Str);		           // обращение к функции
  printf("Наша строка: \n");
  puts(Str);
  printf("\nВведите строку символов с пробелами.\n");
  gets(Str);
  printf("Наша строка: \n");
  puts(Str);
342                                                        Гл а в а 3



    compress_2(Str);		            // обращение к функции
    printf("Наша строка: \n");
    puts(Str);
    getch();
}
   Описание функции, использующей прямую адреса­цию
строки. Длину строки Str возвращает функция strlen(Str).
   В коде функции i — рабочая переменная для поиска
рядом стоящих пробелов, mid — рабочая переменная для
сдвига символов.
void compress_1(char Str[])
{
int i, mid;
i=0;                              // внешний цикл поиска
                                  // рядом стоящих пробелов
while(i<strlen(Str)–1)
  if((Str[i]==' ')&&(Str[i+1]==' ')) // два пробела рядом
?? {
?? // внутренний цикл сдвига
??? for(mid=i; mid<strlen(Str); mid++)
???? Str[mid]=tr[mid+1];             // символ '\0'тоже сдвигается
?? }
  else                               // движение по строке,
                                     // если не было сдвига
  i++;
}
   Описание функции, использующей косвенную адреса-
цию строки.
void compress_2(char *Str)
{
  Char *ip, *mid;
  ip=Str;                     // внешний цикл поиска рядом
                              // стоящих пробелов
  while(*ip!='\0')
?? if(*ip==' '&&*(ip+1)==' ') // два пробела рядом
??? {
??? // внутренний цикл сдвига
???? mid=p;		 // запомнили адрес
????? while(*mid!='\0')
За д ач и и у п р аж н е н и я                        343


????? {
??????? *mid=*(mid+1); // копирование символа
??????? mid++;         // смещение указателя
????? }
??? }
?? else                // движение по строке,
                       // если не было сдвига
??? ip++;
}
    Пример 10.7. Функция, возвращающая строку.
    Строка, передаваемая в функцию как параметр, будет
изменена, потому что передается адрес строки. Многие
алгоритмы требуют сохранения исходной строки, многие
алгоритмы должны породить новые строки. Следователь-
но, функция будет порождать и формировать новую стро-
ку и должна ее вернуть. Сравним две функции, одна из
которых возвращает новую строку через параметр, дру-
гая через указатель.
    Функция сформирует новую строку на основе задан-
ной, вставляя в нее указанный символ через один.
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <conio.h>
   Основная задача — сохранить строку-образец. Новая
строка будет содержать все символы исходной, но после
каждого символа исходной строки будет добавлен новый
символ.
   Функция Transform_1 получает и возвращает строки
только через параметры, поэтому ее тип void. Память для
строк должна быть выделена в main.
void Transform_1(char *Str, char *Ind, char Symbol)
{
char *pts;      // рабочая переменная
pts=Str;		      // теперь pts – это исходная строка
char *pti;      // рабочая переменная
pti=Ind;		      // теперь pti – это новая срока Ind
do
{
344                                                     Гл а в а 3



  // циклом управляет pts
  *pti=*pts;      // символ приписывается к Ind(*pti)
                  // из Str(*pts)
  pti++;
  *pti=Symbol;    // Symbol приписывается к Ind(*pti)
  pti++;
}
while(*pts++!='\0'); // выход при достижении конца строки
// '\0' перенесен в строку назначения
}
     Функция Transform_2 получает исходную строку через
параметры, а новую возвращает через указатель, поэтому
ее тип char *. Память для новой строки должна быть вы-
делена в теле функции.
char *Transform_2(char *Str, char Symbol)
{
  int len;
  len=strlen(Str);      // длина строки Str
  char *Ind;
  Ind=new char[len*2]; // выделена память для новой
			                     // строки
  char *pts;		          // рабочая переменная
  pts=Str;		            // теперь pts — это исходная строка
  char *pti;		          // рабочая переменная
  pti=Ind;		            // теперь pti — это новая срока Ind
  // алгоритм тот же самый, но запись короче
  do
  {
?? *pti++=*pts;
?? *pti++=Symbol;
  }
  while(*pts++!='\0');
?? return Ind;		        // возвращается адрес новой строки
}
    Обращение к этим функциям выполняется различным
образом. Вызов Transform_1 — это оператор-функция, вы-
зов Transform_2 — это оператор-выражение, его значение
должно быть присвоено переменной такого же типа, как
и тип возвращаемого функцией значения.
За д ач и и у п р аж н е н и я                        345


void main(void)
{
  clrscr();
  char *Str=new char[80];
  char *Str_new_1=new char[160];
  Str="Преобразование строки без изменения образца.";
  puts(Str);
  Transform_1(Str, Str_new_1, '!');
  // для Str_new_1 память выделена
  puts(Str_new_1);
  char *Str_new_2;      // просто адрес, память выделит
			                     // функция
  Str_new_2=Transform_2(Str, '*');
  puts(Str_new_2);
}
    Пример 10.8. Использование библиотек функций ра-
боты с символами и строками.
    Библиотека функций <ctype.h> используется для рабо-
ты с символами, имеет много полезных функций. Напри-
мер, isalpha определит, является ли символ буквой латин-
ского алфавита, tolower и toupper позволят преобразовать
символ латинского алфавита соответственно к нижнему
и верхнему регистру, isascii определит, имеет ли символ
код ASCII (0–127) и т. д.
    Библиотека <stdlib.h> имеет функции преобразования,
которые используются для преобразования строки в чис-
ло (atof, atoi) или числа в строку (itoa) и т. д.
    Библиотека <string.h> содержит функции преобра-
зования строк. Например, strlen возвращает целочис-
ленную длину строки, включая '\0', strcpy возвращает
указатель на копию строки, strcat выполняет конкате-
нацию строк, strchr поиск первого вхождения символа,
strcmp сравнение строк, strstr поиск подстроки в строке
и т. д.
    Рассмотрим несколько простых примеров использова-
ния библиотечных функций.
    Перед использованием функций надо подключить со-
ответствующую библиотеку.
#include <stdio.h>
346                                                      Гл а в а 3



#include <ctype.h>
#include <string.h>
    Функция cou_dig    подсчитает, сколько символов
в строке являются цифрами, используя функцию isdigit,
которая получает как входное данное символ (char) и воз-
вращает значение 0 или 1.
int cou_dig(char *str)
{
   int count=0;
   while(*str!='\0')
   {
?? if(isdigit(*str)!=0) count++;
??? str++;
   }
   return count;
}
    Пример совместного использования функции cou_dig
и библиотечных функций strcpy, strcat, strstr.
void main(void)
{
  char *my_str="1 2 3 4 5.";
  printf("Цифр=%d",cou_dig(my_str));
  char *Old_str="Cтрока текста";
  char New_str[80];

  // для копирования строки Old_str по адресу New_str
  // используем функцию strcpy
  strcpy(New_str, Old_str);   // New_str="Cтрока текста"
  puts(New_str);

   // для слияния строк (конкатенации) используем функцию
strcat
   strcat(New_str, Old_str);
   // New_str="Cтрока текста Cтрока текста"
   puts(New_str);

  // для поиска вхождения подстроки в строку
  // используем функцию strstr.
  char *found="ока";		          // строка поиска "ока"
За д ач и и у п р аж н е н и я                                 347


  char *Yes;
  Yes=strstr(Old_str, found);           // Yes="ока" текста
  if(Yes==NULL)			                      //Если бы вхождения не было
?? printf("Нет");
  else
?? printf("Есть '%s'\n", Yes);
}
    Пример 10.9. Работа с текстом.
    Текст может быть представлен двумерными масси-
вами строк. В качестве примера покажем реализацию
функции сортировки строк текста в алфавитном порядке
(по возрастанию первых символов строки) с использова-
нием алгоритма сортировки простым обменом. Функция
SortStr в качестве параметра использует указатель на мас-
сив строк. Массив фактически двумерный. Разбивку на
строки определяет наибольшая длина строки LEN.
    Используем функции из библиотеки string.h.
#include <stdio.h>
#include <string.h>
#define LEN 80		                 // наибольшая длина строки
#define SIZE 20		                // наибольшее число строк

void SortStr(char *Srt[LEN], int num)
// массив строк, num – его длина
{
   int i;
   int flag;
   char buf[LEN];        // для перестановки строк местами
   // сортировка простым обменом
   flag=1;
   while(flag!=0)
?? for(i=0, flag=0; i<num–1; i++)
?? {
??? if(strcmp(Str[i], Str[i+1])>0)
??? //символ Str[i]>символа Str[i+1].
???? {
???? // перестановка строк
???? strcpy(buf, Str[i]);
???? strcpy(Str[i], Str[i+1]);
348                                                 Гл а в а 3



???? strcpy(Str[i+1], buf);
???? flag=1;		        // запоминает факт перестановки
?? }
  }
}

void main(void)
{
  char Text[SIZE][LEN]; // массив вводимых строк
  char *ps[SIZE];        // массив указателей на строки
			                      // массива
  int i, num;		          // num – число вводимых строк
  printf("Введи строки до пустой строки. \n");
  num=0;
  while((gets(Text[num])!=NULL)
          &&num<=SIZE&&strcmp(Text[num],"")!=0)
  // условие завершения ввода:
  // 1) пока gets возвращает не пустое значение,
  // 2) пока число введенных строк меньше, чем SIZE,
  // 3) пока строка не пуста, и strcmp позволит сравнить
  // значения символов, а не указатели
  {
?? ps[num]=Text[num]; // указатель на очередную строку
?? num++;
  }
  printf("Вывод перед обращением к функции сортировки\n");
  for(i=0; i< um; i++)
??? puts Text[i]);       // введенный массив строк
  printf("\n");
  SortStr(ps, num);
  printf("Вывод после обращения к функции сортировки\n ");
  for(i=0; i<num; i++)
??? puts(Text[i]);       // отсортированный массив строк
?? printf("\n");
?? for(i=0; i<num; i++)
??? puts(ps[i]);         // указатель на сортированные
			                      // строки
  printf("\n");
}
За д ач и и у п р аж н е н и я                        349

                                 Варианты заданий
    Задание 1.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, сколько раз входит в строку некоторый про-
извольный символ (задать как параметр функции).
    2. Дан текст (2–3 строки) в файле F1. Описать функцию
преобразования строки, которая вносит изменения в стро-
ку текста, повторяя дважды каждую букву строки (знаки
препинания и прочие символы не изменять). Преобразо-
вать все строки текста и новый текст записать в файл F2.
    Задание 2.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, сколько раз в строке встречаются знаки
препинания ".", "?", "!" и др.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
слов, отделенных друг от друга пробелами. Описать функ-
цию, удаляющую из строки слово с номером М (номер
слова М один из параметров функции). В вызывающей
программе номер слова лучше всего вводить в диалоге.
Преобразовать все строки текста и новый текст записать
в файл F2.
    Задание 3.
    1. Описать функцию работы со строкой символов, ко-
торая найдет первое вхождение некоторого слова (задать
как один из параметров функции).
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию преобразования строки, которая после каждого де-
сятого символа вставит в текст сочетание символов ":!:",
в начало строки — "!:", в конец — ":!". Преобразовать все
строки текста и записать новый текст в файл F2.
    Задание 4.
    1. Описать функцию работы со строкой символов, ко-
торая найдет первое вхождение некоторого символа и по-
следнее его вхождение (символ задать как один из пара-
метров функции).
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
слов, отделенных друг от друга одним символом пробела.
Описать функцию, определяющую, есть ли в тексте некото-
рое слово, заданное заранее (включить в список параметров
350                                                Гл а в а 3



функции, а в вызывающей программе вводить в диалоге).
Описать функцию, удаляющую слово из текста. Преобразо-
вать все строки текста и новый текст записать в файл F2.
    Задание 5.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, сколько всего слов в строке, если известно,
что слова отделены друг от друга пробелами или сочета-
нием пробела со знаками препинания.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию, преобразующую строку текста следующим образом:
если в строке есть подстроки, заключенные в скобки, уда-
лить их вместе со скобками. Если есть вложения скобок,
удалить всю внешнюю скобку. Преобразовать все строки
текста и новый текст записать в файл F2.
    Задание 6.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, есть ли в строке стоящие рядом одинаковые
символы, и определит число таких вхождений.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию преобразования строки, которая заменяет все одина-
ковые идущие подряд символы одним вхождением этого
символа. Преобразовать все строки текста и записать но-
вый текст в файл F2.
    Задание 7.
    1. Описать функцию работы со строкой символов, ко-
торая проверит, не является ли эта строка палиндромом.
Для проверки придется удалить все пробелы, отделяю-
щие слова, и перевести символы в один регистр. Пример
палиндрома «А роза упала на лапу Азора».
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию преобразования строки, которая заменяет все повтор-
ные вхождения символа пробел одним символом пробела,
в начало строки добавляет слово «НАЧАЛО», в конце сло-
во «КОНЕЦ». Преобразовать все строки текста и записать
новый текст в файл F2.
    Задание 8.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, сколько в строке символов, которые явля-
ются цифрами, и сформирует из них новую строку.
За д ач и и у п р аж н е н и я                      351


    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию обработки строки, которая удаляет из строки все зна-
ки препинания. Преобразовать все строки исходного тек-
ста и записать новый текст в файл F2.
    Задание 9.
    1. Описать функции работы со строкой символов, ко-
торые найдут самое длинное и самое короткое слово стро-
ки.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию, которая удалит из строки символы, находящиеся
рядом (справа и слева) с символом "#". Преобразовать все
строки текста и записать новый текст в файл F2.
    Задание 10.
    1. Описать функцию работы со строкой символов, ко-
торая найдет вхождение в строку самой длинной последо-
вательности пробелов и определит ее длину.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию, которая удалит из исходной строки все слова, име-
ющие окончание «КАЯ» или «КОЕ». Преобразовать все
строки текста и записать новый текст в файл F2.
    Задание 11.
    1. Описать функцию работы со строкой символов, ко-
торая найдет первое вхождение подстроки, заключенной
в скобки.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию, которая после каждого пробела вставит в текст вос-
клицательный знак. Преобразовать все строки текста
и записать новый текст в файл F2.
    Задание 12.
    1. Описать функцию работы со строкой символов, ко-
торая удалит из строки первое и последнее слова.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию, которая формирует из исходной строки новую, за-
писывая в нее только подстроки, заключенные в круглые
скобки (вместе со скобками). Преобразовать все строки
текста и записать новый текст в файл F2.
    Задание 13.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, сколько слов строки начинаются с некото-
352                                                 Гл а в а 3



рой буквы, заданной произвольно (задать как один из па-
раметров функции).
    2. Дан текст (2–3 строки) в файле F1. Текст состо-
ит из слов, отделенных друг от друга одним пробелом.
Описать функцию преобразования строки: из исходной
строки в новую строку переписать только те слова, дли-
на которых больше трех, отделяя их пробелами. Пре-
образовать все строки текста и записать новый текст
в файл F3.
    Задание 14.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, сколько из слов строки начинаются и за-
канчиваются одной буквой, например, «абракадабра»,
«сервис», «кулак» и пр.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию, которая удаляет из строки все сочетания букв «АЯ»
и «ОЕ». Преобразовать все строки текста и записать но-
вый текст в файл F2.
    Задание 15.
    1. Описать функцию работы со строкой символов, ко-
торая получит массив длин слов этой строки.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит
из слов, отделенных друг от друга произвольным числом
пробелов. Описать функцию преобразования строки, ко-
торая каждое слово отделяет от другого слова сочетанием
трех символов "***". Преобразовать все строки текста и за-
писать новый текст в файл F2.
    Задание 16.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, есть ли в строке символы, отличные от букв,
пробела и точки.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
слов, отделенных друг от друга одним символом пробела.
Описать функцию, которая меняет местами первое сло-
во с последним словом. Преобразовать все строки текста
и записать новый текст в файл F2.
    Задание 17.
    1. Для заданного натурального числа n получить
его правильное символьное представление в виде стро-
За д ач и и у п р аж н е н и я                         353


ки, где триады цифр отделены друг от друга пробелами.
Например, для n = 1753967 запись должна иметь вид:
«1 753 976».
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию преобразования строки, которая заменяет все после-
довательности цифр, стоящих подряд, одним символом
решетки "#". Преобразовать все строки текста и записать
новый текст в файл F2.
    Задание 18.
    1. Для заданного натурального числа n (n < 20) полу-
чить его правильное текстовое представление в виде стро-
ки текста, например, «три», «девятнадцать», «одиннад-
цать» и пр.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию, которая формирует новую строку, занося в нее сим-
волы исходной строки по 10 через каждые десять. То есть
с 1-го по 10-й, с 21-го по 30-й и т. д. Преобразовать все
строки текста и записать новый текст в файл F2.
    Задание 19.
    1. Описать функцию работы со строкой символов, ко-
торая проверит, начинается ли каждое слово с большой
буквы.
    2. Дан текст в файле F1 в виде:
    ИМЯ ОТЧЕСТВО ФАМИЛИЯ_1
    ИМЯ ОТЧЕСТВО ФАМИЛИЯ_2
    …
    Описать функцию, которая формирует текстовую
строку в формате:
    ФАМИЛИЯ И. О.
    Сохранить преобразованный текст в файле F2.
    Задание 20.
    1. Дано натуральное число n (n < 100), означающее
возраст человека в годах, например, 1, 11, 51 и т. д. Полу-
чить текстовую строку, выражающую возраст человека.
Например: «Один год», «Одиннадцать лет», «Пятьдесят
один год».
    2. Дан текст (2–3 строки) в файле F1. Текст состоит
из слов, отделенных друг от друга пробелами. Описать
функцию, которая находит самое длинное слово в строке
354                                                 Гл а в а 3



и удаляет его. Преобразовать все строки текста и записать
новый текст в файл F2.
    Задание 21.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, есть ли в строке правильное соответствие
открывающих и закрывающих скобок.
    2. Дан текст (2–3 строки) в файле F1. Описать функ-
цию преобразования строки, которая заменяет все подряд
идущие пробелы одним вхождением пробела и удаляет
все символы, отличные от букв (знаки препинания и пр.).
Записать новый «чистый» текст в файл F2.
    Задание 22.
    1. Описать функцию работы со строкой символов, ко-
торая найдет количество пар открывающих и закрываю-
щих скобок разного вида. Функции вернет 1, если есть со-
ответствие пар, и 0, если соответствия нет.
    2. Дан текст (2–3 строки) в файлах F1 и F2. Тексты со-
стоят из слов, отделенных друг от друга одним пробелом.
Описать функцию, которая определяет, насколько совпа-
дают данные в файлах (по словам). Все несовпадающие
слова вывести в файл G в формате: «Слово из первого фай-
ла», «Слово из второго файла».
    Задание 23.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, сколько в строке знаков препинания.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
слов, отделенных друг от друга пробелами. Описать функ-
цию, которая каждый одиночный пробел заменяет пятью
пробелами, идущими подряд. Преобразовать все строки
текста и записать новый текст в файл F2.
    Задание 24.
    1. Описать функцию работы со строкой символов, ко-
торая найдет, стоит ли пробел после каждого знака пре-
пинания.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
слов, отделенных друг от друга пробелами или сочетанием
символов «точка пробел». Описать функцию, формирую-
щую словарь данного текста в виде массива слов. Повторя-
ющиеся слова не включать. Вывести словарь в файл F2.
За д ач и и у п р аж н е н и я                        355


    Задание 25.
    1. Описать функцию работы со строкой символов, ко-
торая возвращает первое слово строки.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит
из слов, отделенных друг от друга пробелами. Описать
функцию, которая найдет все вхождения некоторого сло-
ва в строке и заменит его некоторым другим словом (эти
слова задать как параметры функции). Преобразовать все
строки текста и записать новый текст в файл F2.
    Задание 26.
    1. Описать функцию работы со строкой символов, ко-
торая находит и возвращает последнее слово строки.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
слов, отделенных друг от друга пробелами или знаками
препинания. Описать функцию, формирующую частот-
ный алфавит данного текста в виде массива символов
(букв). Вывести частотный алфавит в файл F2.
    Задание 27.
    1. Описать функцию работы с текстом, представлен-
ным в виде строки символов, которая найдет среднее чис-
ло слов в предложениях этого текста.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
потока предложений, отделенных друг от друга знаками
препинания. Описать функцию, которая читает текст,
выделяет одно предложение и выводит в текстовый файл
F2 по одному предложению в строке.
    Задание 28.
    1. Описать функцию работы с текстом, представлен-
ным в виде строки символов, которая найдет среднюю
длину всех слов этого текста.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
слов, отделенных друг от друга пробелами. Описать функ-
цию, которая находит самое длинное слово в тексте, а за-
тем формирует в новом файле форматированный текст,
в котором каждое слово дополнено пробелами до длины
самого длинного слова. Записать новый текст в файл F2.
    Задание 29.
    1. Описать функцию работы с текстом, представлен-
ным в виде строки символов, которая «нумерует» строку,
356                                                  Гл а в а 3



добавляя в начало строки текстовое представление номе-
ра, переданного в функцию как параметр.
    2. В файле F1 даны натуральные числа (n < 1000), озна-
чающие некоторую цену в копейках, например, 317, 5005,
100 и пр. Описать функцию, которая формирует текстовую
строку, выражающую цену в рублях и копейках. Напри-
мер: «3 руб. 17 коп.», «50 руб. 05 коп.», «1 руб. 00 коп.».
Записать числа исходного файла и новый текст в файл F2.
    Задание 30.
    1. Описать функцию работы со строкой символов, ко-
торая возвращает значение слова, номер которого задан
как параметр функции.
    2. Дан текст (2–3 строки) в файле F1. Текст состоит из
слов, отделенных друг от друга пробелами. Описать функ-
цию, которая в строке текста находит все слова, одноко-
ренные некоторому заданному корню, и формирует из
них новую строку. Преобразовать все строки текста и за-
писать новый текст в файл F2.

      Тема 11. Использование двумерных
      массивов в содержательных задачах
    В заданиях этого раздела предполагается использо-
вание файлов данных. Работа с файлами описана в п. 2.8
(глава 2).
    Задание 1. При записи данных о соревнованиях по
шахматам формируется матрица турнира особого вида.
Результат матча может быть 1 (выигранная партия),
0 (проигранная) или 0,5 (ничья). При вводе данных
нужно получить симметричную матрицу турнира, где
на главной диагонали нули, для обоих участников 0,5
в случае ничьей, а если участник выиграл, то его пар-
тнер проиграл и ему записывается 0. Написать функ-
цию для ввода данных турнира в диалоге с формирова-
нием матрицы турнира, которую сохранить в текстовом
файле. Написать функцию обработки турнира, чтобы
определить победителя. Написать функцию обработки
турнира, чтобы распределить участников по убыванию
набранных очков.
За д ач и и у п р аж н е н и я                                         357


    Задание 2. Фабрика производит валенки, тапочки
и боты. Данные об объемах сбыта продукции каждого
вида за прошлый год помесячно хранятся в файле. При
подведении итогов года дирекция требует найти суммы
накопительным итогом для каждого вида продукции,
и сохранить эту информацию в файле, а также выяснить,
в каком месяце имеет место наибольший сбыт каждого
вида продукции. Использовать функции для накопления
итогов и для поиска максимума.
    Задание 3. Валяльная фабрика производит валенки.
Данные об объемах сбыта продукции и о ценах продаж за
прошлый год помесячно хранятся в файле в виде таблицы
следующего вида.
   Месяц      Объем продаж, пар   Цена продажи, руб.   Себестоимость, руб.
 Январь               4500               100                   20
 Февраль              3900               100                   25
   …

    При подведении итогов года необходимо выяснить ди-
намику сбыта, т. е. найти и упорядочить по убыванию ин-
формацию о прибылях, приносимых производством. Ис-
пользовать функцию для вычисления ежемесячной при-
были. Для сортировки матрицы по столбцу «прибыль»
использовать функцию сортировки матрицы методом пу-
зырька.
    Задание 4. Кот Матроскин владеет стадом коров,
а также организовал производство молока, сметаны, тво-
рога, масла, сыра. Ежедневно он записывает в текстовый
файл дневной сбыт каждого вида продукции, причем
цены товара у Матроскина могут изменяться, и цены ему
приходится тоже ежедневно записывать. В конце месяца
необходимо подвести итог по результатам торговли, что-
бы выяснить, какая продукция пользуется наибольшим
и наименьшим спросом, а также какая продукция прино-
сит наибольшую и наименьшую прибыль.
    Задание 5. В соревнованиях по фигурному катанию
каждый спортсмен принимает участие в трех видах со-
ревнований. Каждый вид судят десять судей. Для более
точной оценки самый низкий и самый высокий баллы
358                                                  Гл а в а 3



судей отбрасывают. Составить протокол судейства для
n участников в виде матрицы, сохраненной в файле. Най-
ти победителя соревнований. Использовать функции для
обработки результатов соревнований.
    Задание 6. Коротышки собирают урожай огурцов, по-
мидор, гороха, моркови и прочих плодов земли. Работают
n коротышек, а Знайка подводит итоги их трудовой дея-
тельности. Он завел текстовый файл и написал програм-
му, которая ежедневно в диалоге позволяет ввести дан-
ные об итогах трудового дня. Эти данные суммируются
с итогами предыдущих дней работы, и файл обновляется.
По итогам работы в конце уборочной кампании произво-
дится оплата. Стоимость сбора одного вида овощей Знай-
ка хранит в отдельном файле. Представьте себя на месте
Знайки.
    Задание 7. Разборчивая невеста занесла в файл данные
о своих потенциальных женихах: внешность и богатство
она оценила в баллах.
      Имя      Возраст       Внешность       Богатство
Иван             25             15              10
Петр             30             15              10
Павел            40             12              50
Борис            45             8               50
Сергей           45             10             100

   Составить оценочную таблицу в виде матрицы. Воз-
раст невесты N лет. Требования к претенденту сформули-
рованы просто: средняя красота, среднее богатство, сред-
ний возраст, но не моложе ее самой. Помогите сделать
выбор. Использовать функцию выбора, возвращающую
номер потенциального жениха.
   Задание 8. Сорок разбойников провели турнир, в ко-
тором каждый разбойник бился с каждым. Сведения о ре-
зультатах соревнований записали в файл в виде турнир-
ной таблицы, где номера строк и столбцов — это номера
разбойников. Найти самого сильного и самого слабого
разбойника. Использовать функцию обработки турнира.
   Задание 9. Учебное заведение проводит приемные эк-
замены на новый учебный год. Информация об абитури-
За д ач и и у п р аж н е н и я                      359


ентах занесена в текстовый файл в виде матрицы. Каж-
дый должен сдать три экзамена. Те, кто получил двойку
за первый экзамен, ко второму экзамену не допускаются,
а кто получил двойку за второй экзамен, не допускаются
к третьему. Обработать данные об абитуриентах, выпол-
няя удаление после первого, второго и третьего экзаменов
с использованием функции обработки матрицы.
    Задание 10. Царевна Несмеяна, принимая претенден-
тов на ее руку и сердце, задает каждому М вопросов. Если
ответ очень понравился, она присуждает 2 балла, если не
очень понравился — 6 баллов, если очень не понравил-
ся — 8. Данные опроса она сама записывает в текстовый
файл. В конце дня выбирается лучший претендент. Ис-
пользовать функцию обработки матрицы, чтобы опреде-
лить самого понравившегося претендента. Этот кандидат
приписывается в файл, хранящий многолетнюю историю
испытаний, по которому, возможно, когда-то будет при-
нято окончательное решение.
    Задание 11. n коротышек собирают урожай m видов
различных овощей. Знайка подводит итоги их трудовой
деятельности и выполняет расчет. Он завел текстовый
файл, и написал программу, которая ежедневно в диало-
ге позволяет ввести данные об итогах трудового дня. По
количеству собранных овощей в конце дня производится
оплата. Сбор одного овоща каждого вида Знайка хранит
в отдельном файле. Алгоритм оплаты труда сложный.
Вычисляется среднее арифметическое собранных всеми
за день овощей по каждому виду. Если коротышка со-
брал больше, чем среднее арифметическое этого вида, то
сбор каждого овоща сверху оплачивается в 2 раза дороже.
Тот, кто собрал больше всех, получает премию в размере
стоимости сбора трех овощей этого вида. Ежедневно Знай-
ка подсчитывает, сколько денег получает каждый коро-
тышка за собранный урожай. Эти данные он приписывает
в итоговый текстовый файл, чтобы впоследствии подвести
общий итог уборочной кампании.
    Задание 12. Кот Матроскин владеет стадом n коров.
Ежедневно он записывает в текстовый файл дневной удой
каждой коровы. Кот желает приобрести программу, ко-
360                                               Гл а в а 3



торая позволит подвести итоги производительности его
коров. В конце каждого месяца Матроскин желает найти
общий удой каждой коровы, а также наибольший и наи-
меньший. Эти данные должны быть программно припи-
саны в новый текстовый файл, по данным которого Ма-
троскин подведет годовой итог. Использовать функцию
(функции) обработки результатов.
    Задание 13. Отец Федор открыл небольшой свечной за-
водик под Самарой. На заводике льют свечи малые, сред-
ние, большие, очень большие и особые. Ежедневный итог
по продажам каждого вида продукции в стоимостном вы-
ражении матушка дописывает в текстовый файл. По за-
вершении месяца нужно подвести итог, какая суммарная
прибыль получена от каждого вида продукции, какой вид
приносит наибольшую и наименьшую прибыль.
    Задание 14. Сорок разбойников провели соревнование
по брейк дансингу. Судили пять судей. Запись о результа-
тах записали в файл в виде матрицы 40?5. Чтобы резуль-
тат был точнее, самый низкий и самый высокий баллы
судей решили не учитывать. Составить оценочную табли-
цу в виде матрицы, найти победителя соревнований. Ис-
пользовать функцию обработки результатов соревнова-
ний, возвращающую номер победителя.
    Задание 15. Дана матрица размером 7?7. Это семеро
козлят устроили турнир по копытрестлингу. Сведения
о результатах соревнований записали в файл в виде тур-
нирной таблицы, где номера строк и столбцов, это номера
козлят, принявших участие в турнире. Турнирная табли-
ца представлена в виде симметричной матрицы. Найти
распределение козлят по силе. Использовать функцию
обработки турнира.
    Задание 16. Семеро гномов копают золотой песок
шесть дней в неделю, а в седьмой отдыхают. Сколько на-
рыл за день каждый гном, Белоснежка вечером записыва-
ет в файл. В воскресенье подводится итоги. Самый трудо-
любивый гном награждается поцелуем красавицы, самый
ленивый — мытьем посуды. Найти самого старательного
и самого ленивого гномов. Использовать функцию (функ-
ции) обработки результатов.
За д ач и и у п р аж н е н и я                                       361


   Задание 17. Коротышки провели психологическое те-
стирование «Узнай себя». Запись о результатах записали
в файл в виде таблицы, где на перекрестье строк и столб-
цов записана оценка в виде итогового балла.
         Имя                     Умный     Смелый         Добрый
 Знайка                           10           5             8
 Незнайка                          2          10             5
 Пончик                           5           3             10
 Шурупчик                         8           8             7
 …

   Составить оценочную таблицу в виде матрицы, найти
самого умного, самого смелого, самого доброго из короты-
шек. Использовать функции.
   Задание 18. Коротышки устроили турнир по футболу.
Было четыре команды: Знайчики, Незнайчики, Пончи-
ки, Сиропчики. Результаты игр записали в файл в виде
таблицы соревнований.
 Знайчики                  Незнайчики                3           2
 Знайчики                  Пончики                   3           1
 Знайчики                  Сиропчики                 1           2
 Незнайчики                Пончики                   4           1
 Незнайчики                Сиропчики                 2           2
 Пончики                   Сиропчики                 2           3

   Составить турнирную таблицу в виде матрицы игр,
определить победителя. Использовать функцию обработ-
ки турнира.
   Задание 19. Три эксперта оценивают накануне выборов
популярность десяти кандидатов по 20-балльной шкале.
                         Эксперт 1       Эксперт 2       Эксперт 3
 Кандидат 1                  15             10              10
 Кандидат 2                  18             12              10
 …

   Составить оценочную таблицу в виде матрицы. Подве-
сти итог по сумме баллов каждого кандидата, найти трех
самых популярных кандидатов. Использовать функции
обработки матрицы.
362                                                Гл а в а 3



    Задание 20. Для контроля состояния трубопровода
ежечасно в течение суток измеряется давление на некото-
рых точках, где установлены датчики. Для снижения по-
грешностей датчиков перед обработкой исходные данные
сглаживаются путем замены каждого элемента значени-
ем среднего арифметического трех стоящих рядом значе-
ний (для первого и последнего двух). Результат формиру-
ется в новом массиве. Выполнить подготовку данных для
n датчиков, если снятые ими данные за сутки записаны
в текстовый файл.
    Задание 21. Белоснежка назначила каждому из семе-
рых гномов день недели, когда тот должен дежурить по
кухне. Каждый день она ставит оценку за дежурство по
пятибалльной шкале, а в конце месяца подводит итог,
чтобы наградить лучшего гнома. Сведения о результатах
проверки Белоснежка записывает в файл в виде матрицы,
где номера строк — это номера гномов, а столбцов — номе-
ра недель. Найти самого старательного и самого ленивого
гномов. Использовать функцию (функции) обработки ре-
зультатов.
    Задание 22. Чипполино проводит ежедневный мони-
торинг погоды, записывая в текстовый файл информацию
о дневной температуре, влажности, давлении, количестве
выпавших осадков и скорости ветра. Пытаясь дать про-
гноз на завтра, он всего лишь усредняет все предыдущие
данные за месяц. Текстовый файл прогнозов сохраняет
все данные. Выяснить, насколько прогнозирование оши-
бочно, сравнивая данные файла прогнозов с данными
файла мониторинга.
    Задание 23. Фермер снял план своего участка прямо­
угольной формы и сформировал матрицу размером n?m (раз-
мер сетки 1 м), в которой на пустых местах записаны нули,
а на занятых цифры, например 1 — жилой дом, 2 — зеленые
насаждения, 3 — хозяйственные постройки. Матрица зане-
сена в текстовый файл. Теперь фермер желает выяснить:
  • каков процент занятости его территории;
  • можно ли полностью огородить участок живой изго-
    родью шириной 1 м, а если нет, то какие будут препят-
    ствия;
За д ач и и у п р аж н е н и я                       363


  • на каком месте можно построить сарайчик размером k
    на l, если это возможно.
    Использовать функции обработки матрицы.
    Задание 24. Кафе специализируется по бизнес-ланчам
для тех, кто следит за своей фигурой, поэтому в меню по-
мимо цены указана и калорийность каждого блюда. Пред-
лагается N комплексных ланчей, состоящих из Q блюд
каждый. Стоимость и калорийность каждого блюда за-
писаны в текстовых файлах в виде матрицы стоимостей
и матрицы калорийностей. Выбрать все ланчи, калорий-
ность которых ниже, чем указанное значение. Подсчитать
стоимость. Выбрать все ланчи, стоимость которых ниже,
чем указанное значение. Подсчитать калорийность.
    Задание 25. В аптечном складе хранятся лекарства.
Сведения о лекарствах содержатся в специальной ведомо-
сти: номер лекарства, количество (в шт.), цена. Ведомость
хранится в текстовом файле. Провизор время от времени
развлекается, решая следующие нестандартные задачи:
  • сколько стоит самый дешевый и самый дорогой пре-
    парат;
  • каково количество всех препаратов на складе;
  • какова общая стоимость всех препаратов.
    Использовать функции для нахождения минимально-
го, максимального элементов массива и функцию для на-
хождения суммы.
    Задание 26. В музее регистрируется в течение дня вре-
мя прихода и ухода каждого посетителя. Таким образом,
за день получены N пар значений, где первое значение
в паре показывает время прихода посетителя и второе
значения — время его ухода. Найти промежуток време-
ни, в течение которого в музее одновременно находилось
максимальное число посетителей, минимальное число по-
сетителей.
    Задание 27. Кукольный театр поставил n спектаклей.
Ежедневно театр дает несколько различных спектаклей.
Мальвина продает билеты и перед каждым сеансом зна-
ет, сколько детских и взрослых билетов продано. Чтобы
знать репертуарную политику, Мальвина желает выяс-
нить, какие спектакли имеют наибольшую популярность.
364                                                                Гл а в а 3



Для этого данные о посещаемости каждого спектакля она
сохраняет в текстовом файле следующего вида.
 Спектакль   Показов   Детских билетов   Цена   Взрослых билетов    Цена
Золушка        20            25          10           30              20
Король Лир     15            10          10           50              30
…

    Данные о спектакле вводятся в диалоге, и обновляют
матрицу данных, причем данные о числе билетов сумми-
руются, а данные о ценах усредняются. В любой момент
времени можно получить информацию о том, каков инте-
рес к спектаклям в порядке убывания отдельно для взрос-
лых и для детей, а также узнать в порядке убывания об-
щую прибыль от спектакля.
    Задание 28. В зале кинотеатра 10 рядов по 15 мест. С 3
по 7 ряд — VIP-места. Стоимость билетов на них в 2 раза
дороже, чем на другие места. 1 и 2 ряды в 1,5 раза дешев-
ле прочих. На обычный сеанс билет стоит K1 руб., на пре-
мьерный K2 руб., на льготный K3 руб. При продаже биле-
тов данные заносятся в текстовый файл в виде матрицы
занятости мест. Найти сумму, на которую продано биле-
тов. Использовать функции формирования и обработки
матрицы.
    Задание 29. В зале кинотеатра n рядов, в каждом из
которых m мест. При бронировании и продаже билетов
формируется карта занятости мест, которая сохраняется
в текстовом файле после очередной операции. Нужно по-
мочь кассиру и зрителю выполнить процедуру бронирова-
ния, для чего организовать диалог:
  • показать на экране карту занятости мест в зале;
  • показать зрителю выбранное им место;
  • зафиксировать выбор места по договоренности со зри-
    телем;
  • сохранить измененную карту;
  • подсчитать стоимость билетов.
    Задание 30. Дана матрица размером 5?3. Это жители
Средиземья организовали курсы информатики. По окон-
чании курсов всем выдали свидетельства. Похвальные
листы нужно вручить трем лучшим слушателям. Най-
За д ач и и у п р аж н е н и я                                365


дите лучших, если данные записаны в текстовом файле
в форме таблицы следующего вида.
                                 MS Word   MS Excel   MS Access
 Фродо Беггинз                     5          5          3
 Бильбо Беггинз                    3          4          5
 Гэндальф                          3          5          5
 Двалин                            5          4          3
 Гвалин                            3          5          5
 Бифур                             3          4          3
 Бофур                             5          4          3
 Бомбур                            3          4          4
 Торин Оукеншильд                  5          4          4

     Использовать функции обработки данных.

     Тема 12. Работа со структурами
     и объединениями
   Структура позволяет объединить в единое целое про-
извольное количество данных различных типов. Поэтому
все задачи, которые требуют логического объединения
каких-то данных, могут и должны использовать струк-
турный тип. Данные, входящие в структуру, достаточно
независимы. Они имеют собственные имена и возмож-
ность выполнить над ними любые операции, разрешен-
ные их типом.
   Рассмотрим пример использования структур в неко-
торой модельной задаче, т. е. такой, которая не имеет осо-
бенного практического смысла, но позволяет продемон-
стрировать достоинства структурного типа, его возмож-
ности и механизмы. Пусть структура объединяет некую
информацию об одном абстрактном объекте (человеке):
имя, фамилия и какие-то данные числового характера,
например, возраст, рост, средняя зарплата и т. д., назовем
их показателями. Пусть имеются сведения о некотором
множестве объектов, т. е. о некотором сообществе людей,
например, студентов какого-либо факультета, сотрудни-
ков некоторой организации, случайной статистической
выборки.
366                                               Гл а в а 3



    Объект называется среднестатистическим, если на
нем достигается минимум модуля разности среднего ариф-
метического значений его показателей со средним ариф-
метическим всей группы объектов. Аналогично определя-
ется уникальный объект (на нем достигается максимум).
    Объект может быть назван среднестатистическим по
k-му параметру, (уникальным по k-му параметру), тогда
рассматриваются данные о значении k-го показателя это-
го объекта в сравнении со средним значением k-го показа-
теля по всей совокупности объектов.
    Выясним, кто в группе объектов является:
    а) среднестатистическим;
    б) среднестатистическим по отдельным показателям;
    в) просто поставим задачу найти объект в группе по
ключевому значению.
    Для описания одного объекта используется структура.
Попытаемся отразить в примере возможности этого типа
данных. В качестве полей структуры используем простые
типы данных, массив и строки, причем одна строка будет
статической, а вторая динамической. Для хранения имени
используем статическую строку, для хранения фамилии
динамическую, для хранения показателей используем
массив (ограничимся пятью показателями). Информация
о среднем арифметическом показателей каждого объекта
может быть вычислена при получении объектом данных.
Ее можно сохранить, для этого введем в структуру поля,
имеющие смысл «Сумма показателей» и «Среднее ариф-
метическое показателей», соответственно, данные целого
и вещественного типов.
    Поскольку в группе объектов несколько данных, сле-
дует объединить их в массив, где один элемент массива
описывает один объект.
    Выполним функциональную декомпозицию задачи,
т. е. определим, какие алгоритмы обработки понадобятся
для ее решения.
    1. Сначала подумаем, откуда взять данные. Напри-
мер, их можно ввести.
    2. Для работы с одним объектом пригодятся функции
ввода данных об одном объекте и вывода данных об одном
За д ач и и у п р аж н е н и я                      367


объекте. Имя формального параметра пусть будет Man,
это полные данные об одном объекте.
    3. Чтобы иметь возможность визуально сравнить дан-
ные, требуется вывод общей информации, идеально под-
ходит таблица.
    4. Для поиска среднего арифметического по группе
объектов и для поиска среднего по какому-то показателю
требуются функции, которые возвращают значение сред-
него по всей группе объектов и по одному показателю. Эти
функции похожи внешне и по смыслу, но первая будет
работать со средним данным всего объекта, а вторая, по-
лучив в качестве параметра номер показателя, будет рабо-
тать только с этим элементом массива показателей.
    Функция поиска может вернуть номер элемента в мас-
сиве структур или указатель на объект. Покажем это на
примере функций поиска. Функция поиска среднестати-
стического объекта вернет его номер в массиве структур.
Имея функцию вывода, мы легко выведем его данные
на экран с использованием операции разыменования [].
Функция поиска среднего по k-му показателю вернет ука-
затель на структуру. Имея функцию вывода, мы легко
выведем его данные на экран с использованием операции
разыменования *.
    Все эти функции требуют полные данные обо всей
группе объектов. Формальный параметр, используемый
в их описании, тоже имеет имя Man, но теперь он имеет
совсем другую смысловую нагрузку, обозначая имя всей
совокупности данных обо всех объектах, т. е. о массиве
объектов.
    Поиск по ключевому значению, например, по фами-
лии, не внесет ничего нового, просто добавим его, чтобы
лишний раз показать механизмы работы со строками
символов.
    Описание абстрактного типа «Объект» с именем Person
использует инструкцию typedef, потому что объявлений
объектов указанного типа будет несколько.
#include <stdio.h>
#include <io.h>#include <conio.h>
#include <math.h>
368                                                  Гл а в а 3



#include <string.h>

typedef struct
{
   char Name[10];
   // поле "Имя", статический символьный массив
   char *Surname;
   // поле "Фамилия", динамический символьный массив
   // для него нужно выделить динамическую память
   // перед присваиванием значения
   int Data[5]; // поле "Показатели", статический массив
   int Sum;      // поле "Сумма" накапливает и сохраняет
		               // сумму баллов
   float Var;    // поле "Среднее" вычисляет и сохраняет
		               // средний показатель
} Person;        // имя типа данного "Person"
   Функция ввода данных об одном объекте возвращает
объект.
void In(Person & Man)
// одно данное типа Person возвращается по ссылке
{
   puts("Введите имя: ");
   scanf("%s", &Man.Name);
   puts("Введите фамилию: ");
   // обязательно выделить память
   // число символов фамилии не более 10
   Man.Surname=new char[10];
   scanf("%s", Man.Surname);
   //& при вводе значения указателя не пишем
   puts("Введите данные: ");
   Man.Sum=0;
   // будет накоплена сумма показателей при вводе
   for(int i=0; i<5; i++)
   {
?? scanf("%4d", &Man.Data [i]);
?? Man.Sum+=Man.Data[i];
   }
   Man.Var=(float)Man.Sum/5.; // вычислен средний
				                           // показатель
За д ач и и у п р аж н е н и я                           369


}
     Функция вывода полных данных об одном объекте.
void Out(Person Man) // передается данное типа Person
{
  printf("%s ", Man.Name);
  printf("%s ", Man.Surname);
  for(int i=0; i<5; i++)
?? printf("%4d",Man.Data[i]);
  // показатели выводятся одной строкой
  printf("\nСумма баллов=%d ", Man.Sum);
  printf("Среднее= %6.2f\n", Man.Var);
}
   Функция вывода данных обо всех объектах в форме
таблицы.
void Out_All(Person Man [], int n)
// передается n данных типа Person
{
   printf("=========================================\n");
   printf("ИМЯ \t ФАМИЛИЯ \t ДАННЫЕ \t CУММА СРЕДНЕЕ\n");
   printf("=========================================\n");
   for(int k= 0;k<n; k++)
   {
?? printf("% –10s ", Man[k].Name);
?? printf("% –10s ", Man[k].Surname);
?? for(int i=0; i<5; i++)
?? printf("%4d", Man[k].Data[i]);
?? printf("%4d ",Man[k].Sum);
?? printf("%6.2f \n",Man[k].Var);
   }
   printf("=========================================\n");
}
   Функция вычисляет средний показатель по всем объ-
ектам, суммируя данные полей Var по всему массиву Man.
float Sred(Person Man [], int n)
// передается n данных типа Person
{
   float Var=0;		        // переменная Var не имеет
			                      // отношения к полю структуры
			                      // с именем Var
370                                                      Гл а в а 3



  for(int i= 0; i<n; i++)
?? Var+= Man[i].Var;
  return Var/(float)n;      // среднее по всем средним
}
   Функция вычисляет средний показатель по k-му пара-
метру. Номер показателя (от 0 до 5) — это один из параме-
тров функции.
float Sred_k(Person Man[], int n, int k)
// передается n данных типа Person и номер показателя k
{
   float Var_k=0;		       // Var_k – средний по одному
			                       // показателю
   for(int i=0; i<n; i++)
?? Var_k+=(float)Man[i].Data[k];
// складывает один k-й показатель по всем объектам
return Var_k/(float) n;   // среднее по k-му показателю
}
     Функция Sred_Stat определяет номер среднестати-
стического объекта в массиве. Ей передается весь массив
структур.
int Sred_Stat(Person Man [], int n)
// передается n данных типа Person
{
   float Var_All=Sred(Man,n);
   // средний показатель по всем объектам.
   float Var_min=fabs(Var_All–Man[0].Var);
   int Nom=0;       // наименьший имеет номер 0
   for(int i=0; i<n; i++)
   if(fabs(Var_All–Man[i].Var)<Var_min)
?? Nom=i;           // запоминаем номер самого среднего
   return Nom;
}
      Функция Sred_Stat_k определяет объект, среднестати-
стический по k-му показателю. Ей передается весь массив
структур, функция возвращает указатель на найденный
объект.
Person *Sred_Stat_k(Person Man[], int n, int k)
// передается n данных типа Person и номер показателя
{
За д ач и и у п р аж н е н и я                         371


  float Var_k=Sred_k(Man, n, k);
  // находим среднее значение k-го показателя
  // по всем объектам
  float Var_min=fabs(Var_k–Man[0].Data[k]);
  Person *Nom=Man;
  // указатель Nom запоминает адрес объекта
  for(int i=0; i<n; i++)
?? if(fabs(Var_k–Man[i].Data[k])<Var_min)
??? Nom = Man+i;
  // запоминаем адрес самого среднего
  return Nom;
}
   Функция поиска объекта по фамилии. Передается n дан-
ных типа Person, и Who — строка, содержащая фамилию ис-
комого объекта. Выполняется прямой поиск по всей группе
объектов путем последовательного сравнения искомой стро-
ки с полем Surname каждого элемента массива Man. Функ-
ция возвращает указатель на найденный объект или NULL.
Person *Found_Fam(char *Who, Person Man[], int n)
{
  for(int i=0; i<n; i++)
?? if(strcmp (Who ,Man[i].Surname)==0) // если найдено
??? return Man+i;                      // возвращает адрес
  return NULL;
  // возвращает NULL, если поиск неудачен
}
    Продемонстрируем текст программы, которая объяв-
ляет данные и осуществляет управление ими путем вызо-
ва функций обработки данных.
void main (void)
{
int n;
// объявлен массив структур
Person All_Person[20];
printf("Введите количество\n");
// реальное количество данных n
scanf("%d", &n);

// ввод данных выполняется в цикле вызова функции In
372                                                 Гл а в а 3



for(int i=0; i<n; i++)
{
  In(All_Person[i]);
}

// Вывод на экран полной таблицы.
Out_All(All_Person,n);

// поиск номера среднестатистического объекта
int Found=Sred_Stat(All_Person, n);
printf("Самый средний имеет номер: %d\n", Found);
printf("Его данные: \n");
Out(All_Person [Found]);

// снова выведем таблицу на экран
Out_All(All_Person,n);

// поиск значения объекта, среднестатистического
// по k-му показателю
Person *Found_k;
for(int k=0;k<5;k++)
{
   printf("Средний по %d -му показателю\n", k);
   Found_k=Sred_Stat_k(All_Person, n, k);
   Out(*Found_k);
}

// поиск объекта по фамилии
char Surname[10];
// тоже фамилия, но не та, что в Person
puts("Введите строку для поиска\n");
scanf("%s", Surname);
Person *Who; // хранит адрес, возвращенный функцией
Who=Found_Fam(Surname, All_Person, n);
   if(Who!=NULL)       // проверяем, найден объект или нет
?? Out(*Who);
   else
?? puts("Такого нет.\n");
} // End of main
За д ач и и у п р аж н е н и я                      373

                                 Варианты заданий
   Задание 1. Определить структуру для регистрации ав-
томашин. Она должна иметь следующие поля: фамилия
владельца, дата регистрации, марка машины, год выпу-
ска, цвет, регистрационный номер.
   Написать и протестировать функции для регистрации
новой машины, удаления машины из регистрационного
списка, поиска машины по марке и по цвету, а также по
сочетанию признаков «марка и цвет».
   Задание 2. Определить структуру, описывающую ба-
гаж пассажира, с полями: количество вещей и общий вес
вещей. Пусть имеются данные о багаже нескольких пас-
сажиров, где информация о багаже каждого отдельного
пассажира представляет собой соответствующую пару чи-
сел.
   Написать и протестировать функции для ввода и вы-
вода общей информации о багаже. Найти число пассажи-
ров, имеющих не более двух вещей. Найти число пасса-
жиров, количество вещей которых превосходит среднее
число вещей.
   Задание 3. Определить структуру, описывающую ба-
гаж пассажира, с полями: количество вещей и общий вес
вещей. Пусть имеются данные о багаже нескольких пас-
сажиров, где информация о багаже каждого отдельного
пассажира представляет собой соответствующую пару чи-
сел.
   Написать и протестировать функции для ввода и вы-
вода общей информации о багаже. Определить, имеются
ли два пассажира, багажи которых совпадают по числу
вещей и различаются по весу не более чем на 0,5 кг. Вы-
яснить, имеется ли пассажир, багаж которого превышает
багаж каждого из остальных пассажиров и по числу ве-
щей и по весу.
   Задание 4. Определить структуру, описывающую ба-
гаж пассажира, с полями: количество вещей и общий вес
вещей. Пусть имеются данные о багаже нескольких пас-
сажиров, где информация о багаже каждого отдельного
пассажира представляет собой соответствующую пару
чисел.
374                                                  Гл а в а 3



    Написать и протестировать функции для ввода и вы-
вода общей информации о багаже. Выяснить, имеется ли
пассажир, багаж которого состоит из одной вещи весом не
менее 30 кг. Дать сведения о багаже, число вещей в кото-
ром не меньше, чем в любом другом багаже, а вес вещей
не больше, чем в любом другом багаже с этим же числом
вещей.
    Задание 5. Определить структуру, описывающую
сведения об ученике, с полями: имя, фамилия, название
класса, в котором он учится (год обучения и буква).
    Написать и протестировать функции для добавления
нового ученика, для вывода информации об одном учени-
ке и вывода общей информации. Выяснить, имеются ли
в школе однофамильцы. Выяснить, имеются ли однофа-
мильцы в каких-нибудь классах.
    Задание 6. Определить структуру, описывающую
сведения об ученике, с полями: имя, фамилия, название
класса, в котором он учится (год обучения и буква).
    Написать и протестировать функции для добавления
нового ученика, для вывода информации об одном учени-
ке и вывода общей информации. Выяснить, в каких клас-
сах больше чем n учащихся. Выяснить, сколько человек
учится в каждой параллели.
    Задание 7. Определить структуру, описывающую све-
дения об ученике, с полями: имя, фамилия, название клас-
са, в котором он учится (год обучения и буква), а также от-
метки, полученные учениками в последней четверти.
    Написать и протестировать функции для добавления
нового ученика, для вывода информации об одном уче-
нике и вывода общей информации. Выяснить, сколько
учеников имеют отметки не ниже 4. Выяснить, сколько
учеников имеют тройки в четверти.
    Задание 8. Определить структуру, описывающую дату,
с полями число, название месяца, год. Написать и протести-
ровать функции для ввода и вывода даты в формате «ЧЧ.
ММ.ГГ» и «ЧЧ Месяц ГГ». Пусть есть некоторое количество
дат, связанных с некоторым событием, например, историче-
ской датой. Написать и протестировать функции для сорти-
ровки этих данных по дате и по названию события.
За д ач и и у п р аж н е н и я                      375


    Задание 9. Определить структуру, описывающую све-
дения о книге, с полями: фамилия автора, название и год
издания.
    Написать и протестировать функции для добавления
новой книги, для вывода информации об одной книге
и вывода общей информации. Написать и протестировать
функции для поиска по фамилии автора, по году издания,
а также по совокупности этих признаков.
    Задание 10. Определить структуру, описывающую
сведения о книге, с полями: фамилия автора, название,
год издания.
    Написать и протестировать функции для добавления
новой книги, для вывода информации об одной книге
и вывода общей информации. Написать и протестировать
функции для поиска по названию книги, и по ключевому
слову названия. Например, если название книги «Инфор-
матика и программирование», то она должна быть найде-
на и по ключевому слову «Информатика», и по ключевому
слову «Программирование». Если таких книг несколько,
то сообщить сведения обо всех книгах.
    Задание 11. Определить структуру, описывающую
сведения о сотрудниках учреждения, с полями: фамилия,
имя, отчество, занимаемая должность, номер телефона.
    Написать и протестировать функции для добавления
нового сотрудника, для вывода информации об одном че-
ловеке и вывода общей информации. Написать и проте-
стировать функции для поиска сотрудника по фамилии
и по должности.
    Задание 12. Определить структуру, описывающую ку-
бики: размер (длина ребра в сантиметрах), цвет (красный,
желтый, зеленый или синий) и материал (деревянный,
металлический, картонный).
    Написать и протестировать функции для ввода и вывода
данных, а также функции поиска количества кубиков каж-
дого из перечисленных цветов и их суммарного объема.
    Задание 13. Определить структуру, описывающую
кубики: размер кубика (длина ребра в сантиметрах), его
цвет (красный, желтый, зеленый или синий) и материал
(деревянный, металлический, картонный).
376                                              Гл а в а 3



    Написать и протестировать функции для ввода и вы-
вода данных, а также функции поиска количества куби-
ков с указанными значениями «материал» и «длина ре-
бра». Например, найти количество деревянных кубиков
с ребром 3 см и количество металлических кубиков с ре-
бром 5 см.
    Задание 14. Определить структуру, описывающую све-
дения о веществах: название вещества, его удельный вес
и проводимость (проводник, полупроводник, изолятор).
    Написать и протестировать функции для ввода и вы-
вода данных. Написать и протестировать функции для
поиска по названию вещества и по проводимости. Найти
удельные веса и названия всех проводников.
    Задание 15. Определить структуру, описывающую све-
дения о веществах: название вещества, его удельный вес
и проводимость (проводник, полупроводник, изолятор).
    Написать и протестировать функции для ввода и вы-
вода данных. Написать и протестировать функции для со-
ртировки данных по любому из признаков.
    Задание 16. Определить структуру, описывающую
сведения об игрушках: название игрушки, ее стоимость
и возрастные границы детей, для которых она предназна-
чена (например, для детей от 2 до 5 лет).
    Написать и протестировать функции для ввода и выво-
да данных. Написать и протестировать функцию поиска,
чтобы получить сведения о названиях игрушек, цена кото-
рых не превышает k руб. и которые подходят детям n лет.
Написать и протестировать функцию поиска, чтобы полу-
чить сведения о самом дорогом, например, конструкторе.
    Задание 17. Определить структуру, описывающую
сведения об игрушках: название игрушки, ее стоимость
и возрастные границы детей, для которых она предназна-
чена (например, для детей от 2 до 5 лет).
    Написать и протестировать функции для ввода и вы-
вода данных. Написать и протестировать функцию поис-
ка по наименованию. Написать и протестировать функ-
цию поиска, чтобы получить сведения о названиях наи-
более дорогих игрушек (цена которых отличается от цены
самой дорогой игрушки не более чем на 10 руб.).
За д ач и и у п р аж н е н и я                                          377


    Задание 18. Определить структуру, описывающую
сведения об игрушках: название игрушки, ее стоимость
и возрастные границы детей для которых она предназна-
чена (например, для детей от 2 до 5 лет).
    Написать и протестировать функции для ввода и выво-
да данных. Написать и протестировать функцию поиска по
диапазону цены. Написать и протестировать функцию по-
иска, чтобы подобрать игрушку любую, кроме мяча, под-
ходящую ребенку 3 лет, и дополнительно мяч так, чтобы
суммарная стоимость игрушек не превосходила 100 руб.
    Задание 19. Определить структуру, описывающую
сведения об игрушках: название игрушки, ее стоимость
и возрастные границы детей для которых она предназна-
чена (например, для детей от 2 до 5 лет).
    Написать и протестировать функции для ввода и вы-
вода данных. Написать и протестировать функцию поис-
ка, чтобы подобрать игрушку по названию, по цене, и по
возрастному диапазону. Например, все мячи ценой n руб.,
предназначенный детям от 3 до 8 лет.
    Задание 20. Имеются сведения о сотрудниках учреж-
дения в следующем виде: табельный номер сотрудника,
его фамилия, имя, отчество, оклад. Определить структу-
ру для представления этих данных.
    Написать и протестировать функции для ввода дан-
ных и вывода в виде таблицы. Написать и протестиро-
вать функции для поиска по табельному номеру, по фа-
милии. Вычислить среднюю заработную плату всех со-
трудников.
    Задание 21. Имеются сведения об изделиях, выпу-
скаемых малым предприятием: наименование изделия,
годовой план выпуска изделий в штуках, фактический
поквартальный выпуск каждого изделия.
 №      Наименование        Годовой план   Фактический выпуск по кварталам
 п/п      изделия             выпуска       I        II      III      IV
  1    Стул                      100       10       20       35       35



  Определить структуру для представления этих дан-
ных.
378                                                        Гл а в а 3



    Написать и протестировать функции для ввода дан-
ных и вывода в виде таблицы. Написать и протестировать
функции для определения фактического выпуска изделий
и процента выполнения плана по каждому виду изделий.
Написать функцию поиска по наименованию с выводом
общей информации.
    Задание 22. Имеются данные о выпускаемых издели-
ях: наименование изделия, артикул, себестоимость изде-
лия и его цена. Определить структуру для представления
этих данных. Написать и протестировать функции для
ввода данных и вывода в форме полной ведомости выпу-
скаемых изделий следующего вида.
№ п/п   Наименование изделия    Артикул   Себестоимость    Цена



   Написать и протестировать функции для поиска из-
делий по наименованию и по диапазону цен. (Например,
цена не превышает K1 руб., но более K2 руб.)
   Задание 23. Известны сведения о себестоимости не-
которых видов продукции: наименование, Jм — индекс
изменения норм расхода на данный вид материальных
затрат; Jц — индекс изменения оптовых цен на данный
вид; Jп — индекс выпуска продукции; Do — отноше-
ние стоимости основных и вспомогательных материалов
к выпуску товарной продукции по отчету; Тпп — объем
товарной продукции по плану. На основании этих дан-
ных может быть вычислена экономия от снижения себе-
стоимости, которая вычисляется по формуле:
                Э = (1 – Jм • Jц) • Dо • Jп • Тпп.
   Определить структуру для представления этих дан-
ных. Разработать функции для ввода данных и вывода
в форме выходной ведомости следующего вида.
Наименование     Jм        Jц        Jп     Dо       Тпп     Э




   Здесь Э — экономия, которая должна быть вычислена
для каждого наименования. Написать и протестировать
За д ач и и у п р аж н е н и я                                              379


функции для добавления новых данных, а также для по-
иска наименований, для которых достигнута наибольшая
и наименьшая экономия.
   Задание 24. В магазине ведется учет продажи това-
ров. По каждому товару известны наименование товара,
цена, торговая надбавка, количество проданного товара.
Определить структуру для представления этих данных.
Разработать функции для ввода данных и вывода в форме
отчетной ведомости следующего вида.
 Наименование                       Торговая                          Общая
                    Цена, руб.                     Количество
    товара                         надбавка, %                      стоимость




   Написать и протестировать функции для добавления
данных о новом товаре, для поиска по наименованию, для
вычисления общей итоговой стоимости продаж.
   Задание 25. Известны данные о выпускаемой про-
дукции по цехам предприятия: название цеха, отноше-
ние стоимости основных и вспомогательных материалов
к выпуску продукции по отчету Dо и по плану Dп, объем
товарной продукции по плану Тп.
   Определить структуру для представления этих дан-
ных. Разработать функции для ввода данных и вывода
в форме выходной ведомости следующего вида.
          Отношение стоимости основных           Объем товарной     Экономия
          и вспомогательных материалов            продукции по     от снижения
 Цех     к объему выпускаемой продукции              плану        себестоимости
                     Dо                  Dп            Тп              Э



   Здесь экономия от снижения себестоимости по каждо-
му цеху вычисляется по формуле:
                                 Э = (Dо – Dп) · Тп.
   Написать и протестировать функции, чтобы найти цеха,
для которых достигнута наибольшая и наименьшая эконо-
мия, а также для поиска информации по названию цеха.
   Задание 26. В выпуске продукции принимают участие
несколько бригад, для которых ведется помесячный учет.
Бригады имеют номера. Определить структуру для представ-
380                                                                   Гл а в а 3



ления этих данных. Разработать функции для ввода данных
и вывода в форме выходной ведомости следующего вида.
                Номер бригады
 Месяц                                     Итоговая выработка по месяцам
           1      2      3      4



    Написать и протестировать функции, чтобы найти
среднюю выработку по бригадам за весь отчетный период,
а также для поиска сведений о выработке за указанный
месяц по названию месяца.
    Задание 27. Предприятие нанимает работников на
сдельную работу. Для каждого из них ведется ежеднев-
ный учет: фамилия, имя, отчество, разряд, расценка за
единицу продукции, количество произведенных изделий.
Определить структуру для представления этих данных.
Разработать функции для ввода данных и вывода в форме
расчетной ведомости следующего вида.
  ФИО      Разряд        Расценки            Количество          Сумма



   Написать и протестировать функции, чтобы найти об-
щую выработку за день и общую сумму к оплате. Сохра-
нить эти данные в виде таблицы.
   Дата         Произведено (количество)                  Оплачено



    Задание 28. Для каждого участка цеха завода имеют-
ся сведения о количестве отпущенных для производства
материалов: наименование материала, единица измере-
ния, объем отпущенного участку материала. Определить
структуру для представления этих данных. Разработать
функции для ввода данных и вывода с подведением ито-
гов в форме выходной ведомости следующего вида.
                  Единицы
 Наименование                Участок 1     Участок 2 Участок 3       Итого
                 измерения



   Написать и протестировать функции, чтобы найти
общий расход материалов каждым участком, и всего по
цеху, а также для поиска по наименованию.
За д ач и и у п р аж н е н и я                                         381


   Задание 29. На складе ведется учет наличия товаров.
Для подведения итогов месяца есть сведения: наименова-
ние товара; количество поступившего и реализованного
товара за месяц. Определить структуру для представле-
ния этих данных. Разработать функции для ввода данных
и вывода в форме оборотной ведомости следующего вида.
 Наименование           Поступило       Реализовано          Разница
    товара               за месяц         за месяц




   Написать и протестировать функции, чтобы найти об-
щий приход товара и общий расход, а также для вывода
отчета об остатках товара на складе по форме.
              Наименование товара                        Остаток



   Задание 30. На предприятие поступает сырье разного
вида. Учет поступления сырья ведется по следующим по-
зициям: вид сырья (наименование), плановое поступле-
ние, фактическое поступление. Определить структуру
для представления этих данных. Разработать функции
для ввода данных и вывода в форме отчетной ведомости
следующего вида.
                    Плановое        Фактическое       Процент выполнения
  Вид сырья        поступление      поступление             плана




   Написать и протестировать функции, чтобы найти об-
щий объем плановых поступлений и общий объем факти-
ческих поступлений, а также для поиска по наименова-
нию.
                Библиографический список


1. Вирт, Н. Алгоритмы и структуры данных / пер. с англ.
     Д. Б. Подшивалова. — М. : Мир, 1989. — 360 с.
2. Гагарина, Л. Г. Алгоритмы и структуры данных : учеб. по-
     собие / Л. Г. Гагарина, В. Д. Колдаев. — М. : Финансы и ста-
     тистика : ИНФРА-М, 2009. — 302 с.
3. Голицына, О. Л. Основы алгоритмизации и программирова-
     ния : учеб. пособие / О. Л. Голицына, И. И. Попов. — М. :
     Форум, 2010. — 429 с.
4. Канцедал, С. А. Алгоритмизация и программирование :
     учеб. пособие. — М. : Форум : ИНФРА-М, 2011. — 351 с.
5. Культин, Н. Б. С/С++ в задачах и примерах. — СПб. : БХВ-
     Петербург, 2004. — 288 с.
6. Мишенин, А. И. Сборник задач по программированию : учеб.-
     метод. пособие. — М. : Финансы и статистика : ИНФРА-М,
     2009. — 221 с.
7. Незнанов, А. А. Программирование и алгоритмизация :
     учебник. — М. : Академия, 2010. — 303 с.
8. Павловская, Т. А. C/C++. Программирование на языке вы-
     сокого уровня : учебник. — СПб. : Питер, 2013. — 238 с.
9. Павловская, Т. А. Программирование на языке высокого
     уровня : учебник. — СПб. : Питер, 2013. — 432 с.
10. Подбельский, В. В. Программирование на языке Си : учеб.
     пособие / В. В. Подбельский, С. С. Фомин. — М. : Финансы
     и статистика, 2009. — 600 с.
11. С и С++: Алгоритмы и приемы программирования : пер с англ. /
     А. Фридман, Л. Кландер, М. Михаэлис, Г. Шилдт ; под ред.
     В. Тимофеева. — М. : Бином: Бином-пресс, 2003. — 560 с.
12. Синицын, С. В. Программирование на языке высокого уров-
     ня : учебник / С. В. Синицин, А. С. Михайлов, О. И. Хлыт-
     чиев. — М. : Академия, 2010. — 392 с.
13. Тимофеева, Т. С. Задачи по программированию : учеб. посо-
     бие / Т. С. Тимофеева, О. А. Тихонова, И. Г. Ларионова ; под
     ред. В. И. Васильева. — М. : Вузовская книга, 2011. — 94 с.
14. Франка, П. С++. — СПб. : Питер, 2012. — 491 с.
15. Чиртик, А. А. Программирование на С++. — СПб. : Питер,
     2010. — 346 с.
16. 	Шилдт, Г. Самоучитель С++ / пер. с англ. А. Жданова. —
     СПб. : BHV-Петербург, 2005. — 683 с.
                                                                  Оглавление


Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
Глава 1. Основы алгоритмизации. . . . . . . . . . . . . . . . . . . . . . . . . 5
   1.1. Определение алгоритма и его свойства . . . . . . . . . . . . . . 5
   1.2. Базовые алгоритмические конструкции. . . . . . . . . . . . . 8
   1.3. Алгоритмы, использующие одномерные массивы . . . . 20
   1.4. Алгоритмы, использующие двумерные массивы . . . . . 32
   1.5. Алгоритмы сортировки. . . . . . . . . . . . . . . . . . . . . . . . . . 41
   1.6. Алгоритмы поиска . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
Глава 2. Основы программирования на языке C++. . . . . . . . . . 61
   2.1. Начальные сведения о языке программирования
          C++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
   2.2. Операции и выражения языка C++. . . . . . . . . . . . . . . . 73
   2.3. Структура и компоненты простой программы
          на языке C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
   2.4. Управляющие конструкции языка C++ . . . . . . . . . . . . 90
   2.5. Механизм функций языка C++ . . . . . . . . . . . . . . . . . . 119
   2.6. Локальные и глобальные данные. Время жизни
          и область действия объектов. . . . . . . . . . . . . . . . . . . 137
   2.7. Производные типы данных . . . . . . . . . . . . . . . . . . . . . 142
   2.8. Файлы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
Глава 3. Задачи и упражнения . . . . . . . . . . . . . . . . . . . . . . . . . 205
   Тема 1. Простые программы на языке С++ . . . . . . . . . . . . 205
   Тема 2. Использование условного оператора if
          и переключателя switch . . . . . . . . . . . . . . . . . . . . . . 214
   Тема 3. Инструменты С++ для реализации
          циклических алгоритмов . . . . . . . . . . . . . . . . . . . . . 228
   Тема 4. Алгоритмы вычисления сумм, произведений,
          количеств, пределов, последовательностей.
          Сложные циклы. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
   Тема 5. Использование циклических алгоритмов
          в решении содержательных задач . . . . . . . . . . . . . . 258
   Тема 6. Практическое использование механизма
          функций. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
   Тема 7. Работа с одномерными массивами. . . . . . . . . . . . . 285
   Тема 8. Использование одномерных массивов
          в содержательных задачах . . . . . . . . . . . . . . . . . . . . 313
   Тема 9. Работа с двумерными массивами.
          Использование функций. . . . . . . . . . . . . . . . . . . . . . 319
                    Елена Александровна КОНОВА,
                     Галина Андреевна ПОЛЛАК
       АЛГОРИТМЫ И ПРОГРАММЫ. ЯЗЫК С++
                        Учебное пособие
                    Издание второе, стереотипное
                             Зав. редакцией
              естественнонаучной литературы М. В. Рудкевич
                         ЛР № 065466 от 21.10.97
             Гигиенический сертификат 78.01.10.953.П.1028
                   от 14.04.2016 г., выдан ЦГСЭН в СПб
                          Издательство «ЛАНЬ»
                    lan@lanbook.ru; www.lanbook.com
          196105, СанктПетербург, пр. Ю. Гагарина, д. 1, лит. А.
                  Тел./факс: (812) 3362509, 4129272.
              Бесплатный звонок по России: 88007004071

                               ГДЕ КУПИТЬ
                         ДЛЯ ОРГАНИЗАЦИЙ:
Для того, чтобы заказать необходимые Вам книги, достаточно обратиться
      в любую из торговых компаний Издательского Дома «ЛАНЬ»:
                            по России и зарубежью
  «ЛАНЬТРЕЙД». 196105, СанктПетербург, пр. Ю. Гагарина, д. 1, лит. А.
   тел.: (812) 4128578, 4121445, 4128582; тел./факс: (812) 4125493
                 email: trade@lanbook.ru; ICQ: 446869967
                               www.lanbook.com
                          пункт меню «Где купить»
                      раздел «Прайслисты, каталоги»
                    в Москве и в Московской области
     «ЛАНЬПРЕСС». 109263, Москва, 7я ул. Текстильщиков, д. 6/19
           тел.: (499) 1786585; email: lanpress@lanbook.ru
                   в Краснодаре и в Краснодарском крае
            «ЛАНЬЮГ». 350901, Краснодар, ул. Жлобы, д. 1/1
              тел.: (861) 2741035; email: lankrd98@mail.ru
                  ДЛЯ РОЗНИЧНЫХ ПОКУПАТЕЛЕЙ:
                           интернет5магазин
              Издательство «Лань»: http://www.lanbook.com
                       магазин электронных книг
                     Global F5: http://globalf5.com/

                     Подписано в печать 01.11.16.
       Бумага офсетная. Гарнитура Школьная. Формат 84?108 1/32.
           Печать офсетная. Усл. п. л. 20,16. Тираж 100 экз.
                             Заказ № 32916.
                     Отпечатано в полном соответствии
              с качеством предоставленного оригиналмакета
                  в ПАО «Т8 Издательские Технологии».
             109316, г. Москва, Волгоградский пр., д. 42, к. 5.
